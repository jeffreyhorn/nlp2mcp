// Minimal, practical GAMS NLP subset grammar for nlp2mcp
// Notes:
// - Case-insensitive keywords handled via inline (?i: ...) blocks.
// - Identifiers allow quoted GAMS names: 'x.i', "cost%", etc.
// - Indexing like x(i,j) and sum(i, expr) supported.
// - Equations with =e=, =l=, =g=; bounds via x.lo(i) = ...; x.up(i) = ...;
// - One Solve statement: "Solve <name> using NLP [minimizing|maximizing] <objvar>;"
//
// You’ll still implement semantic checks in Python (dimensions, undefined symbols, etc).

start: stmt*  -> program

?stmt: sets_block
     | aliases_block
     | params_block
     | table_block
     | scalars_block
     | variables_block
     | equations_block
     | model_stmt
     | option_stmt
     | if_stmt
     | loop_stmt
     | display_stmt
     | abort_stmt
     | file_stmt
     | put_stmt
     | putclose_stmt
     | execute_stmt
     | acronym_stmt
     | assignment_stmt
     | equation_def
     | solve_stmt
     | SEMI

// ---------------------------
// Blocks
// ---------------------------

// Sprint 12 Day 5: Support unquoted inline descriptions in set declarations
// Sprint 12 Day 5 (Issue #417): Allow both space and newline separation for sets
// Note: SEMI is optional to handle GAMS files where new block keywords implicitly end previous blocks
sets_block: ("Sets"i | "Set"i) set_decl+ SEMI?

aliases_block: ("Aliases"i | "Alias"i) alias_decl+ SEMI

// Sprint 12 Day 5: Support unquoted inline descriptions in parameter declarations
// Same fix as variables_block - use NEWLINE to delimit declarations
// Note: SEMI is optional to handle GAMS files where new block keywords implicitly end previous blocks
params_block: ("Parameters"i | "Parameter"i) param_decl_list SEMI?

param_decl_list: param_decl (NEWLINE param_decl)*

// Sprint 19 Day 1: Added alternative without explicit domain for tables like "Table td 'desc'"
table_block: "Table"i ID "(" table_domain_list ")" (STRING | DESCRIPTION)? table_content+ SEMI
           | "Table"i ID (STRING | DESCRIPTION)? table_content+ SEMI

table_content: table_row | table_continuation

table_continuation: PLUS (table_value | ID | NUMBER)+

table_domain_list: table_domain ("," table_domain)*
table_domain: ID                      -> explicit_domain
            | "*"                     -> wildcard_domain
            | "(" wildcard_tuple ")"  -> wildcard_tuple_domain

wildcard_tuple: "*" ("," "*")+

scalars_block: ("Scalars"i | "Scalar"i) scalar_decl+ SEMI

// Sprint 12 Day 5: Support unquoted inline descriptions in variable declarations
// Even though NEWLINE is globally ignored, we explicitly reference it here
// to delimit variable declarations with inline descriptions
// Note: SEMI is optional to handle GAMS files where new block keywords implicitly end previous blocks
variables_block: var_kind? ("Variables"i | "Variable"i) var_decl_list SEMI?

var_decl_list: var_decl (NEWLINE var_decl)*

equations_block: ("Equations"i | "Equation"i) eqn_head_decl+ SEMI

// ---------------------------
// Declarations
// ---------------------------

// Sprint 12 Day 5 (Issue #417): Split into single vs list patterns to handle inline descriptions
// Two patterns: single declarations (with desc_text) and lists (without desc_text to avoid ambiguity)
set_decl: set_item ("," set_item)+          -> set_list
        | set_single_item                   -> set_single

// For single set declarations: allow desc_text or STRING
// Issue #424: Use SYMBOL_NAME instead of ID to prevent quoted strings as set names
set_single_item: SYMBOL_NAME "(" id_list ")" (STRING | desc_text)? "/" set_members "/"     -> set_domain_with_members
               | SYMBOL_NAME (STRING | desc_text)? "/" set_members "/"                     -> set_simple
               | SYMBOL_NAME (STRING | desc_text)? alias_opt "/" set_members "/"           -> set_aliased
               | SYMBOL_NAME "(" id_list ")" (STRING | desc_text)?                         -> set_domain
               | SYMBOL_NAME (STRING | desc_text)?                                         -> set_empty

// For comma-separated lists: only STRING allowed (desc_text would be ambiguous)
// Issue #424: Use SYMBOL_NAME instead of ID to prevent quoted strings as set names
set_item: SYMBOL_NAME "(" id_list ")" STRING? "/" set_members "/"     -> set_domain_with_members
        | SYMBOL_NAME STRING? "/" set_members "/"                     -> set_simple
        | SYMBOL_NAME STRING? alias_opt "/" set_members "/"           -> set_aliased
        | SYMBOL_NAME "(" id_list ")" STRING?                         -> set_domain
        | SYMBOL_NAME STRING?                                         -> set_empty

alias_decl: ID "," ID  "/" ID "/"                            -> alias_with_universe
          | alias_pair ("," alias_pair)+                     -> alias_multi
          | ID "," ID                                        -> alias_plain
          | alias_pair                                       -> alias_single

alias_pair: "(" ID "," id_list ")"

// Sprint 12 Day 5 (Issue #417): Split into single vs list patterns to handle inline descriptions
// Two patterns: single declarations (with desc_text) and lists (without desc_text to avoid ambiguity)
param_decl: param_item ("," param_item)+          -> param_list
          | param_single_item                     -> param_single

// For single parameter declarations: allow PARAM_DESC or STRING
// Issue #433: Use PARAM_DESC instead of desc_text to allow single-word descriptions like "partition"
param_single_item: ID "(" id_or_wildcard_list ")" (STRING | PARAM_DESC)? "/" param_data_items "/" param_default? -> param_domain_data
                 | ID "(" id_or_wildcard_list ")" (STRING | PARAM_DESC)? param_default?                          -> param_domain
                 | ID (STRING | PARAM_DESC)? "/" param_data_items "/" param_default?                             -> param_plain_data
                 | ID (STRING | PARAM_DESC)? param_default?                                                      -> param_plain

// For comma-separated lists: only STRING allowed (desc_text would be ambiguous)
param_item: ID "(" id_or_wildcard_list ")" STRING? "/" param_data_items "/" param_default? -> param_domain_data
          | ID "(" id_or_wildcard_list ")" STRING? param_default?                          -> param_domain
          | ID STRING? "/" param_data_items "/" param_default?                             -> param_plain_data
          | ID STRING? param_default?                                                      -> param_plain
scalar_decl: scalar_single_item                                          -> scalar_single
           | scalar_item (","? scalar_item)+                                 -> scalar_list

// For comma-separated or newline-separated lists:
// Issue #651: Support STRING descriptions in multi-scalar declarations.
// Use SYMBOL_NAME instead of ID to prevent quoted strings from being parsed as scalar names.
// SYMBOL_NAME matches only unquoted identifiers, so 'quoted text' cannot start a new scalar_item.
scalar_item: SYMBOL_NAME STRING "/" scalar_data_items "/" (ASSIGN expr)?  -> scalar_with_data
           | SYMBOL_NAME "/" scalar_data_items "/" (ASSIGN expr)?         -> scalar_with_data
           | SYMBOL_NAME STRING ASSIGN expr                               -> scalar_with_assign
           | SYMBOL_NAME ASSIGN expr                                      -> scalar_with_assign
           | SYMBOL_NAME                                                  -> scalar_plain

// For single scalar declarations: allow optional description (quoted STRING or unquoted DESC_TEXT)
// Sprint 12 Day 5 (Issue #417): Made DESC_TEXT optional with ? since terminal can't match empty
// Sprint 17 Day 4: Added STRING as alternative to DESC_TEXT to support quoted descriptions like 'freight cost'
scalar_single_item: ID (STRING | DESC_TEXT)? "/" scalar_data_items "/" (ASSIGN expr)?  -> scalar_with_data
                  | ID (STRING | DESC_TEXT)? ASSIGN expr                               -> scalar_with_assign
                  | ID (STRING | DESC_TEXT)?                                           -> scalar_plain

// Optional inline description text for variables/sets/params
// Sprint 12 Day 5: Require at least 2 words to avoid consuming variable names on subsequent lines
// This prevents "variables x\n y\n z;" from parsing "y z" as a description of x
// Multi-word descriptions like "total cost" (2+ words) still work
// Sprint 12 Day 5 (Issue #417): Make desc_text a terminal to prevent crossing newlines
// Pattern: 2+ words separated by spaces/tabs (not newlines)
// Words can contain letters, numbers, underscores, and hyphens
desc_text: DESC_TEXT

scalar_data_items: scalar_data_item ("," scalar_data_item)*
scalar_data_item: NUMBER

param_default: ASSIGN expr
param_data_items: param_data_item ("," param_data_item)*
// Sprint 16 Day 7: Added param_data_tuple_expansion for (a,b) value syntax (Issue P-4)
// Example: k(j) / (route-1,route-2) 13, route-5 1 / expands to route-1=13, route-2=13, route-5=1
// Issue #563: Added param_data_range_expansion for (ne2*ne5) 0 syntax
// Issue #564: Support special values (na, inf, eps) via param_data_value rule
param_data_item: data_matrix_row                              -> param_data_matrix_row
                 | "(" range_expr ")" param_data_value        -> param_data_range_expansion
                 | "(" set_element_id_list ")" param_data_value -> param_data_tuple_expansion
                 | data_indices NUMBER                        -> param_data_scalar

// Issue #564: Parameter data values can be numbers or special GAMS values (na, inf, eps, undf)
// Also handles signed special values like -inf and +inf
param_data_value: NUMBER | SPECIAL_VALUE | MINUS SPECIAL_VALUE | PLUS SPECIAL_VALUE
SPECIAL_VALUE: /(?i:na|inf|eps|undf)\b/

// Set element ID list for tuple expansion - comma-separated list of SET_ELEMENT_IDs or quoted strings
// Note: Preprocessor quotes hyphenated identifiers like route-1 to 'route-1', so we must accept STRING
set_element_id_list: set_element_id_or_string ("," set_element_id_or_string)*
set_element_id_or_string: SET_ELEMENT_ID | STRING

// data_indices can be numeric (e.g., parameter tau(nm) / 1 0.000, 2 0.025 /)
// Also allows hyphenated identifiers (e.g., parameter cost(i) / light-ind 100 /)
// Sprint 12 Day 5: Support range notation (e.g., foulds3*foulds5 -8)
// Issue #555: Support quoted strings as indices (e.g., / 'gov-expend' 110.5 /)
data_indices: range_expr
            | data_index ("." data_index)*

data_index: SET_ELEMENT_ID | NUMBER | STRING
// Matrix row must have at least 2 values (data_indices followed by 2+ NUMBERs) to disambiguate from scalar
data_matrix_row: data_indices NUMBER NUMBER+
data_matrix_values: NUMBER (NUMBER)*

// Variable declarations with support for unquoted inline descriptions
// Two patterns: single declarations (with desc_text) and lists (without desc_text)
var_decl: var_item ("," var_item)+                                  -> var_list
        | var_single_item                                           -> var_single

// For single variable declarations: allow desc_text (3+ words) or STRING
var_single_item: var_kind? ID "(" id_list ")" (STRING | desc_text)? -> var_item_indexed
               | var_kind? ID (STRING | desc_text)?                 -> var_item_scalar

// For comma-separated lists: only STRING allowed (desc_text would be ambiguous)
var_item: var_kind? ID "(" id_list ")" STRING?               -> var_item_indexed
        | var_kind? ID STRING?                               -> var_item_scalar

var_kind: POSITIVE_K | NEGATIVE_K | BINARY_K | INTEGER_K | FREE_K

POSITIVE_K: /(?i:positive)\b/
NEGATIVE_K: /(?i:negative)\b/
BINARY_K  : /(?i:binary)\b/
INTEGER_K : /(?i:integer)\b/
FREE_K    : /(?i:free)\b/

// NOTE: eqn_head_domain_list allows comma-separated equation names with domains,
// e.g., "Equations eq1, eq2(i,j);". This is NOT valid GAMS syntax according to
// the official specification, but we handle it gracefully to support user error recovery.
// Updated for Sprint 11 Day 1: Support nested/subset indexing like defdist(low(n,nn))
eqn_head_decl: id_list "(" domain_list ")" (STRING | DESCRIPTION)?  -> eqn_head_domain_list
             | ID "(" domain_list ")" (STRING | DESCRIPTION)?       -> eqn_head_domain
             | id_list (STRING | DESCRIPTION)?                      -> eqn_head_list
             | ID (STRING | DESCRIPTION)?                           -> eqn_head_scalar

alias_opt : "(" id_list ")"                                  -> alias_domain
id_list: ID ("," ID)*
id_or_wildcard_list: id_or_wildcard ("," id_or_wildcard)*
// Issue #425: Use WILDCARD terminal instead of literal "*" to preserve token in parse tree
id_or_wildcard: ID | WILDCARD
WILDCARD: "*"

set_members: set_member ("," set_member)*
// Sprint 16 Day 7: Added STRING STRING for quoted elements with descriptions (P-5)
// Preprocessor quotes hyphenated IDs, so 'cotton-h' 'cotton-herbaceo' is STRING STRING
// Issue #562: Added set_tuple_prefix_expansion for (a,b).c syntax
// Issue #567: Support quoted strings in tuple dot notation (e.g., upper.'u-egypt')
// Issue #568: Support hyphenated (quoted) prefix and suffixes in tuple expansion
?set_member: range_expr                          -> set_range
           | "(" set_element_id_list ")" "." SET_ELEMENT_ID  -> set_tuple_prefix_expansion
           | SET_ELEMENT_ID "." "(" set_element_id_list ")"  -> set_tuple_expansion
           | STRING "." "(" set_element_id_list ")"          -> set_tuple_expansion
           | SET_ELEMENT_ID "." SET_ELEMENT_ID STRING -> set_tuple_with_desc
           | SET_ELEMENT_ID "." STRING STRING    -> set_tuple_with_desc
           | STRING "." SET_ELEMENT_ID STRING    -> set_tuple_with_desc
           | STRING "." STRING STRING            -> set_tuple_with_desc
           | SET_ELEMENT_ID "." SET_ELEMENT_ID   -> set_tuple
           | SET_ELEMENT_ID "." STRING           -> set_tuple
           | STRING "." SET_ELEMENT_ID           -> set_tuple
           | STRING "." STRING                   -> set_tuple
           | SET_ELEMENT_ID STRING               -> set_element_with_desc
           | STRING STRING                       -> set_element_with_desc
           | NUMBER STRING                       -> set_element_with_desc
           | NUMBER                              -> set_element
           | SET_ELEMENT_ID                      -> set_element
           | STRING                              -> set_element

// Range expression: supports both numeric (1*10) and symbolic (s1*s10) ranges
// Sprint 16 Day 7: Added SET_ELEMENT_ID and STRING for hyphenated ranges (e.g., route-1*route-5)
// STRING supports quoted identifiers from preprocessor (e.g., 'route-1'*'route-5')
range_expr: range_bound TIMES range_bound
range_bound: NUMBER | SET_ELEMENT_ID | STRING | ID



// ---------------------------
// Table rows (for Table blocks)
// ---------------------------

// table_value will match NUMBER or ID tokens
// Since WS_INLINE is ignored globally, tokens are automatically separated
// table_row_label supports:
//   - nested dot notation: "low.a.subst"
//   - tuple notation: "(low,medium,high).ynot" expands to multiple rows
table_row: table_row_label table_value*
table_row_label: dotted_label                    -> simple_label
               | "(" id_list ")" "." dotted_label  -> tuple_label

// Issue #665: Allow STRING tokens for quoted row labels (e.g., '20-bond-wt')
dotted_label: (ID | STRING) ("." (ID | STRING | range_expr))*
// table_value: NUMBER handles signed numbers like -5, 3.14
// ID handles special values like inf, eps, na
// negative_special handles -inf, -eps, etc. (MINUS only, not PLUS since + means continuation)
// negative_number handles space-separated negatives like "- 0.0013" (Issue #704)
table_value: NUMBER | ID | range_expr | negative_special | negative_number
negative_special: MINUS ID
negative_number: MINUS NUMBER

// ---------------------------
// Assignments & Bounds
// ---------------------------

// Sprint 17 Day 7: Added square bracket conditional variants
// Sprint 19: Use condition rule for all dollar conditional forms (Issue #705)
assignment_stmt: lvalue ASSIGN expr SEMI                    -> assign
               | lvalue condition ASSIGN expr SEMI          -> conditional_assign_general

// Assignment without semicolon - for use as final statement in loop/if blocks
// Sprint 17 Day 7: Added square bracket conditional variants
// Sprint 19: Use condition rule for all dollar conditional forms (Issue #705)
assignment_nosemi: lvalue ASSIGN expr                         -> assign
                 | lvalue condition ASSIGN expr               -> conditional_assign_general

// lvalue supports: x.lo(i), x.up(i), x.fx(i), parameter(i), scalar
lvalue: ref_bound | ref_indexed | ID

ref_bound: ID "." BOUND_K "(" index_list ")"   -> bound_indexed
         | ID "." BOUND_K "[" index_list "]"   -> bound_indexed
         | ID "." BOUND_K                      -> bound_scalar
         | ID "." ID "(" index_list ")"        -> attr_access_indexed
         | ID "." ID "[" index_list "]"        -> attr_access_indexed
         | ID "." ID                           -> attr_access

// Note: 'stage' is NOT included as a bound keyword so that x.stage(...) parses as
// attr_access/attr_access_indexed, avoiding it being interpreted as a variable bound
// in the ModelIR builder. The IR builder ignores these assignments (Issue #554).
BOUND_K: /(lo|up|fx|l|m)/i

ref_indexed.2: ID "(" index_list ")"             -> symbol_indexed
             | ID "[" index_list "]"             -> symbol_indexed

// ---------------------------
// Indexing with lead/lag offsets (Sprint 9 Day 3)
// ---------------------------

// index_list supports both plain identifiers, lag/lead indexing, and subset indexing
// Examples: x(i, j++1, k--2), dist.l(low(n,nn))
index_list: index_expr ("," index_expr)*

// Sprint 11 Day 2 Extended: Support subset indexing like low(n,nn)
// Also support lag/lead inside subset like nh(i+1)
// Sprint 12 Day 5: Support square brackets [] in addition to parentheses ()
// Issue #566: Support STRING for quoted indices like drand('route-1',s)
index_expr: ID "(" index_list ")" lag_lead_suffix?  -> index_subset
          | ID "[" index_list "]" lag_lead_suffix?  -> index_subset
          | ID lag_lead_suffix?                   -> index_simple
          | STRING                                -> index_string

lag_lead_suffix: CIRCULAR_LEAD offset_expr   -> circular_lead
               | CIRCULAR_LAG offset_expr    -> circular_lag
               | PLUS offset_expr            -> linear_lead
               | MINUS offset_expr           -> linear_lag

offset_expr: NUMBER                          -> offset_number
           | ID                              -> offset_variable

CIRCULAR_LEAD: "++"
CIRCULAR_LAG: "--"

// ---------------------------
// Equations
// ---------------------------

equation_def: ID "(" domain_list ")" condition? ".." expr REL_K expr SEMI    -> eqn_def_domain
            | ID condition? ".." expr REL_K expr SEMI                     -> eqn_def_scalar

// Domain list for equation definitions - supports nested/subset indexing
domain_list: domain_element ("," domain_element)*

// Domain element can be simple (i) or subset with indices (low(n,nn))
// Sprint 12 Day 5: Support square brackets [] in addition to parentheses ()
domain_element: ID ("(" index_list ")" | "[" index_list "]")?
              | ID lag_lead_suffix

// Sprint 17 Day 7: Support square bracket conditionals (e.g., $[cond] in addition to $(cond))
// Sprint 19: Added bare dollar conditionals (e.g., $tm(t), $ls.l(i), $flag) for equation definitions (Issue #703)
condition: DOLLAR "(" expr ")"
         | DOLLAR "[" expr "]"
         | DOLLAR cond_bound
         | DOLLAR ref_indexed
         | DOLLAR ID

// Bare dollar conditional bound access — restricted to BOUND_K attributes (.lo, .up, .fx, .l, .m)
// that _expr() supports. Excludes attr_access/attr_access_indexed (e.g., .scale, .stage).
cond_bound: ID "." BOUND_K "(" index_list ")"   -> bound_indexed
          | ID "." BOUND_K "[" index_list "]"   -> bound_indexed
          | ID "." BOUND_K                      -> bound_scalar

REL_K: /=e=|=l=|=g=/i

// ---------------------------
// Solve
// ---------------------------

solve_stmt: "Solve"i ID obj_sense ID "using"i solver_type SEMI     -> solve
          | "Solve"i ID "using"i solver_type obj_sense ID SEMI     -> solve
obj_sense: MINIMIZING_K | MAXIMIZING_K
solver_type: /(?i:nlp|dnlp|minlp|mip|lp|mcp|cns|qcp|rmip|rminlp)\b/  // Sprint 11 Day 2: Support more solvers
// GAMS accepts any word starting with "min" or "max" as the solve direction
// (e.g., min, minimize, minimizing, minimzing, minfoo all work)
// Issue #706: Matches GAMS's tolerant keyword matching behavior
MINIMIZING_K: /(?i:min)\w*\b/
MAXIMIZING_K: /(?i:max)\w*\b/

model_stmt: ("Models"i | "Model"i) ID STRING? "/" "all"i "/" SEMI       -> model_all
          | ("Models"i | "Model"i) ID STRING? "/" model_ref_list "/" SEMI  -> model_with_list
          | ("Models"i | "Model"i) ID STRING? SEMI                         -> model_decl
          | ("Models"i | "Model"i) model_decl_item+ SEMI        -> model_multi

model_decl_item: ID STRING? "/" model_ref_list "/"
               | ID STRING? "/" "all"i "/"

model_ref_list: ID (","? ID)*

// ---------------------------
// Option Statement (Sprint 8)
// ---------------------------

option_stmt: OPTION_K option_list SEMI

option_list: option_item (","? option_item)*

option_item: ID "=" option_value  -> option_with_value
           | ID ":" NUMBER (":" NUMBER)*  -> option_format
           | ID                   -> option_flag

option_value: NUMBER
            | ID
            | ON
            | OFF

// ---------------------------
// Conditional Statements (Sprint 8 Day 2)
// ---------------------------

if_stmt: IF_K "(" expr "," exec_stmt+ elseif_clause* else_clause? ")" SEMI

elseif_clause: ELSEIF_K expr "," exec_stmt+

else_clause: ELSE_K exec_stmt+

// Loop statement (Sprint 11 Day 2 Extended, Sprint 12 conditional filter and indexed sets)
// Syntax: loop((indices), statements);
// Example: loop((n,d), p = p + 1; point.l(n,d) = p/10;);
// Conditional filter syntax: loop(i$(cond), ...) or loop((i,j)$(cond), ...)
// Indexed set syntax: loop(setname(i,j), ...) - iterate over mapped/sparse set
// Note: GAMS allows the final statement to omit the semicolon
// Sprint 17 Day 7: Added square bracket conditional variants for loop filters
loop_stmt: LOOP_K "(" id_list "," loop_body ")" SEMI
         | LOOP_K "(" "(" id_list ")" "," loop_body ")" SEMI  -> loop_stmt_paren
         | LOOP_K "(" ID DOLLAR "(" expr ")" "," loop_body ")" SEMI  -> loop_stmt_filtered
         | LOOP_K "(" ID DOLLAR "[" expr "]" "," loop_body ")" SEMI  -> loop_stmt_filtered
         | LOOP_K "(" "(" id_list ")" DOLLAR "(" expr ")" "," loop_body ")" SEMI  -> loop_stmt_paren_filtered
         | LOOP_K "(" "(" id_list ")" DOLLAR "[" expr "]" "," loop_body ")" SEMI  -> loop_stmt_paren_filtered
         | LOOP_K "(" ID "(" id_list ")" "," loop_body ")" SEMI  -> loop_stmt_indexed
         | LOOP_K "(" ID "(" id_list ")" DOLLAR "(" expr ")" "," loop_body ")" SEMI  -> loop_stmt_indexed_filtered
         | LOOP_K "(" ID "(" id_list ")" DOLLAR "[" expr "]" "," loop_body ")" SEMI  -> loop_stmt_indexed_filtered

// Loop body: zero or more statements with semicolons, followed by a final statement (semicolon optional)
loop_body: exec_stmt* exec_stmt_final

// Executable statements that can appear inside if blocks or loop blocks
// Note: These statements don't include trailing SEMI - the if_stmt/loop_stmt grammar handles it
?exec_stmt: display_stmt_nosemi
          | abort_stmt_nosemi
          | option_stmt          // Sprint 11 Day 2: Support option inside if/loop
          | solve_stmt           // Support solve inside if/loop
          | put_stmt             // Sprint 12: Support put inside if/loop
          | putclose_stmt        // Sprint 12: Support putclose inside if/loop
          | execute_stmt         // Sprint 12: Support execute inside if/loop
          | loop_stmt            // Sprint 19: Support nested loops
          | if_stmt              // Sprint 19: Support nested if statements
          | assignment_stmt
          | SEMI

// Final statement in loop - semicolon is optional
// Must include all statement types from exec_stmt for completeness
?exec_stmt_final: assignment_nosemi
                | assignment_stmt
                | display_stmt_nosemi
                | abort_stmt_nosemi
                | option_stmt
                | solve_stmt
                | put_stmt
                | put_stmt_nosemi
                | putclose_stmt
                | execute_stmt
                | loop_stmt      // Sprint 19: Support nested loops
                | if_stmt        // Sprint 19: Support nested if statements
                | SEMI

// ---------------------------
// File Statement (Sprint 12 - mock/skip for file I/O)
// ---------------------------

// File statement declares a file handle for output operations
// Syntax: file <name> / '<path>' /;  or  file <name> / path.ext /;
// We parse but don't process since file I/O is not relevant for NLP model extraction
file_stmt: "file"i ID "/" file_path "/" SEMI

// Sprint 16 Day 6: Added FILE_PATH_UNQUOTED for unquoted paths like MODEL.STG (Issue #556)
file_path: STRING
         | compile_time_const
         | FILE_PATH_UNQUOTED

// Pattern for unquoted file paths: allows letters, numbers, dots, underscores, hyphens
// Examples: MODEL.STG, output.txt, results_2024.dat
FILE_PATH_UNQUOTED: /[a-zA-Z0-9_][a-zA-Z0-9_.\-]*/

// ---------------------------
// Put Statement (Sprint 12 - Issue #447 - mock/skip for file I/O)
// ---------------------------

// Put statement writes output to files
// Syntax variations:
//   put f;                    - select file handle
//   put 'text' /;             - write string with newline
//   put x.l;                  - write expression
//   put 'x = ' x.l /;         - write multiple items with newline (space-separated)
//   put "text", v1("out", omega1), " more" /;  - comma-separated items with indexed expressions
// We parse but don't process since file I/O is not relevant for NLP model extraction
// Issue #557: Use optional comma separation to handle indexed expressions like v1("out", omega1)
// GAMS allows both space-separated and comma-separated put items
put_stmt: "put"i put_items? SEMI
        | "put"i put_items "/" SEMI

// Sprint 19 Day 2: No-semicolon variant for put as final statement in loop/if body
put_stmt_nosemi: "put"i put_items?
               | "put"i put_items "/"

put_items: put_item (","? put_item)*

put_item: STRING put_format?
        | "/" -> put_newline
        | expr put_format?

// Sprint 19 Day 2: Format specifiers for put items — :width or :width:decimals
// Optional alignment prefix: <, >, <>
// Examples: put x:8:2; put "text":20; put @10 y:12:4;
put_format: ":" PUT_ALIGN? NUMBER (":" NUMBER)?
PUT_ALIGN: "<>" | "<" | ">"

// Putclose statement closes a file after writing
putclose_stmt: "putclose"i ID? SEMI

// ---------------------------
// Execute Statement (Sprint 12 - Issue #456 - mock/skip for external execution)
// ---------------------------

// Execute statement runs external programs/commands
// Syntax variations:
//   execute 'command';                    - basic execute
//   execute.async 'command';              - with modifier (async, checkErrorLevel, etc.)
// We parse but don't process since external execution is not relevant for NLP model extraction
execute_stmt: "execute"i ("." ID)? STRING SEMI?

// ---------------------------
// Acronym Statement (Sprint 17 Day 8)
// ---------------------------

// Acronym statement declares symbolic constants (not used in NLP extraction but parsed for compatibility)
// Syntax: Acronym id1, id2, id3;
acronym_stmt: "Acronym"i id_list SEMI

// ---------------------------
// Display and Abort Statements (Sprint 8 Day 2 - mock/skip)
// ---------------------------

// Abort statement base rule (no SEMI)
// Sprint 16 Day 6: Extended to support display list after message (e.g., abort$(cond) 'msg', var1, var2)
abort_base: "abort"i DOLLAR "[" expr "]" STRING ("," display_item)*  -> abort_cond_square_msg
          | "abort"i DOLLAR "[" expr "]" expr (","? display_item)*    -> abort_cond_square_display
          | "abort"i DOLLAR "[" expr "]"                              -> abort_cond_square
          | "abort"i DOLLAR "(" expr ")" STRING ("," display_item)*   -> abort_cond_paren_msg
          | "abort"i DOLLAR "(" expr ")" expr (","? display_item)*    -> abort_cond_paren_display
          | "abort"i DOLLAR "(" expr ")"                              -> abort_cond_paren
          | "abort"i DOLLAR expr STRING ("," display_item)*           -> abort_cond_plain_msg
          | "abort"i DOLLAR abort_cond_atom expr (","? display_item)* -> abort_cond_plain_display
          | "abort"i DOLLAR expr                                      -> abort_cond_plain
          | "abort"i STRING ("," display_item)*                       -> abort_msg
          | "abort"i                                                  -> abort_plain

// Issue #715: Restricted condition atom for bare $cond abort (no parens/brackets).
// Without delimiters, the condition must be a single atom so the parser knows
// where the condition ends and display items begin.
abort_cond_atom: func_call
              | ref_indexed
              | ID

// Top-level statements (with SEMI)
// Sprint 17 Day 6: Made comma optional to support whitespace/newline separation
// GAMS allows: display a, b, c; OR display a b c; OR display a b\n c d;
display_stmt: "display"i display_item (","? display_item)* SEMI

display_item: expr
            | STRING

abort_stmt: abort_base SEMI

// Variants for use in if-statements (without SEMI)
// Sprint 17 Day 6: Made comma optional to support whitespace/newline separation
display_stmt_nosemi: "display"i display_item (","? display_item)*

abort_stmt_nosemi: abort_base

// ---------------------------
// Expressions
// ---------------------------

?expr: or_expr

SUM_K: "sum"i
// Sprint 17 Day 6: Added prod as aggregation function (like sum)
PROD_K: "prod"i

?or_expr: and_expr
        | or_expr OR and_expr          -> binop
?and_expr: comp_expr
         | and_expr AND comp_expr      -> binop

?comp_expr: arith_expr
          | arith_expr comp_op arith_expr -> binop

comp_op: ASSIGN | LE | GE | LT | GT | NE

?arith_expr: dollar_expr
           | arith_expr PLUS dollar_expr        -> binop
           | arith_expr MINUS dollar_expr       -> binop

// Sprint 17 Day 7: Support square bracket conditionals in expressions (e.g., x$[cond])
?dollar_expr: term
            | term DOLLAR term   -> dollar_cond
            | term DOLLAR "(" arith_expr ")"  -> dollar_cond_paren
            | term DOLLAR "[" arith_expr "]"  -> dollar_cond_paren

?term: factor
     | term TIMES factor                 -> binop
     | term DIV factor                   -> binop

?factor: power
       | PLUS factor                     -> unaryop
       | MINUS factor                    -> unaryop
       | NOT_K factor                    -> unaryop

?power: atom
      | atom POW factor                  -> binop

symbol_plain: ID

// Sprint 17 Day 8: Added curly brace expression support for GAMS compatibility
?atom: NUMBER                             -> number
     | func_call                          -> funccall
     | sum_expr
     | prod_expr
     | compile_time_const                 -> compile_const
     | ref_bound
     | ref_indexed
     | symbol_plain
     | "(" expr ")"
     | "[" expr "]"                       -> bracket_expr
     | "{" expr "}"                       -> brace_expr

// Compile-time constants: %identifier% or %path.to.value%
compile_time_const: "%" compile_const_path "%"
compile_const_path: ID ("." ID)*

sum_expr: SUM_K "(" sum_domain "," expr ")"   -> sum
        | SUM_K "{" sum_domain "," expr "}"   -> sum

// Sprint 17 Day 6: Added prod aggregation function (like sum but for products)
prod_expr: PROD_K "(" sum_domain "," expr ")"   -> prod
         | PROD_K "{" sum_domain "," expr "}"   -> prod

sum_domain: index_spec
          | "(" index_spec ")"  -> tuple_domain
          | "(" index_spec ")" DOLLAR expr           -> tuple_domain_cond
          | "(" index_spec ")" DOLLAR "[" expr "]"   -> tuple_domain_cond

// Sprint 17 Day 7: Support square bracket conditionals in sum/prod index specs
index_spec: index_list (DOLLAR expr)?
          | index_list DOLLAR "[" expr "]"

func_call.3: FUNCNAME "(" arg_list? ")"
arg_list: expr ("," expr)*

// ---------------------------
// Tokens & basics
// ---------------------------

FUNCNAME: /(?i:abs|exp|log10|log2|log|sqrt|sin|cos|tan|min|max|smin|smax|power|signpower|sqr|ord|card|uniform|normal|gamma|loggamma|psi|round|mod|ceil|floor|sameas)\b/
IF_K: /(?i:if)\b/
ELSEIF_K: /(?i:elseif)\b/
ELSE_K: /(?i:else)\b/
LOOP_K: /(?i:loop)\b/
OPTION_K: /(?i:options?)\b/
ON: /(?i:on)\b/
OFF: /(?i:off)\b/
// Sprint 16 Day 6: Extended to allow number-start elements like "1964-i", "89-07"
// Pattern allows: letter/underscore start, or digit start followed by '-'/'_' separator
// This prevents stealing NUMBER tokens (e.g., "1", "10", "1e-3") while allowing "1964-i", "89-07"
// The digit-start branch requires explicit '-' or '_' separator to avoid matching scientific notation
// Priority 2 ensures it matches before plain ID but after keywords
SET_ELEMENT_ID.2: /(?:[a-zA-Z_][a-zA-Z0-9_+\-]*|[0-9][0-9_]*[\-_][a-zA-Z0-9_+\-]*)/
ID: ESCAPED | /[a-zA-Z_][a-zA-Z0-9_]*/
// Issue #424: SYMBOL_NAME matches only unquoted identifiers for use as set/param/var names
// This prevents quoted strings like 'products' from being parsed as symbol names
SYMBOL_NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
ESCAPED: /'[^']*'|\"[^\"]*\"/
STRING: /"[^"]*"|'[^']*'/
// Sprint 12 Day 5 (Issue #417): DESC_TEXT matches 2+ words on same line (no newlines)
// Pattern: word (separator word)+ where words are separated by spaces/tabs
// Words can contain letters, numbers, underscores, and hyphens within words (e.g., co-efficient)
// Separators can be spaces/tabs or space-hyphen-space (e.g., "word - word")
// Priority -1: Lower than default (0) to avoid interfering with normal ID matching
// Note: {1,} means 1 or more additional (separator word) sequences after the first = 2+ words total
DESC_TEXT.-1: /[a-zA-Z_]\w*(?:-\w+)*(?:(?:[ \t]+|[ \t]+-[ \t]+)[a-zA-Z_]\w*(?:-\w+)*){1,}/
// Issue #433: PARAM_DESC matches 1+ words for parameter descriptions (allows single-word like "partition")
// This is safe in parameter context because params are always followed by domain or nothing
// Priority -2: Lower than DESC_TEXT to prefer 2+ word matches when available
PARAM_DESC.-2: /[a-zA-Z_]\w*(?:-\w+)*(?:(?:[ \t]+|[ \t]+-[ \t]+)[a-zA-Z_]\w*(?:-\w+)*)*/
DESCRIPTION.10: /(?=.*(?:[a-zA-Z_][a-zA-Z0-9_]{3,}|\w+\-\w+))[a-zA-Z_][\w\-]*(?:[ \t]+[a-zA-Z_][\w\-]*)+/

NUMBER: SIGNED_NUMBER

LE: "<="
GE: ">="
NE: "<>"
LT: "<"
GT: ">"
ASSIGN: "="
SEMI: ";"
COMMA: ","
DOT: "."
PLUS: /\+/
MINUS: /-/
TIMES: /\*/
DIV: /\//
POW: "**" | "^"
DOLLAR.10: "$"  // Higher priority to prevent being consumed by ignore patterns
AND: /(?i:and)\b/
OR: /(?i:or)\b/
NOT_K: /(?i:not)\b/

%import common.SIGNED_NUMBER
%import common.CNAME
%import common.WS_INLINE
%import common.NEWLINE

// Note: WS_INLINE and NEWLINE are selectively ignored
// They can be explicitly referenced in rules where needed
%ignore WS_INLINE
%ignore /(?m)^\s*\*.*$/      // GAMS inline comments: * comment
%ignore /\/\/.*?$/m      // // comment
%ignore /(?si)\$ontext.*?\$offtext/ // block comments (case insensitive)
// Ignore $ directives but not $ operator in expressions
// Pattern matches $directive (not followed by ( or space) to avoid matching expr$(condition)
// Common directives: $title, $include, $set, $eval, $if, $ifthen, $else, $endif,
// $load, $gdxin, $gdxout, $call, $setglobal, $setlocal, $show, $log, $onecho, $offecho, etc.
%ignore /\$(?![\(\s])[a-z]+[^\n]*/i
%ignore NEWLINE
