// Minimal, practical GAMS NLP subset grammar for nlp2mcp
// Notes:
// - Case-insensitive keywords handled via inline (?i: ...) blocks.
// - Identifiers allow quoted GAMS names: 'x.i', "cost%", etc.
// - Indexing like x(i,j) and sum(i, expr) supported.
// - Equations with =e=, =l=, =g=; bounds via x.lo(i) = ...; x.up(i) = ...;
// - One Solve statement: "Solve <name> using NLP [minimizing|maximizing] <objvar>;"
//
// Youâ€™ll still implement semantic checks in Python (dimensions, undefined symbols, etc).

start: stmt*  -> program

?stmt: sets_block
     | aliases_block
     | params_block
     | table_block
     | scalars_block
     | variables_block
     | equations_block
     | model_stmt
     | option_stmt
     | if_stmt
     | display_stmt
     | abort_stmt
     | assignment_stmt
     | equation_def
     | solve_stmt
     | SEMI

// ---------------------------
// Blocks
// ---------------------------

sets_block: ("Sets"i | "Set"i) set_decl+ SEMI

aliases_block: ("Aliases"i | "Alias"i) alias_decl+ SEMI

params_block: ("Parameters"i | "Parameter"i) param_decl+ SEMI

table_block: "Table"i ID "(" id_list ")" STRING? table_row+ SEMI

scalars_block: ("Scalars"i | "Scalar"i) scalar_decl+ SEMI

variables_block: var_kind? ("Variables"i | "Variable"i) var_decl+ SEMI

equations_block: ("Equations"i | "Equation"i) eqn_head_decl+ SEMI

// ---------------------------
// Declarations
// ---------------------------

set_decl: ID STRING? "/" set_members "/"                     -> set_simple
        | ID STRING? alias_opt "/" set_members "/"           -> set_aliased
        | ID "(" id_list ")"                                 -> set_domain
        | ID                                                 -> set_empty

alias_decl: ID "," ID  "/" ID "/"                            -> alias_with_universe
          | "(" ID "," ID ")"                                -> alias_parens
          | ID "," ID                                        -> alias_plain

param_decl: ID "(" id_list ")" "/" param_data_items "/" param_default? -> param_domain_data
          | ID "(" id_list ")" param_default?                          -> param_domain
          | ID "/" param_data_items "/" param_default?                 -> param_plain_data
          | ID param_default?                                          -> param_plain
          | ID "," id_list                                             -> param_list
scalar_decl: scalar_single_item                                          -> scalar_single
           | scalar_item (","? scalar_item)+                                 -> scalar_list

// For comma-separated or newline-separated lists: NO desc_text (ambiguous)
scalar_item: ID "/" scalar_data_items "/" (ASSIGN expr)?                -> scalar_with_data
           | ID ASSIGN expr                                             -> scalar_with_assign
           | ID                                                         -> scalar_plain

// For single scalar declarations: allow desc_text (unambiguous)
scalar_single_item: ID desc_text "/" scalar_data_items "/" (ASSIGN expr)?  -> scalar_with_data
                  | ID desc_text ASSIGN expr                               -> scalar_with_assign
                  | ID desc_text                                           -> scalar_plain

// Optional inline description text
// Matches zero or more words/operators, implicitly stops at structural tokens (/, =, ;, etc.)
// The grammar rules ensure it stops before these delimiters
// NOTE: desc_text always produces a node in the parse tree (even if empty with zero words)
// Parser code must handle this by checking if the node has children or skipping it entirely
desc_text: _desc_word*

// NOTE: Currently limited to ID tokens and hyphens (sufficient for hs62.gms)
// Other characters like +, *, /, parentheses will cause description to stop prematurely
// Future: May need to expand pattern to support richer description syntax
_desc_word: ID | MINUS

scalar_data_items: scalar_data_item ("," scalar_data_item)*
scalar_data_item: NUMBER

param_default: ASSIGN expr
param_data_items: param_data_item ("," param_data_item)*
param_data_item: data_indices NUMBER                       -> param_data_scalar
                 | data_matrix_row                         -> param_data_matrix_row

data_indices: ID ("." ID)*
data_matrix_row: data_indices data_matrix_values
data_matrix_values: NUMBER (NUMBER)*

var_decl: var_kind? ID "(" id_list ")"                       -> var_indexed
        | var_kind? id_list                                  -> var_list
        | var_kind? ID                                       -> var_scalar

var_kind: POSITIVE_K | NEGATIVE_K | BINARY_K | INTEGER_K

POSITIVE_K: /(?i:positive)\b/
NEGATIVE_K: /(?i:negative)\b/
BINARY_K  : /(?i:binary)\b/
INTEGER_K : /(?i:integer)\b/

// NOTE: eqn_head_domain_list allows comma-separated equation names with domains,
// e.g., "Equations eq1, eq2(i,j);". This is NOT valid GAMS syntax according to
// the official specification, but we handle it gracefully to support user error recovery.
// Updated for Sprint 11 Day 1: Support nested/subset indexing like defdist(low(n,nn))
eqn_head_decl: id_list "(" domain_list ")"                   -> eqn_head_domain_list
             | ID "(" domain_list ")"                        -> eqn_head_domain
             | id_list                                       -> eqn_head_list
             | ID                                            -> eqn_head_scalar

alias_opt : "(" id_list ")"                                  -> alias_domain
id_list: ID ("," ID)*

set_members: set_member ("," set_member)*
?set_member: range_expr    -> set_range
           | ID            -> set_element
           | STRING        -> set_element

// Range expression: supports both numeric (1*10) and symbolic (s1*s10) ranges
range_expr: range_bound TIMES range_bound
range_bound: NUMBER | ID



// ---------------------------
// Table rows (for Table blocks)
// ---------------------------

// table_value will match NUMBER or ID tokens
// Since WS_INLINE is ignored globally, tokens are automatically separated
table_row: ID table_value*
table_value: NUMBER | ID

// ---------------------------
// Assignments & Bounds
// ---------------------------

assignment_stmt: lvalue ASSIGN expr SEMI                    -> assign

// lvalue supports: x.lo(i), x.up(i), x.fx(i), parameter(i), scalar
lvalue: ref_bound | ref_indexed | ID

ref_bound: ID "." BOUND_K "(" index_list ")"   -> bound_indexed
         | ID "." BOUND_K                      -> bound_scalar
         | ID "." ID                            -> attr_access

BOUND_K: /(lo|up|fx|l|m)/i

ref_indexed.2: ID "(" index_list ")"             -> symbol_indexed

// ---------------------------
// Indexing with lead/lag offsets (Sprint 9 Day 3)
// ---------------------------

// index_list supports both plain identifiers and lag/lead indexing
// Example: x(i, j++1, k--2)
index_list: index_expr ("," index_expr)*

index_expr: ID lag_lead_suffix?

lag_lead_suffix: CIRCULAR_LEAD offset_expr   -> circular_lead
               | CIRCULAR_LAG offset_expr    -> circular_lag
               | PLUS offset_expr            -> linear_lead
               | MINUS offset_expr           -> linear_lag

offset_expr: NUMBER                          -> offset_number
           | ID                              -> offset_variable

CIRCULAR_LEAD: "++"
CIRCULAR_LAG: "--"

// ---------------------------
// Equations
// ---------------------------

equation_def: ID "(" domain_list ")" condition? ".." expr REL_K expr SEMI    -> eqn_def_domain
            | ID condition? ".." expr REL_K expr SEMI                     -> eqn_def_scalar

// Domain list for equation definitions - supports nested/subset indexing
domain_list: domain_element ("," domain_element)*

// Domain element can be simple (i) or subset with indices (low(n,nn))
domain_element: ID ("(" id_list ")")?

condition: "$" "(" expr ")"

REL_K: /=e=|=l=|=g=/i

// ---------------------------
// Solve
// ---------------------------

solve_stmt: "Solve"i ID obj_sense ID "using"i "NLP"i SEMI     -> solve
          | "Solve"i ID "using"i "NLP"i obj_sense ID SEMI     -> solve
obj_sense: MINIMIZING_K | MAXIMIZING_K
MINIMIZING_K: /(?i:minimizing|min)\b/
MAXIMIZING_K: /(?i:maximizing|max)\b/

model_stmt: ("Models"i | "Model"i) ID "/" "all"i "/" SEMI       -> model_all
          | ("Models"i | "Model"i) ID "/" model_ref_list "/" SEMI  -> model_with_list
          | ("Models"i | "Model"i) ID SEMI                         -> model_decl
          | ("Models"i | "Model"i) model_decl_item+ SEMI        -> model_multi

model_decl_item: ID "/" model_ref_list "/"
               | ID "/" "all"i "/"

model_ref_list: ID ("," ID)*

// ---------------------------
// Option Statement (Sprint 8)
// ---------------------------

option_stmt: ("option"i | "options"i) option_list SEMI

option_list: option_item ("," option_item)*

option_item: ID "=" option_value  -> option_with_value
           | ID                   -> option_flag

option_value: NUMBER
            | ON
            | OFF

// ---------------------------
// Conditional Statements (Sprint 8 Day 2)
// ---------------------------

if_stmt: IF_K "(" expr "," exec_stmt+ elseif_clause* else_clause? ")" SEMI

elseif_clause: ELSEIF_K expr "," exec_stmt+

else_clause: ELSE_K exec_stmt+

// Executable statements that can appear inside if blocks
// Note: These statements don't include trailing SEMI - the if_stmt grammar handles it
?exec_stmt: display_stmt_nosemi
          | abort_stmt_nosemi
          | assignment_stmt
          | SEMI

// ---------------------------
// Display and Abort Statements (Sprint 8 Day 2 - mock/skip)
// ---------------------------

// Abort statement base rule (no SEMI)
abort_base: "abort"i "$" "[" expr "]" STRING     -> abort_cond_square_msg
          | "abort"i "$" "[" expr "]"             -> abort_cond_square
          | "abort"i "$" "(" expr ")" STRING      -> abort_cond_paren_msg
          | "abort"i "$" "(" expr ")"             -> abort_cond_paren
          | "abort"i "$" expr STRING              -> abort_cond_plain_msg
          | "abort"i "$" expr                     -> abort_cond_plain
          | "abort"i STRING                       -> abort_msg
          | "abort"i                              -> abort_plain

// Top-level statements (with SEMI)
display_stmt: "display"i display_item ("," display_item)* SEMI

display_item: expr
            | STRING

abort_stmt: abort_base SEMI

// Variants for use in if-statements (without SEMI)
display_stmt_nosemi: "display"i display_item ("," display_item)*

abort_stmt_nosemi: abort_base

// ---------------------------
// Expressions
// ---------------------------

?expr: or_expr

SUM_K: "sum"i

?or_expr: and_expr
        | or_expr OR and_expr          -> binop
?and_expr: comp_expr
         | and_expr AND comp_expr      -> binop

?comp_expr: arith_expr
          | arith_expr comp_op arith_expr -> binop

comp_op: ASSIGN | LE | GE | LT | GT | NE

?arith_expr: term
           | arith_expr PLUS term        -> binop
           | arith_expr MINUS term       -> binop

?term: factor
     | term TIMES factor                 -> binop
     | term DIV factor                   -> binop

?factor: power
       | PLUS factor                     -> unaryop
       | MINUS factor                    -> unaryop

?power: atom
      | atom POW factor                  -> binop

symbol_plain: ID

?atom: NUMBER                             -> number
     | func_call                          -> funccall
     | sum_expr
     | compile_time_const                 -> compile_const
     | ref_bound
     | ref_indexed
     | symbol_plain
     | "(" expr ")"

// Compile-time constants: %identifier% or %path.to.value%
compile_time_const: "%" compile_const_path "%"
compile_const_path: ID ("." ID)*

sum_expr: SUM_K "(" id_list "," expr ")"  -> sum

func_call.3: FUNCNAME "(" arg_list? ")"
arg_list: expr ("," expr)*

// ---------------------------
// Tokens & basics
// ---------------------------

FUNCNAME: /(?i:abs|exp|log|sqrt|sin|cos|tan|min|max|smin|smax|power|sqr|ord|card|uniform|normal|gamma|loggamma|round|mod|ceil)\b/
IF_K: /(?i:if)\b/
ELSEIF_K: /(?i:elseif)\b/
ELSE_K: /(?i:else)\b/
ON: /(?i:on)\b/
OFF: /(?i:off)\b/
ID: ESCAPED | /[a-zA-Z_][a-zA-Z0-9_]*/
ESCAPED: /'[^']*'|\"[^\"]*\"/
STRING: /"[^"]*"|'[^']*'/

NUMBER: SIGNED_NUMBER

LE: "<="
GE: ">="
NE: "<>"
LT: "<"
GT: ">"
ASSIGN: "="
SEMI: ";"
COMMA: ","
DOT: "."
PLUS: /\+/
MINUS: /-/
TIMES: /\*/
DIV: /\//
POW: "**" | "^"
AND: /(?i:and)\b/
OR: /(?i:or)\b/

%import common.SIGNED_NUMBER
%import common.CNAME
%import common.WS_INLINE
%import common.NEWLINE

%ignore WS_INLINE
%ignore /(?m)^\s*\*.*$/      // GAMS inline comments: * comment
%ignore /\/\/.*?$/m      // // comment
%ignore /(?si)\$ontext.*?\$offtext/ // block comments (case insensitive)
%ignore /\$title[^\n]*/i     // $title directives
// NOTE: This pattern intentionally ignores all $ directives for simplicity
// Some directives like $include, $set, $eval may need special handling in future
// but are ignored for now to enable parsing of models like hs62.gms
%ignore /\$[a-z]+/i          // Other $ directives (broad pattern)
%ignore NEWLINE
