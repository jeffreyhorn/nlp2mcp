// Minimal, practical GAMS NLP subset grammar for nlp2mcp
// Notes:
// - Case-insensitive keywords handled via inline (?i: ...) blocks.
// - Identifiers allow quoted GAMS names: 'x.i', "cost%", etc.
// - Indexing like x(i,j) and sum(i, expr) supported.
// - Equations with =e=, =l=, =g=; bounds via x.lo(i) = ...; x.up(i) = ...;
// - One Solve statement: "Solve <name> using NLP [minimizing|maximizing] <objvar>;"
//
// Youâ€™ll still implement semantic checks in Python (dimensions, undefined symbols, etc).

start: stmt*  -> program

?stmt: sets_block
     | aliases_block
     | params_block
     | table_block
     | scalars_block
     | variables_block
     | equations_block
     | model_stmt
     | option_stmt
     | if_stmt
     | loop_stmt
     | display_stmt
     | abort_stmt
     | assignment_stmt
     | equation_def
     | solve_stmt
     | SEMI

// ---------------------------
// Blocks
// ---------------------------

sets_block: ("Sets"i | "Set"i) set_decl+ SEMI

aliases_block: ("Aliases"i | "Alias"i) alias_decl+ SEMI

params_block: ("Parameters"i | "Parameter"i) param_decl+ SEMI

table_block: "Table"i ID "(" table_domain_list ")" (STRING | DESCRIPTION)? table_row+ SEMI

table_domain_list: table_domain ("," table_domain)*
table_domain: ID                      -> explicit_domain
            | "*"                     -> wildcard_domain
            | "(" wildcard_tuple ")"  -> wildcard_tuple_domain

wildcard_tuple: "*" ("," "*")+

scalars_block: ("Scalars"i | "Scalar"i) scalar_decl+ SEMI

variables_block: var_kind? ("Variables"i | "Variable"i) var_decl+ SEMI

equations_block: ("Equations"i | "Equation"i) eqn_head_decl+ SEMI

// ---------------------------
// Declarations
// ---------------------------

set_decl: ID "(" id_list ")" STRING? "/" set_members "/"     -> set_domain_with_members
        | ID STRING? "/" set_members "/"                     -> set_simple
        | ID STRING? alias_opt "/" set_members "/"           -> set_aliased
        | ID ("," ID)+                                       -> set_list
        | ID "(" id_list ")"                                 -> set_domain
        | ID                                                 -> set_empty

alias_decl: ID "," ID  "/" ID "/"                            -> alias_with_universe
          | alias_pair ("," alias_pair)+                     -> alias_multi
          | ID "," ID                                        -> alias_plain
          | alias_pair                                       -> alias_single

alias_pair: "(" ID "," id_list ")"

param_decl: ID "(" id_list ")" STRING? "/" param_data_items "/" param_default? -> param_domain_data
          | ID "(" id_list ")" STRING? param_default?                          -> param_domain
          | ID STRING? "/" param_data_items "/" param_default?                 -> param_plain_data
          | ID STRING? param_default?                                          -> param_plain
          | ID "," id_list                                             -> param_list
scalar_decl: scalar_single_item                                          -> scalar_single
           | scalar_item (","? scalar_item)+                                 -> scalar_list

// For comma-separated or newline-separated lists: NO desc_text (ambiguous)
scalar_item: ID "/" scalar_data_items "/" (ASSIGN expr)?                -> scalar_with_data
           | ID ASSIGN expr                                             -> scalar_with_assign
           | ID                                                         -> scalar_plain

// For single scalar declarations: allow desc_text (unambiguous)
scalar_single_item: ID desc_text "/" scalar_data_items "/" (ASSIGN expr)?  -> scalar_with_data
                  | ID desc_text ASSIGN expr                               -> scalar_with_assign
                  | ID desc_text                                           -> scalar_plain

// Optional inline description text
// Matches zero or more words/operators, implicitly stops at structural tokens (/, =, ;, etc.)
// The grammar rules ensure it stops before these delimiters
// NOTE: desc_text always produces a node in the parse tree (even if empty with zero words)
// Parser code must handle this by checking if the node has children or skipping it entirely
desc_text: _desc_word*

// NOTE: Currently limited to ID tokens and hyphens (sufficient for hs62.gms)
// Other characters like +, *, /, parentheses will cause description to stop prematurely
// Future: May need to expand pattern to support richer description syntax
_desc_word: ID | MINUS

scalar_data_items: scalar_data_item ("," scalar_data_item)*
scalar_data_item: NUMBER

param_default: ASSIGN expr
param_data_items: param_data_item ("," param_data_item)*
param_data_item: data_matrix_row                         -> param_data_matrix_row
                 | data_indices NUMBER                   -> param_data_scalar

// data_indices can be numeric (e.g., parameter tau(nm) / 1 0.000, 2 0.025 /)
// Also allows hyphenated identifiers (e.g., parameter cost(i) / light-ind 100 /)
data_indices: (SET_ELEMENT_ID | NUMBER) ("." (SET_ELEMENT_ID | NUMBER))*
// Matrix row must have at least 2 values (data_indices followed by 2+ NUMBERs) to disambiguate from scalar
data_matrix_row: data_indices NUMBER NUMBER+
data_matrix_values: NUMBER (NUMBER)*

var_decl: var_kind? var_item ("," var_item)*                 -> var_list
        | var_kind? ID "(" id_list ")" STRING?               -> var_indexed
        | var_kind? ID STRING?                               -> var_scalar

var_item: var_kind? ID "(" id_list ")" STRING?               -> var_item_indexed
        | var_kind? ID STRING?                                -> var_item_scalar

var_kind: POSITIVE_K | NEGATIVE_K | BINARY_K | INTEGER_K

POSITIVE_K: /(?i:positive)\b/
NEGATIVE_K: /(?i:negative)\b/
BINARY_K  : /(?i:binary)\b/
INTEGER_K : /(?i:integer)\b/

// NOTE: eqn_head_domain_list allows comma-separated equation names with domains,
// e.g., "Equations eq1, eq2(i,j);". This is NOT valid GAMS syntax according to
// the official specification, but we handle it gracefully to support user error recovery.
// Updated for Sprint 11 Day 1: Support nested/subset indexing like defdist(low(n,nn))
eqn_head_decl: id_list "(" domain_list ")" (STRING | DESCRIPTION)?  -> eqn_head_domain_list
             | ID "(" domain_list ")" (STRING | DESCRIPTION)?       -> eqn_head_domain
             | id_list (STRING | DESCRIPTION)?                      -> eqn_head_list
             | ID (STRING | DESCRIPTION)?                           -> eqn_head_scalar

alias_opt : "(" id_list ")"                                  -> alias_domain
id_list: ID ("," ID)*

set_members: set_member ("," set_member)*
?set_member: range_expr                          -> set_range
           | SET_ELEMENT_ID "." "(" id_list ")"  -> set_tuple_expansion
           | SET_ELEMENT_ID "." SET_ELEMENT_ID STRING -> set_tuple_with_desc
           | SET_ELEMENT_ID "." SET_ELEMENT_ID   -> set_tuple
           | SET_ELEMENT_ID STRING               -> set_element_with_desc
           | NUMBER                              -> set_element
           | SET_ELEMENT_ID                      -> set_element
           | STRING                              -> set_element

// Range expression: supports both numeric (1*10) and symbolic (s1*s10) ranges
range_expr: range_bound TIMES range_bound
range_bound: NUMBER | ID



// ---------------------------
// Table rows (for Table blocks)
// ---------------------------

// table_value will match NUMBER or ID tokens
// Since WS_INLINE is ignored globally, tokens are automatically separated
// table_row_label supports:
//   - nested dot notation: "low.a.subst"
//   - tuple notation: "(low,medium,high).ynot" expands to multiple rows
table_row: table_row_label table_value*
table_row_label: dotted_label                    -> simple_label
               | "(" id_list ")" "." dotted_label  -> tuple_label

dotted_label: ID ("." ID)*
table_value: NUMBER | ID

// ---------------------------
// Assignments & Bounds
// ---------------------------

assignment_stmt: lvalue ASSIGN expr SEMI                    -> assign

// lvalue supports: x.lo(i), x.up(i), x.fx(i), parameter(i), scalar
lvalue: ref_bound | ref_indexed | ID

ref_bound: ID "." BOUND_K "(" index_list ")"   -> bound_indexed
         | ID "." BOUND_K                      -> bound_scalar
         | ID "." ID                            -> attr_access

BOUND_K: /(lo|up|fx|l|m)/i

ref_indexed.2: ID "(" index_list ")"             -> symbol_indexed

// ---------------------------
// Indexing with lead/lag offsets (Sprint 9 Day 3)
// ---------------------------

// index_list supports both plain identifiers, lag/lead indexing, and subset indexing
// Examples: x(i, j++1, k--2), dist.l(low(n,nn))
index_list: index_expr ("," index_expr)*

// Sprint 11 Day 2 Extended: Support subset indexing like low(n,nn)
// Also support lag/lead inside subset like nh(i+1)
index_expr: ID "(" index_list ")" lag_lead_suffix?  -> index_subset
          | ID lag_lead_suffix?                   -> index_simple

lag_lead_suffix: CIRCULAR_LEAD offset_expr   -> circular_lead
               | CIRCULAR_LAG offset_expr    -> circular_lag
               | PLUS offset_expr            -> linear_lead
               | MINUS offset_expr           -> linear_lag

offset_expr: NUMBER                          -> offset_number
           | ID                              -> offset_variable

CIRCULAR_LEAD: "++"
CIRCULAR_LAG: "--"

// ---------------------------
// Equations
// ---------------------------

equation_def: ID "(" domain_list ")" condition? ".." expr REL_K expr SEMI    -> eqn_def_domain
            | ID condition? ".." expr REL_K expr SEMI                     -> eqn_def_scalar

// Domain list for equation definitions - supports nested/subset indexing
domain_list: domain_element ("," domain_element)*

// Domain element can be simple (i) or subset with indices (low(n,nn))
domain_element: ID ("(" index_list ")")?
              | ID lag_lead_suffix

condition: DOLLAR "(" expr ")"

REL_K: /=e=|=l=|=g=/i

// ---------------------------
// Solve
// ---------------------------

solve_stmt: "Solve"i ID obj_sense ID "using"i solver_type SEMI     -> solve
          | "Solve"i ID "using"i solver_type obj_sense ID SEMI     -> solve
obj_sense: MINIMIZING_K | MAXIMIZING_K
solver_type: /(?i:nlp|dnlp|minlp|mip|lp|mcp|cns|qcp|rmip|rminlp)\b/  // Sprint 11 Day 2: Support more solvers
MINIMIZING_K: /(?i:minimizing|min)\b/
MAXIMIZING_K: /(?i:maximizing|max)\b/

model_stmt: ("Models"i | "Model"i) ID STRING? "/" "all"i "/" SEMI       -> model_all
          | ("Models"i | "Model"i) ID STRING? "/" model_ref_list "/" SEMI  -> model_with_list
          | ("Models"i | "Model"i) ID STRING? SEMI                         -> model_decl
          | ("Models"i | "Model"i) model_decl_item+ SEMI        -> model_multi

model_decl_item: ID STRING? "/" model_ref_list "/"
               | ID STRING? "/" "all"i "/"

model_ref_list: ID ("," ID)*

// ---------------------------
// Option Statement (Sprint 8)
// ---------------------------

option_stmt: ("option"i | "options"i) option_list SEMI

option_list: option_item ("," option_item)*

option_item: ID "=" option_value  -> option_with_value
           | ID                   -> option_flag

option_value: NUMBER
            | ON
            | OFF

// ---------------------------
// Conditional Statements (Sprint 8 Day 2)
// ---------------------------

if_stmt: IF_K "(" expr "," exec_stmt+ elseif_clause* else_clause? ")" SEMI

elseif_clause: ELSEIF_K expr "," exec_stmt+

else_clause: ELSE_K exec_stmt+

// Loop statement (Sprint 11 Day 2 Extended)
// Syntax: loop((indices), statements);
// Example: loop((n,d), p = p + 1; point.l(n,d) = p/10;);
loop_stmt: LOOP_K "(" id_list "," exec_stmt+ ")" SEMI
         | LOOP_K "(" "(" id_list ")" "," exec_stmt+ ")" SEMI  -> loop_stmt_paren

// Executable statements that can appear inside if blocks or loop blocks
// Note: These statements don't include trailing SEMI - the if_stmt/loop_stmt grammar handles it
?exec_stmt: display_stmt_nosemi
          | abort_stmt_nosemi
          | option_stmt          // Sprint 11 Day 2: Support option inside if/loop
          | assignment_stmt
          | SEMI

// ---------------------------
// Display and Abort Statements (Sprint 8 Day 2 - mock/skip)
// ---------------------------

// Abort statement base rule (no SEMI)
abort_base: "abort"i DOLLAR "[" expr "]" STRING     -> abort_cond_square_msg
          | "abort"i DOLLAR "[" expr "]"             -> abort_cond_square
          | "abort"i DOLLAR "(" expr ")" STRING      -> abort_cond_paren_msg
          | "abort"i DOLLAR "(" expr ")"             -> abort_cond_paren
          | "abort"i DOLLAR expr STRING              -> abort_cond_plain_msg
          | "abort"i DOLLAR expr                     -> abort_cond_plain
          | "abort"i STRING                       -> abort_msg
          | "abort"i                              -> abort_plain

// Top-level statements (with SEMI)
display_stmt: "display"i display_item ("," display_item)* SEMI

display_item: expr
            | STRING

abort_stmt: abort_base SEMI

// Variants for use in if-statements (without SEMI)
display_stmt_nosemi: "display"i display_item ("," display_item)*

abort_stmt_nosemi: abort_base

// ---------------------------
// Expressions
// ---------------------------

?expr: or_expr

SUM_K: "sum"i

?or_expr: and_expr
        | or_expr OR and_expr          -> binop
?and_expr: comp_expr
         | and_expr AND comp_expr      -> binop

?comp_expr: arith_expr
          | arith_expr comp_op arith_expr -> binop

comp_op: ASSIGN | LE | GE | LT | GT | NE

?arith_expr: dollar_expr
           | arith_expr PLUS dollar_expr        -> binop
           | arith_expr MINUS dollar_expr       -> binop

?dollar_expr: term
            | term DOLLAR term   -> dollar_cond
            | term DOLLAR "(" arith_expr ")"  -> dollar_cond_paren

?term: factor
     | term TIMES factor                 -> binop
     | term DIV factor                   -> binop

?factor: power
       | PLUS factor                     -> unaryop
       | MINUS factor                    -> unaryop

?power: atom
      | atom POW factor                  -> binop

symbol_plain: ID

?atom: NUMBER                             -> number
     | func_call                          -> funccall
     | sum_expr
     | compile_time_const                 -> compile_const
     | ref_bound
     | ref_indexed
     | symbol_plain
     | "(" expr ")"
     | "[" expr "]"                       -> bracket_expr

// Compile-time constants: %identifier% or %path.to.value%
compile_time_const: "%" compile_const_path "%"
compile_const_path: ID ("." ID)*

sum_expr: SUM_K "(" index_list "," expr ")"   -> sum
        | SUM_K "{" index_list "," expr "}"   -> sum

func_call.3: FUNCNAME "(" arg_list? ")"
arg_list: expr ("," expr)*

// ---------------------------
// Tokens & basics
// ---------------------------

FUNCNAME: /(?i:abs|exp|log10|log2|log|sqrt|sin|cos|tan|min|max|smin|smax|power|sqr|ord|card|uniform|normal|gamma|loggamma|round|mod|ceil)\b/
IF_K: /(?i:if)\b/
ELSEIF_K: /(?i:elseif)\b/
ELSE_K: /(?i:else)\b/
LOOP_K: /(?i:loop)\b/
ON: /(?i:on)\b/
OFF: /(?i:off)\b/
SET_ELEMENT_ID.2: /[a-zA-Z_][a-zA-Z0-9_+\-]*/
ID: ESCAPED | /[a-zA-Z_][a-zA-Z0-9_]*/
ESCAPED: /'[^']*'|\"[^\"]*\"/
STRING: /"[^"]*"|'[^']*'/
DESCRIPTION.10: /(?=.*(?:[a-zA-Z_][a-zA-Z0-9_]{3,}|\w+\-\w+))[a-zA-Z_][\w\-]*(?:[ \t]+[a-zA-Z_][\w\-]*)+/

NUMBER: SIGNED_NUMBER

LE: "<="
GE: ">="
NE: "<>"
LT: "<"
GT: ">"
ASSIGN: "="
SEMI: ";"
COMMA: ","
DOT: "."
PLUS: /\+/
MINUS: /-/
TIMES: /\*/
DIV: /\//
POW: "**" | "^"
DOLLAR.10: "$"  // Higher priority to prevent being consumed by ignore patterns
AND: /(?i:and)\b/
OR: /(?i:or)\b/

%import common.SIGNED_NUMBER
%import common.CNAME
%import common.WS_INLINE
%import common.NEWLINE

%ignore WS_INLINE
%ignore /(?m)^\s*\*.*$/      // GAMS inline comments: * comment
%ignore /\/\/.*?$/m      // // comment
%ignore /(?si)\$ontext.*?\$offtext/ // block comments (case insensitive)
// Ignore $ directives but not $ operator in expressions
// Pattern matches $directive (not followed by ( or space) to avoid matching expr$(condition)
// Common directives: $title, $include, $set, $eval, $if, $ifthen, $else, $endif,
// $load, $gdxin, $gdxout, $call, $setglobal, $setlocal, $show, $log, $onecho, $offecho, etc.
%ignore /\$(?![\(\s])[a-z]+[^\n]*/i
%ignore NEWLINE
