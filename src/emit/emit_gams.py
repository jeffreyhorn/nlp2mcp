"""Main GAMS MCP code generator.

This module orchestrates all emission components to generate a complete
GAMS MCP file from a KKT system.
"""

import math

from src.config import Config
from src.emit.equations import _build_domain_condition, _collect_lead_lag_restrictions
from src.emit.expr_to_gams import expr_to_gams
from src.emit.model import emit_model_mcp, emit_solve
from src.emit.original_symbols import (
    _compute_set_alias_phases,
    emit_computed_parameter_assignments,
    emit_original_aliases,
    emit_original_parameters,
    emit_original_sets,
    emit_set_assignments,
    has_stochastic_parameters,
)
from src.emit.templates import emit_equation_definitions, emit_equations, emit_variables
from src.ir.ast import Expr, IndexOffset, SubsetIndex, VarRef
from src.ir.symbols import VarKind
from src.kkt.kkt_system import KKTSystem
from src.kkt.naming import create_eq_multiplier_name
from src.kkt.objective import extract_objective_info


def _index_to_gams_string(idx: str | IndexOffset | SubsetIndex) -> str:
    """Convert an index object to GAMS string representation.

    Args:
        idx: Index object (str, IndexOffset, or SubsetIndex)

    Returns:
        GAMS string representation of the index

    Examples:
        'i' -> 'i'
        IndexOffset('t', Const(1), circular=False) -> 't+1'
        SubsetIndex('subset', ('i', 'j')) -> 'subset(i,j)'
    """
    if isinstance(idx, str):
        return idx
    elif isinstance(idx, IndexOffset):
        return idx.to_gams_string()
    elif isinstance(idx, SubsetIndex):
        # SubsetIndex: subset_name(indices)
        indices_str = ",".join(idx.indices)
        return f"{idx.subset_name}({indices_str})"
    else:
        # Fallback: convert to string
        return str(idx)


def _collect_varref_names(expr: Expr) -> set[str]:
    """Collect variable names referenced as .l in an expression tree."""
    names: set[str] = set()
    if isinstance(expr, VarRef) and expr.attribute == "l":
        names.add(expr.name.lower())
    for child in expr.children():
        names.update(_collect_varref_names(child))
    return names


def emit_gams_mcp(
    kkt: KKTSystem,
    model_name: str = "mcp_model",
    add_comments: bool = True,
    config: Config | None = None,
) -> str:
    """Generate complete GAMS MCP code from KKT system.

    This function orchestrates all emission components to produce a complete,
    runnable GAMS file containing:
    1. Original model declarations (Sets, Aliases, Parameters)
    2. KKT-specific sets for multiplier indexing
    3. Variable declarations (primal + multipliers, grouped by kind)
    4. Equation declarations
    5. Equation definitions
    6. Model MCP declaration with complementarity pairs
    7. Solve statement

    Args:
        kkt: The KKT system to emit
        model_name: Name for the GAMS model (default: "mcp_model")
        add_comments: Whether to add explanatory comments (default: True)

    Returns:
        Complete GAMS MCP code as a string

    Example:
        ```python
        # After parsing and KKT assembly
        gams_code = emit_gams_mcp(kkt)
        Path("output.gms").write_text(gams_code)
        ```
    """
    sections = []

    # Header comment
    if add_comments:
        sections.append("$onText")
        sections.append("Generated by nlp2mcp")
        sections.append("")
        sections.append("This file contains the KKT (Karush-Kuhn-Tucker) conditions")
        sections.append("for the original NLP model, transformed into MCP format.")
        sections.append("")
        sections.append("KKT System Components:")
        sections.append("  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0")
        sections.append("  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π")
        sections.append("  - Dual feasibility: λ, π^L, π^U ≥ 0")
        sections.append("  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up")
        sections.append("$offText")
        sections.append("")

    # Original model symbols
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Original Model Declarations")
        sections.append("* ============================================")
        sections.append("")

    # Sprint 17 Day 10 (Issue #621): Split sets and aliases into phases
    # Correct emit order ensures all dependencies are declared before use.
    # For each phase p: emit phase p sets, then phase p aliases.
    # Supports N phases dynamically based on dependency depth.
    # Compute phases once and pass to both emitters to avoid redundant work.
    phases = _compute_set_alias_phases(kkt.model_ir)
    sets_by_phase = emit_original_sets(kkt.model_ir, precomputed_phases=phases)
    aliases_by_phase = emit_original_aliases(kkt.model_ir, precomputed_phases=phases)

    # Ensure both lists have the same length by padding with empty strings
    if sets_by_phase or aliases_by_phase:
        max_phases = max(len(sets_by_phase), len(aliases_by_phase))
    else:
        max_phases = 0
    while len(sets_by_phase) < max_phases:
        sets_by_phase.append("")
    while len(aliases_by_phase) < max_phases:
        aliases_by_phase.append("")

    # Emit each phase: sets first, then aliases
    for phase_idx in range(max_phases):
        if sets_by_phase[phase_idx]:
            sections.append(sets_by_phase[phase_idx])
            sections.append("")
        if aliases_by_phase[phase_idx]:
            sections.append(aliases_by_phase[phase_idx])
            sections.append("")

    params_code = emit_original_parameters(kkt.model_ir)
    if params_code:
        sections.append(params_code)
        sections.append("")

    # PR #658: Emit dynamic set assignments BEFORE computed parameters
    # Dynamic subsets (e.g., ku(k)) must be populated before parameter assignments
    # like w(n,np,ku) that reference them, otherwise they produce empty data.
    set_assignments_code = emit_set_assignments(kkt.model_ir)
    if set_assignments_code:
        sections.append(set_assignments_code)
        sections.append("")

    # Sprint 17 Day 4: Emit computed parameter assignments
    # Split into two passes: regular assignments go here (before Variables),
    # while .l-referencing calibration assignments are deferred until after
    # Variables are declared (GAMS requires variable declaration before .l access).
    computed_params_code = emit_computed_parameter_assignments(
        kkt.model_ir, varref_filter="no_varref_attr"
    )
    if computed_params_code:
        # Sprint 19 Day 3: If any computed parameter contains stochastic
        # functions (uniform, normal), fix the random seed so the MCP
        # produces deterministic results across solver invocations.
        if has_stochastic_parameters(kkt.model_ir):
            if add_comments:
                sections.append("* Fix random seed for deterministic MCP evaluation")
            sections.append("execseed = 12345;")
            sections.append("")
        sections.append(computed_params_code)
        sections.append("")

    # Variables (primal + multipliers)
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Variables (Primal + Multipliers)")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Primal variables: Original decision variables from the NLP")
        sections.append("* Multipliers:")
        sections.append("*   ν (nu_*): Free multipliers for equality constraints")
        sections.append("*   λ (lam_*): Positive multipliers for inequality constraints")
        sections.append("*   π^L (piL_*): Positive multipliers for lower bounds")
        sections.append("*   π^U (piU_*): Positive multipliers for upper bounds")
        sections.append("")

    variables_code = emit_variables(kkt)
    sections.append(variables_code)
    sections.append("")

    # Sprint 18 Day 3 (P5 fix): Variable initialization to avoid division by zero
    # Variables with level values, lower bounds, or positive type need initialization
    # to prevent division by zero during model generation when they appear in
    # denominators of stationarity equations (e.g., from differentiating log(x) or 1/x)
    # Issue #763: Collect init lines per variable, then topologically sort them
    # so that .l expressions referencing other variables' .l come after their deps.
    var_init_groups: dict[str, list[str]] = {}  # var_name -> init lines
    var_init_order: list[str] = []  # preserve original order for stable sort
    var_l_deps: dict[str, set[str]] = {}  # var_name -> set of var names it depends on
    has_positive_clamp = False  # Track if any POSITIVE variable clamping is done
    has_positive_init = False  # Track if any POSITIVE variable is initialized to 1
    for var_name, var_def in kkt.model_ir.variables.items():
        # Issue #742: Skip unreferenced variables (not declared, so no init needed)
        if (
            kkt.referenced_variables is not None
            and var_name.lower() not in kkt.referenced_variables
        ):
            continue
        has_init = False
        lines: list[str] = []

        # Priority 1: Check for explicit level values (l_map) - these take precedence
        if var_def.l_map:
            for indices, l_val in var_def.l_map.items():
                if l_val is not None:
                    idx_str = ",".join(f'"{i}"' for i in indices)
                    lines.append(f"{var_name}.l({idx_str}) = {l_val};")
                    has_init = True
        elif var_def.l is not None:
            lines.append(f"{var_name}.l = {var_def.l};")
            has_init = True

        # Priority 1b: Expression-based .l assignments (Sprint 20 Day 2)
        # These are non-constant .l initializations like a.l = (xmin+xmax)/2
        if not has_init and hasattr(var_def, "l_expr_map") and var_def.l_expr_map:
            deps: set[str] = set()
            for indices, expr in var_def.l_expr_map.items():  # type: ignore[assignment]
                idx_str = ",".join(_index_to_gams_string(i) for i in indices)
                expr_str = expr_to_gams(expr)
                lines.append(f"{var_name}.l({idx_str}) = {expr_str};")
                deps.update(_collect_varref_names(expr))
                has_init = True
            deps.discard(var_name.lower())  # remove self-references
            if deps:
                var_l_deps[var_name] = deps
        elif not has_init and hasattr(var_def, "l_expr") and var_def.l_expr is not None:
            expr_str = expr_to_gams(var_def.l_expr)
            lines.append(f"{var_name}.l = {expr_str};")
            deps = _collect_varref_names(var_def.l_expr)
            deps.discard(var_name.lower())
            if deps:
                var_l_deps[var_name] = deps
            has_init = True

        # Priority 2: Check for indexed lower bounds (lo_map) if no .l was provided
        if not has_init and var_def.lo_map:
            for indices, lo_val in var_def.lo_map.items():
                if lo_val is not None and lo_val > 0:
                    idx_str = ",".join(f'"{i}"' for i in indices)
                    lines.append(f"{var_name}.l({idx_str}) = {lo_val};")
                    has_init = True
        # Check for scalar lower bound
        elif not has_init and var_def.lo is not None and var_def.lo > 0:
            lines.append(f"{var_name}.l = {var_def.lo};")
            has_init = True

        # Priority 3: Positive variables: ensure all elements have non-zero values
        if var_def.kind == VarKind.POSITIVE:
            if has_init:
                has_positive_clamp = True
                if var_def.domain:
                    domain_str = ",".join(var_def.domain)
                    lines.append(
                        f"{var_name}.l({domain_str}) = min(max({var_name}.l({domain_str}), 1e-6), {var_name}.up({domain_str}));"
                    )
                else:
                    lines.append(f"{var_name}.l = min(max({var_name}.l, 1e-6), {var_name}.up);")
            else:
                has_positive_init = True
                if var_def.domain:
                    domain_str = ",".join(var_def.domain)
                    lines.append(f"{var_name}.l({domain_str}) = 1;")
                else:
                    lines.append(f"{var_name}.l = 1;")

        if lines:
            var_init_groups[var_name] = lines
            var_init_order.append(var_name)

    # Issue #763: Topological sort of variable init groups so deps come first.
    if var_l_deps:
        name_to_lower = {v: v.lower() for v in var_init_order}
        lower_to_name = {v.lower(): v for v in var_init_order}
        in_deg: dict[str, int] = dict.fromkeys(var_init_order, 0)
        for vname, deps in var_l_deps.items():
            for dep_lower in deps:
                if dep_lower in lower_to_name:
                    in_deg[vname] += 1
        queue = [v for v in var_init_order if in_deg[v] == 0]
        sorted_vars: list[str] = []
        while queue:
            node = queue.pop(0)
            sorted_vars.append(node)
            node_lower = name_to_lower[node]
            for vname in var_init_order:
                if vname in sorted_vars:
                    continue
                if node_lower in var_l_deps.get(vname, set()):
                    in_deg[vname] -= 1
                    if in_deg[vname] == 0:
                        queue.append(vname)
        # Add any remaining (cycles) in original order
        for v in var_init_order:
            if v not in sorted_vars:
                sorted_vars.append(v)
        var_init_order = sorted_vars

    init_lines: list[str] = []
    for vname in var_init_order:
        init_lines.extend(var_init_groups[vname])

    if init_lines:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Variable Initialization")
            sections.append("* ============================================")
            sections.append("")
            sections.append(
                "* Initialize variables to avoid division by zero during model generation."
            )
            sections.append(
                "* Variables appearing in denominators (from log, 1/x derivatives) need"
            )
            sections.append("* non-zero initial values.")
            if has_positive_clamp and has_positive_init:
                sections.append("* POSITIVE variables with explicit .l values are")
                sections.append(
                    "* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1."
                )
            elif has_positive_clamp:
                sections.append("* POSITIVE variables with explicit .l values are")
                sections.append("* clamped to min(max(value, 1e-6), upper_bound).")
            elif has_positive_init:
                sections.append("* POSITIVE variables are set to 1.")
            sections.append("")
        # Issue #763: Wrap .l initialization in $onImplicitAssign to suppress
        # GAMS Error 141 when .l expressions reference other variables' .l values
        # that haven't been assigned yet (e.g., v.l(i) = pk.l * k.l(i) + ...).
        has_cross_varref = any(".l" in line and "=" in line for line in init_lines)
        if has_cross_varref:
            sections.append("$onImplicitAssign")
        sections.extend(init_lines)
        if has_cross_varref:
            sections.append("$offImplicitAssign")
        sections.append("")

    # Additional initialization for smooth_abs (if enabled)
    # Note: This is now largely redundant with Priority 3 initialization above,
    # which already handles POSITIVE variables. Kept for explicit smooth_abs comment.
    if config and config.smooth_abs:
        if add_comments:
            sections.append("* Additional initialization for smooth abs() approximation")
            sections.append("* (POSITIVE variables already initialized above)")
            sections.append("")

    # Deferred .l-referencing calibration assignments (second pass).
    # These must come after Variables are declared so GAMS recognizes var.l syntax.
    # $onImplicitAssign suppresses GAMS Error 141 when reading .l from variables
    # that have been declared and initialized but not explicitly data-assigned.
    calibration_code = emit_computed_parameter_assignments(
        kkt.model_ir, varref_filter="only_varref_attr"
    )
    if calibration_code:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Post-solve Calibration (variable .l references)")
            sections.append("* ============================================")
            sections.append("")
        sections.append("$onImplicitAssign")
        sections.append(calibration_code)
        sections.append("$offImplicitAssign")
        sections.append("")

    # Equations
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Equations")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Stationarity: One equation per primal variable (except objvar)")
        sections.append("* Complementarity: Equations for inequalities and bounds")
        sections.append("* Equality constraints: Original equality constraints")
        sections.append("")

    equations_code = emit_equations(kkt)
    sections.append(equations_code)
    sections.append("")

    # Equation definitions
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Equation Definitions")
        sections.append("* ============================================")
        sections.append("")

    eq_defs_code, index_aliases = emit_equation_definitions(kkt)

    # Emit index aliases if any are needed (to avoid GAMS Error 125)
    # These must be declared before the equation definitions that use them
    if index_aliases:
        if add_comments:
            sections.append("* Index aliases to avoid 'Set is under control already' error")
            sections.append("* (GAMS Error 125 when equation domain index is reused in sum)")
        for idx in sorted(index_aliases):
            alias_name = f"{idx}__"
            sections.append(f"Alias({idx}, {alias_name});")
        sections.append("")

    sections.append(eq_defs_code)
    sections.append("")

    # Issue #724: Fix variables whose paired MCP equation has a dollar condition.
    # When an MCP equation is conditioned (e.g., stat_x(w,t)$(td(w,t)) or
    # comp_minw(t)$(tm(t))), the paired variable must be fixed for excluded
    # instances so GAMS MCP doesn't report unmatched pairs.
    fx_lines: list[str] = []

    # 1. Fix primal variables with conditioned stationarity equations
    for var_name, cond_expr in sorted(kkt.stationarity_conditions.items()):
        var_def = kkt.model_ir.variables.get(var_name)
        if var_def and var_def.domain:
            domain_str = ",".join(var_def.domain)
            domain_vars = frozenset(var_def.domain)
            cond_gams = expr_to_gams(cond_expr, domain_vars=domain_vars)
            # Choose a finite fixing value: prefer fx, then lo (if finite),
            # then up (if finite), else 0.  Infinite bounds (-inf/+inf or None)
            # cannot be emitted as GAMS .fx values.
            if var_def.fx is not None and math.isfinite(var_def.fx):
                fix_val = var_def.fx
            elif var_def.lo is not None and math.isfinite(var_def.lo):
                fix_val = var_def.lo
            elif var_def.up is not None and math.isfinite(var_def.up):
                fix_val = var_def.up
            else:
                fix_val = 0
            fx_lines.append(f"{var_name}.fx({domain_str})$(not ({cond_gams})) = {fix_val};")

    # 2. Fix multipliers whose complementarity equation has a condition
    ref_mults = kkt.referenced_multipliers
    for _eq_name, comp_pair in sorted(kkt.complementarity_ineq.items()):
        if ref_mults is not None and comp_pair.variable not in ref_mults:
            continue
        eq_def = comp_pair.equation
        if eq_def.condition is not None and eq_def.domain:
            mult_name = comp_pair.variable
            domain_str = ",".join(eq_def.domain)
            domain_vars = frozenset(eq_def.domain)
            assert isinstance(eq_def.condition, Expr)
            cond_gams = expr_to_gams(eq_def.condition, domain_vars=domain_vars)
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({cond_gams})) = 0;")

    # 3. Fix equality multipliers (nu_*) whose equation has lead/lag restrictions.
    # Issue #760: stateq(n,k+1) generates rows only for k in ku (ord(k)<=card(k)-1),
    # but nu_stateq(n,k) is declared over the full (n,k) domain.  Fix the terminal
    # instances to 0 so GAMS MCP matching sees no unmatched free variable.
    for eq_name in sorted(kkt.model_ir.equalities):
        if eq_name not in kkt.model_ir.equations:
            continue
        eq_def = kkt.model_ir.equations[eq_name]
        if not eq_def.domain:
            continue
        lhs, rhs = eq_def.lhs_rhs
        lead_l, lag_l = _collect_lead_lag_restrictions(lhs, eq_def.domain)
        lead_r, lag_r = _collect_lead_lag_restrictions(rhs, eq_def.domain)
        lead_offsets = {
            k: max(lead_l.get(k, 0), lead_r.get(k, 0)) for k in set(lead_l) | set(lead_r)
        }
        lag_offsets = {k: max(lag_l.get(k, 0), lag_r.get(k, 0)) for k in set(lag_l) | set(lag_r)}
        # Also incorporate any explicit condition already on the equation
        inferred_cond = _build_domain_condition(lead_offsets, lag_offsets)
        if inferred_cond is None and eq_def.condition is None:
            continue
        mult_name = create_eq_multiplier_name(eq_name)
        if ref_mults is not None and mult_name not in ref_mults:
            continue
        domain_str = ",".join(eq_def.domain)
        if inferred_cond is not None:
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({inferred_cond})) = 0;")
        elif eq_def.condition is not None and isinstance(eq_def.condition, Expr):
            domain_vars = frozenset(eq_def.domain)
            cond_gams = expr_to_gams(eq_def.condition, domain_vars=domain_vars)
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({cond_gams})) = 0;")

    if fx_lines:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Fix inactive variable instances")
            sections.append("* ============================================")
            sections.append("")
            sections.append("* Variables whose paired MCP equation is conditioned must be")
            sections.append("* fixed for excluded instances to satisfy MCP matching.")
            sections.append("")
        sections.extend(fx_lines)
        sections.append("")

    # Model MCP
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Model MCP Declaration")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Each line pairs an equation with a variable:")
        sections.append("*   equation.variable")
        sections.append("*")
        sections.append("* This defines the complementarity problem:")
        sections.append("*   equation ⊥ variable")
        sections.append("*")
        sections.append("* Meaning: equation = 0 if variable > 0")
        sections.append("*          equation ≥ 0 if variable = 0")
        sections.append("")

    model_code = emit_model_mcp(kkt, model_name)
    sections.append(model_code)
    sections.append("")

    # Solve statement
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Solve Statement")
        sections.append("* ============================================")
        sections.append("")

    solve_code = emit_solve(model_name)
    sections.append(solve_code)

    # Emit NLP objective value capture for pipeline comparison.
    # MCP listings have no "OBJECTIVE VALUE" line, so we assign the NLP objective
    # variable to a fixed-name sentinel scalar after the solve. The pipeline's
    # extract_objective_from_variables() matches "---- PARAMETER nlp2mcp_obj_val".
    # The nlp2mcp_ prefix reduces collision risk with user-defined symbols.
    obj_info = extract_objective_info(kkt.model_ir)
    if obj_info.objvar:
        sections.append("")
        sections.append("Scalar nlp2mcp_obj_val;")
        sections.append(f"nlp2mcp_obj_val = {obj_info.objvar}.l;")
        sections.append("Display nlp2mcp_obj_val;")

    return "\n".join(sections)
