"""Main GAMS MCP code generator.

This module orchestrates all emission components to generate a complete
GAMS MCP file from a KKT system.
"""

import math

from src.config import Config
from src.emit.equations import _build_domain_condition, _collect_lead_lag_restrictions
from src.emit.expr_to_gams import expr_to_gams
from src.emit.model import emit_model_mcp, emit_solve
from src.emit.original_symbols import (
    _compute_set_alias_phases,
    emit_computed_parameter_assignments,
    emit_original_aliases,
    emit_original_parameters,
    emit_original_sets,
    emit_set_assignments,
    has_stochastic_parameters,
)
from src.emit.templates import emit_equation_definitions, emit_equations, emit_variables
from src.ir.ast import Expr, IndexOffset, SubsetIndex
from src.ir.symbols import VarKind
from src.kkt.kkt_system import KKTSystem
from src.kkt.naming import create_eq_multiplier_name
from src.kkt.objective import extract_objective_info


def _index_to_gams_string(idx: str | IndexOffset | SubsetIndex) -> str:
    """Convert an index object to GAMS string representation.

    Args:
        idx: Index object (str, IndexOffset, or SubsetIndex)

    Returns:
        GAMS string representation of the index

    Examples:
        'i' -> 'i'
        IndexOffset('t', Const(1), circular=False) -> 't+1'
        SubsetIndex('subset', ('i', 'j')) -> 'subset(i,j)'
    """
    if isinstance(idx, str):
        return idx
    elif isinstance(idx, IndexOffset):
        return idx.to_gams_string()
    elif isinstance(idx, SubsetIndex):
        # SubsetIndex: subset_name(indices)
        indices_str = ",".join(idx.indices)
        return f"{idx.subset_name}({indices_str})"
    else:
        # Fallback: convert to string
        return str(idx)


def emit_gams_mcp(
    kkt: KKTSystem,
    model_name: str = "mcp_model",
    add_comments: bool = True,
    config: Config | None = None,
) -> str:
    """Generate complete GAMS MCP code from KKT system.

    This function orchestrates all emission components to produce a complete,
    runnable GAMS file containing:
    1. Original model declarations (Sets, Aliases, Parameters)
    2. KKT-specific sets for multiplier indexing
    3. Variable declarations (primal + multipliers, grouped by kind)
    4. Equation declarations
    5. Equation definitions
    6. Model MCP declaration with complementarity pairs
    7. Solve statement

    Args:
        kkt: The KKT system to emit
        model_name: Name for the GAMS model (default: "mcp_model")
        add_comments: Whether to add explanatory comments (default: True)

    Returns:
        Complete GAMS MCP code as a string

    Example:
        ```python
        # After parsing and KKT assembly
        gams_code = emit_gams_mcp(kkt)
        Path("output.gms").write_text(gams_code)
        ```
    """
    sections = []

    # Header comment
    if add_comments:
        sections.append("$onText")
        sections.append("Generated by nlp2mcp")
        sections.append("")
        sections.append("This file contains the KKT (Karush-Kuhn-Tucker) conditions")
        sections.append("for the original NLP model, transformed into MCP format.")
        sections.append("")
        sections.append("KKT System Components:")
        sections.append("  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0")
        sections.append("  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π")
        sections.append("  - Dual feasibility: λ, π^L, π^U ≥ 0")
        sections.append("  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up")
        sections.append("$offText")
        sections.append("")

    # Original model symbols
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Original Model Declarations")
        sections.append("* ============================================")
        sections.append("")

    # Sprint 17 Day 10 (Issue #621): Split sets and aliases into phases
    # Correct emit order ensures all dependencies are declared before use.
    # For each phase p: emit phase p sets, then phase p aliases.
    # Supports N phases dynamically based on dependency depth.
    # Compute phases once and pass to both emitters to avoid redundant work.
    phases = _compute_set_alias_phases(kkt.model_ir)
    sets_by_phase = emit_original_sets(kkt.model_ir, precomputed_phases=phases)
    aliases_by_phase = emit_original_aliases(kkt.model_ir, precomputed_phases=phases)

    # Ensure both lists have the same length by padding with empty strings
    if sets_by_phase or aliases_by_phase:
        max_phases = max(len(sets_by_phase), len(aliases_by_phase))
    else:
        max_phases = 0
    while len(sets_by_phase) < max_phases:
        sets_by_phase.append("")
    while len(aliases_by_phase) < max_phases:
        aliases_by_phase.append("")

    # Emit each phase: sets first, then aliases
    for phase_idx in range(max_phases):
        if sets_by_phase[phase_idx]:
            sections.append(sets_by_phase[phase_idx])
            sections.append("")
        if aliases_by_phase[phase_idx]:
            sections.append(aliases_by_phase[phase_idx])
            sections.append("")

    params_code = emit_original_parameters(kkt.model_ir)
    if params_code:
        sections.append(params_code)
        sections.append("")

    # PR #658: Emit dynamic set assignments BEFORE computed parameters
    # Dynamic subsets (e.g., ku(k)) must be populated before parameter assignments
    # like w(n,np,ku) that reference them, otherwise they produce empty data.
    set_assignments_code = emit_set_assignments(kkt.model_ir)
    if set_assignments_code:
        sections.append(set_assignments_code)
        sections.append("")

    # Sprint 17 Day 4: Emit computed parameter assignments
    # Split into two passes: regular assignments go here (before Variables),
    # while .l-referencing calibration assignments are deferred until after
    # Variables are declared (GAMS requires variable declaration before .l access).
    computed_params_code = emit_computed_parameter_assignments(
        kkt.model_ir, varref_filter="no_varref_attr"
    )
    if computed_params_code:
        # Sprint 19 Day 3: If any computed parameter contains stochastic
        # functions (uniform, normal), fix the random seed so the MCP
        # produces deterministic results across solver invocations.
        if has_stochastic_parameters(kkt.model_ir):
            if add_comments:
                sections.append("* Fix random seed for deterministic MCP evaluation")
            sections.append("execseed = 12345;")
            sections.append("")
        sections.append(computed_params_code)
        sections.append("")

    # Variables (primal + multipliers)
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Variables (Primal + Multipliers)")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Primal variables: Original decision variables from the NLP")
        sections.append("* Multipliers:")
        sections.append("*   ν (nu_*): Free multipliers for equality constraints")
        sections.append("*   λ (lam_*): Positive multipliers for inequality constraints")
        sections.append("*   π^L (piL_*): Positive multipliers for lower bounds")
        sections.append("*   π^U (piU_*): Positive multipliers for upper bounds")
        sections.append("")

    variables_code = emit_variables(kkt)
    sections.append(variables_code)
    sections.append("")

    # Sprint 18 Day 3 (P5 fix): Variable initialization to avoid division by zero
    # Variables with level values, lower bounds, or positive type need initialization
    # to prevent division by zero during model generation when they appear in
    # denominators of stationarity equations (e.g., from differentiating log(x) or 1/x)
    init_lines: list[str] = []
    has_positive_clamp = False  # Track if any POSITIVE variable clamping is done
    has_positive_init = False  # Track if any POSITIVE variable is initialized to 1
    for var_name, var_def in kkt.model_ir.variables.items():
        # Issue #742: Skip unreferenced variables (not declared, so no init needed)
        if (
            kkt.referenced_variables is not None
            and var_name.lower() not in kkt.referenced_variables
        ):
            continue
        has_init = False

        # Priority 1: Check for explicit level values (l_map) - these take precedence
        if var_def.l_map:
            for indices, l_val in var_def.l_map.items():
                if l_val is not None:
                    idx_str = ",".join(f'"{i}"' for i in indices)
                    init_lines.append(f"{var_name}.l({idx_str}) = {l_val};")
                    has_init = True
        elif var_def.l is not None:
            init_lines.append(f"{var_name}.l = {var_def.l};")
            has_init = True

        # Priority 1b: Expression-based .l assignments (Sprint 20 Day 2)
        # These are non-constant .l initializations like a.l = (xmin+xmax)/2
        if not has_init and hasattr(var_def, "l_expr_map") and var_def.l_expr_map:
            for indices, expr in var_def.l_expr_map.items():  # type: ignore[assignment]
                idx_str = ",".join(_index_to_gams_string(i) for i in indices)
                expr_str = expr_to_gams(expr)
                init_lines.append(f"{var_name}.l({idx_str}) = {expr_str};")
                has_init = True
        elif not has_init and hasattr(var_def, "l_expr") and var_def.l_expr is not None:
            expr_str = expr_to_gams(var_def.l_expr)
            init_lines.append(f"{var_name}.l = {expr_str};")
            has_init = True

        # Priority 2: Check for indexed lower bounds (lo_map) if no .l was provided
        if not has_init and var_def.lo_map:
            for indices, lo_val in var_def.lo_map.items():
                if lo_val is not None and lo_val > 0:
                    idx_str = ",".join(f'"{i}"' for i in indices)
                    init_lines.append(f"{var_name}.l({idx_str}) = {lo_val};")
                    has_init = True
        # Check for scalar lower bound
        elif not has_init and var_def.lo is not None and var_def.lo > 0:
            init_lines.append(f"{var_name}.l = {var_def.lo};")
            has_init = True

        # Priority 3: Positive variables: ensure all elements have non-zero values
        # PR #658 review: Even with partial per-index inits, other elements may be 0.
        # Always apply a blanket max() to ensure no POSITIVE variable element is 0.
        # PR #664 review: Use small epsilon (1e-6) to preserve explicit small values
        # like 0.0001 while preventing division by zero. Previous value of 1.0 was
        # overriding explicit initializations.
        # PR #658 review: Clamp to upper bound using GAMS .up attribute to respect
        # per-element bounds (up_map), not just scalar var_def.up.
        # Issue #651: Don't read from .l when initializing - GAMS Error 141 occurs
        # if the variable was never assigned any .l values. For variables without
        # explicit .l values, we set .l = 1 directly (not reading .up either to
        # avoid Error 141 if bounds weren't assigned).
        if var_def.kind == VarKind.POSITIVE:
            if has_init:
                has_positive_clamp = True
                # Variable already has explicit .l values - preserve them with max()
                # Use 1e-6 epsilon to allow small explicit values like 0.0001
                if var_def.domain:
                    domain_str = ",".join(var_def.domain)
                    init_lines.append(
                        f"{var_name}.l({domain_str}) = min(max({var_name}.l({domain_str}), 1e-6), {var_name}.up({domain_str}));"
                    )
                else:
                    init_lines.append(
                        f"{var_name}.l = min(max({var_name}.l, 1e-6), {var_name}.up);"
                    )
            else:
                # No explicit .l values - just set to 1 directly
                # Don't read .up either as it may not be assigned (Error 141)
                has_positive_init = True
                if var_def.domain:
                    domain_str = ",".join(var_def.domain)
                    init_lines.append(f"{var_name}.l({domain_str}) = 1;")
                else:
                    init_lines.append(f"{var_name}.l = 1;")

    if init_lines:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Variable Initialization")
            sections.append("* ============================================")
            sections.append("")
            sections.append(
                "* Initialize variables to avoid division by zero during model generation."
            )
            sections.append(
                "* Variables appearing in denominators (from log, 1/x derivatives) need"
            )
            sections.append("* non-zero initial values.")
            if has_positive_clamp and has_positive_init:
                sections.append("* POSITIVE variables with explicit .l values are")
                sections.append(
                    "* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1."
                )
            elif has_positive_clamp:
                sections.append("* POSITIVE variables with explicit .l values are")
                sections.append("* clamped to min(max(value, 1e-6), upper_bound).")
            elif has_positive_init:
                sections.append("* POSITIVE variables are set to 1.")
            sections.append("")
        sections.extend(init_lines)
        sections.append("")

    # Additional initialization for smooth_abs (if enabled)
    # Note: This is now largely redundant with Priority 3 initialization above,
    # which already handles POSITIVE variables. Kept for explicit smooth_abs comment.
    if config and config.smooth_abs:
        if add_comments:
            sections.append("* Additional initialization for smooth abs() approximation")
            sections.append("* (POSITIVE variables already initialized above)")
            sections.append("")

    # Deferred .l-referencing calibration assignments (second pass).
    # These must come after Variables are declared so GAMS recognizes var.l syntax.
    # $onImplicitAssign suppresses GAMS Error 141 when reading .l from variables
    # that have been declared and initialized but not explicitly data-assigned.
    calibration_code = emit_computed_parameter_assignments(
        kkt.model_ir, varref_filter="only_varref_attr"
    )
    if calibration_code:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Post-solve Calibration (variable .l references)")
            sections.append("* ============================================")
            sections.append("")
        sections.append("$onImplicitAssign")
        sections.append(calibration_code)
        sections.append("$offImplicitAssign")
        sections.append("")

    # Equations
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Equations")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Stationarity: One equation per primal variable (except objvar)")
        sections.append("* Complementarity: Equations for inequalities and bounds")
        sections.append("* Equality constraints: Original equality constraints")
        sections.append("")

    equations_code = emit_equations(kkt)
    sections.append(equations_code)
    sections.append("")

    # Equation definitions
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Equation Definitions")
        sections.append("* ============================================")
        sections.append("")

    eq_defs_code, index_aliases = emit_equation_definitions(kkt)

    # Emit index aliases if any are needed (to avoid GAMS Error 125)
    # These must be declared before the equation definitions that use them
    if index_aliases:
        if add_comments:
            sections.append("* Index aliases to avoid 'Set is under control already' error")
            sections.append("* (GAMS Error 125 when equation domain index is reused in sum)")
        for idx in sorted(index_aliases):
            alias_name = f"{idx}__"
            sections.append(f"Alias({idx}, {alias_name});")
        sections.append("")

    sections.append(eq_defs_code)
    sections.append("")

    # Issue #724: Fix variables whose paired MCP equation has a dollar condition.
    # When an MCP equation is conditioned (e.g., stat_x(w,t)$(td(w,t)) or
    # comp_minw(t)$(tm(t))), the paired variable must be fixed for excluded
    # instances so GAMS MCP doesn't report unmatched pairs.
    fx_lines: list[str] = []

    # 1. Fix primal variables with conditioned stationarity equations
    for var_name, cond_expr in sorted(kkt.stationarity_conditions.items()):
        var_def = kkt.model_ir.variables.get(var_name)
        if var_def and var_def.domain:
            domain_str = ",".join(var_def.domain)
            domain_vars = frozenset(var_def.domain)
            cond_gams = expr_to_gams(cond_expr, domain_vars=domain_vars)
            # Choose a finite fixing value: prefer fx, then lo (if finite),
            # then up (if finite), else 0.  Infinite bounds (-inf/+inf or None)
            # cannot be emitted as GAMS .fx values.
            if var_def.fx is not None and math.isfinite(var_def.fx):
                fix_val = var_def.fx
            elif var_def.lo is not None and math.isfinite(var_def.lo):
                fix_val = var_def.lo
            elif var_def.up is not None and math.isfinite(var_def.up):
                fix_val = var_def.up
            else:
                fix_val = 0
            fx_lines.append(f"{var_name}.fx({domain_str})$(not ({cond_gams})) = {fix_val};")

    # 2. Fix multipliers whose complementarity equation has a condition
    ref_mults = kkt.referenced_multipliers
    for _eq_name, comp_pair in sorted(kkt.complementarity_ineq.items()):
        if ref_mults is not None and comp_pair.variable not in ref_mults:
            continue
        eq_def = comp_pair.equation
        if eq_def.condition is not None and eq_def.domain:
            mult_name = comp_pair.variable
            domain_str = ",".join(eq_def.domain)
            domain_vars = frozenset(eq_def.domain)
            assert isinstance(eq_def.condition, Expr)
            cond_gams = expr_to_gams(eq_def.condition, domain_vars=domain_vars)
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({cond_gams})) = 0;")

    # 3. Fix equality multipliers (nu_*) whose equation has lead/lag restrictions.
    # Issue #760: stateq(n,k+1) generates rows only for k in ku (ord(k)<=card(k)-1),
    # but nu_stateq(n,k) is declared over the full (n,k) domain.  Fix the terminal
    # instances to 0 so GAMS MCP matching sees no unmatched free variable.
    for eq_name in sorted(kkt.model_ir.equalities):
        if eq_name not in kkt.model_ir.equations:
            continue
        eq_def = kkt.model_ir.equations[eq_name]
        if not eq_def.domain:
            continue
        lhs, rhs = eq_def.lhs_rhs
        lead_l, lag_l = _collect_lead_lag_restrictions(lhs, eq_def.domain)
        lead_r, lag_r = _collect_lead_lag_restrictions(rhs, eq_def.domain)
        lead_offsets = {
            k: max(lead_l.get(k, 0), lead_r.get(k, 0)) for k in set(lead_l) | set(lead_r)
        }
        lag_offsets = {k: max(lag_l.get(k, 0), lag_r.get(k, 0)) for k in set(lag_l) | set(lag_r)}
        # Also incorporate any explicit condition already on the equation
        inferred_cond = _build_domain_condition(lead_offsets, lag_offsets)
        if inferred_cond is None and eq_def.condition is None:
            continue
        mult_name = create_eq_multiplier_name(eq_name)
        if ref_mults is not None and mult_name not in ref_mults:
            continue
        domain_str = ",".join(eq_def.domain)
        if inferred_cond is not None:
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({inferred_cond})) = 0;")
        elif eq_def.condition is not None and isinstance(eq_def.condition, Expr):
            domain_vars = frozenset(eq_def.domain)
            cond_gams = expr_to_gams(eq_def.condition, domain_vars=domain_vars)
            fx_lines.append(f"{mult_name}.fx({domain_str})$(not ({cond_gams})) = 0;")

    if fx_lines:
        if add_comments:
            sections.append("* ============================================")
            sections.append("* Fix inactive variable instances")
            sections.append("* ============================================")
            sections.append("")
            sections.append("* Variables whose paired MCP equation is conditioned must be")
            sections.append("* fixed for excluded instances to satisfy MCP matching.")
            sections.append("")
        sections.extend(fx_lines)
        sections.append("")

    # Model MCP
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Model MCP Declaration")
        sections.append("* ============================================")
        sections.append("")
        sections.append("* Each line pairs an equation with a variable:")
        sections.append("*   equation.variable")
        sections.append("*")
        sections.append("* This defines the complementarity problem:")
        sections.append("*   equation ⊥ variable")
        sections.append("*")
        sections.append("* Meaning: equation = 0 if variable > 0")
        sections.append("*          equation ≥ 0 if variable = 0")
        sections.append("")

    model_code = emit_model_mcp(kkt, model_name)
    sections.append(model_code)
    sections.append("")

    # Solve statement
    if add_comments:
        sections.append("* ============================================")
        sections.append("* Solve Statement")
        sections.append("* ============================================")
        sections.append("")

    solve_code = emit_solve(model_name)
    sections.append(solve_code)

    # Emit NLP objective value capture for pipeline comparison.
    # MCP listings have no "OBJECTIVE VALUE" line, so we assign the NLP objective
    # variable to a fixed-name sentinel scalar after the solve. The pipeline's
    # extract_objective_from_variables() matches "---- PARAMETER nlp2mcp_obj_val".
    # The nlp2mcp_ prefix reduces collision risk with user-defined symbols.
    obj_info = extract_objective_info(kkt.model_ir)
    if obj_info.objvar:
        sections.append("")
        sections.append("Scalar nlp2mcp_obj_val;")
        sections.append(f"nlp2mcp_obj_val = {obj_info.objvar}.l;")
        sections.append("Display nlp2mcp_obj_val;")

    return "\n".join(sections)
