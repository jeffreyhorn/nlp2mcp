# GAMS Emission Documentation

This document explains how nlp2mcp converts the KKT system into executable GAMS MCP code.

## Table of Contents

1. [Overview](#overview)
2. [Output Structure](#output-structure)
3. [Original Symbols Emission](#original-symbols-emission)
4. [Variable Kind Preservation](#variable-kind-preservation)
5. [AST to GAMS Conversion](#ast-to-gams-conversion)
6. [Equation Emission](#equation-emission)
7. [Model MCP Declaration](#model-mcp-declaration)
8. [Sign Conventions](#sign-conventions)
9. [Examples](#examples)

## Overview

The GAMS emission process transforms the KKT system into a complete, runnable GAMS MCP file. The emission pipeline:

```
KKTSystem + ModelIR → GAMS MCP Code
```

Key modules:
- `src/emit/emit_gams.py` - Main orchestration
- `src/emit/templates.py` - Variable/equation declarations
- `src/emit/original_symbols.py` - Sets/parameters emission (Finding #3)
- `src/emit/equations.py` - Equation definitions
- `src/emit/expr_to_gams.py` - AST → GAMS conversion
- `src/emit/model.py` - Model MCP block

## Output Structure

A generated GAMS MCP file has the following structure:

```gams
* ============================================
* Header Comments
* ============================================
* Generated by nlp2mcp
* KKT System overview

* ============================================
* Original Model Declarations
* ============================================
Sets
    ...
;

Alias(...);

Scalars
    ...
;

Parameters
    ...
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================
Variables       * Free variables (CONTINUOUS)
    ...
;

Positive Variables  * Positive variables + multipliers
    ...
;

Binary Variables    * Binary variables (0-1)
    ...
;

* ... other variable kinds ...

* ============================================
* Equations
* ============================================
Equations
    ...
;

* ============================================
* Equation Definitions
* ============================================
* Stationarity equations
stat_x.. ...;

* Inequality complementarity
comp_g.. ...;

* Bound complementarity
bound_lo_x.. ...;

* Original equality equations
objective.. ...;

* ============================================
* Model MCP Declaration
* ============================================
Model mcp_model /
    stat_x.x,
    comp_g.lam_g,
    bound_lo_x.piL_x,
    objective.obj
/;

* ============================================
* Solve Statement
* ============================================
Solve mcp_model using MCP;
```

## Original Symbols Emission

### Finding #3: Use Actual IR Fields

**Critical**: nlp2mcp uses **actual IR dataclass fields**, not invented ones. This was identified as Finding #3 during Sprint 3 planning.

### Sets Emission

**Source**: `SetDef.members` (list of strings)

```python
# Actual IR field (CORRECT):
set_def.members: list[str]

# NOT set_def.elements (does not exist)
```

**Output**:
```gams
Sets
    I /i1, i2, i3/
    J /j1, j2/
;
```

**Implementation** (`src/emit/original_symbols.py`):
```python
def emit_original_sets(model_ir: ModelIR) -> str:
    for set_name, set_def in model_ir.sets.items():
        members_str = ", ".join(set_def.members)  # Use .members
        lines.append(f"    {set_name} /{members_str}/")
```

### Aliases Emission

**Source**: `AliasDef.target` and `AliasDef.universe`

```python
# Actual IR fields (CORRECT):
alias_def.target: str  # Target set name
alias_def.universe: Optional[str]  # Universe constraint (may be None)
```

**Output**:
```gams
Alias(I, i);
Alias(J, j);
```

**Implementation**:
```python
def emit_original_aliases(model_ir: ModelIR) -> str:
    for alias_name, alias_def in model_ir.aliases.items():
        lines.append(f"Alias({alias_def.target}, {alias_name});")
```

### Parameters Emission

**Source**: `ParameterDef.domain` and `ParameterDef.values`

```python
# Actual IR fields (CORRECT):
param_def.domain: tuple[str, ...]  # Empty () for scalars
param_def.values: dict[tuple[str, ...], float]  # Keys are index tuples

# Scalars: domain = (), accessed via values[()] = value
# Multi-dimensional: keys like ("i1", "j2") → format as "i1.j2"
```

**Output**:
```gams
Scalars
    a /2.0/
    b /3.5/
;

Parameters
    c(i) /
        i1 1.0
        i2 2.0
    /
    d(i,j) /
        i1.j1 0.5
        i1.j2 0.7
    /
;
```

**Implementation**:
```python
def emit_original_parameters(model_ir: ModelIR) -> str:
    # Detect scalars: empty domain ()
    scalars = {
        name: param
        for name, param in model_ir.parameters.items()
        if len(param.domain) == 0
    }
    
    # Scalars: access via values[()]
    for name, param in scalars.items():
        value = param.values[()]
        lines.append(f"    {name} /{value}/")
    
    # Multi-dimensional: format keys as "i1.j2"
    for name, param in parameters.items():
        for key_tuple, value in param.values.items():
            key_str = ".".join(key_tuple)  # ("i1", "j2") → "i1.j2"
            lines.append(f"        {key_str} {value}")
```

### Common Mistakes to Avoid

❌ **WRONG**:
```python
# These fields do NOT exist:
set_def.elements  # Use set_def.members
param_def.is_scalar  # Use len(param_def.domain) == 0
param_def.value  # Use param_def.values[()]
param_def.data  # Use param_def.values
```

✅ **CORRECT**:
```python
# Use actual IR fields:
set_def.members
param_def.domain
param_def.values
```

## Variable Kind Preservation

### Finding #4: Preserve Variable Kinds

**Critical**: nlp2mcp preserves original variable kinds (Positive, Binary, Integer, etc.) from the source model. This was identified as Finding #4 during Sprint 3 planning.

### Variable Kinds in GAMS

GAMS supports several variable kinds:

| Kind | GAMS Declaration | IR Enum | Meaning |
|------|-----------------|---------|---------|
| Free | `Variables` | `VarKind.CONTINUOUS` | Unrestricted (-∞, +∞) |
| Positive | `Positive Variables` | `VarKind.POSITIVE` | x ≥ 0 |
| Negative | `Negative Variables` | `VarKind.NEGATIVE` | x ≤ 0 |
| Binary | `Binary Variables` | `VarKind.BINARY` | x ∈ {0, 1} |
| Integer | `Integer Variables` | `VarKind.INTEGER` | x ∈ ℤ |

### Why Preservation Matters

Original variable semantics must be maintained:
- **Positive variables**: May represent quantities (counts, prices)
- **Binary variables**: Represent on/off decisions
- **Integer variables**: Represent discrete counts

Losing this information would make the MCP incorrect or unsolvable.

### Implementation

**Source**: `VariableDef.kind` (VarKind enum)

```python
# Actual IR field (CORRECT):
var_def.kind: VarKind  # Enum value
```

**Grouping by Kind** (`src/emit/templates.py`):
```python
def emit_variables(kkt: KKTSystem) -> str:
    # Group primal variables by kind
    var_groups: dict[VarKind, list[tuple[str, tuple]]] = defaultdict(list)
    
    for var_name, var_def in kkt.model_ir.variables.items():
        if var_name != objvar:
            # Use var_def.kind to group
            var_groups[var_def.kind].append((var_name, var_def.domain))
    
    # Add multipliers to appropriate groups
    # Free multipliers (ν) → CONTINUOUS
    for mult_name in kkt.multipliers_eq:
        var_groups[VarKind.CONTINUOUS].append(mult_name)
    
    # Positive multipliers (λ, π) → POSITIVE
    for mult_name in kkt.multipliers_ineq:
        var_groups[VarKind.POSITIVE].append(mult_name)
    
    # Emit separate blocks per kind
    for kind in [VarKind.CONTINUOUS, VarKind.POSITIVE, VarKind.BINARY, ...]:
        if var_groups[kind]:
            emit_block_for_kind(kind, var_groups[kind])
```

**Output**:
```gams
Variables
    obj           * Objective variable (free)
    nu_eq         * Free multiplier for equality
;

Positive Variables
    x             * Primal variable (positive)
    y             * Primal variable (positive)
    lam_g         * Inequality multiplier
    piL_x         * Lower bound multiplier
;

Binary Variables
    z             * Binary decision variable
;
```

### Mixed Example

For a model with multiple variable kinds:

```gams
* Original model
Positive Variables x, y;
Binary Variables z;
Variables obj;
```

nlp2mcp generates:

```gams
Variables
    obj             * Objective (free)
    nu_balance      * Free multiplier
;

Positive Variables
    x               * Primal (positive)
    y               * Primal (positive)
    lam_capacity    * Inequality multiplier
    piL_x           * Lower bound multiplier
;

Binary Variables
    z               * Primal (binary)
;
```

## AST to GAMS Conversion

### Expression Types

nlp2mcp converts all AST expression nodes to GAMS syntax:

| AST Node | GAMS Syntax | Example |
|----------|-------------|---------|
| `Const` | Literal number | `2.0` |
| `VarRef` | Variable name | `x` or `x(i)` |
| `ParamRef` | Parameter name | `a` or `c(i)` |
| `MultiplierRef` | Multiplier name | `nu_eq` or `lam_g(i)` |
| `Binary("+")` | `+` | `x + y` |
| `Binary("-")` | `-` | `x - y` |
| `Binary("*")` | `*` | `x * y` |
| `Binary("/")` | `/` | `x / y` |
| `Binary("^")` | `**` | `x ** 2` |
| `Unary("+")` | `+` | `+x` |
| `Unary("-")` | `-` | `-x` |
| `Call("exp")` | `exp(...)` | `exp(x)` |
| `Call("log")` | `log(...)` | `log(x)` |
| `Call("sqrt")` | `sqrt(...)` | `sqrt(x)` |
| `Call("sin")` | `sin(...)` | `sin(x)` |
| `Call("cos")` | `cos(...)` | `cos(x)` |
| `Call("tan")` | `tan(...)` | `tan(x)` |
| `Sum` | `sum(...)` | `sum(i, c(i) * x(i))` |

### Power Operator

**Critical**: GAMS uses `**` for exponentiation, not `^`.

AST `Binary("^", base, exp)` converts to GAMS `base ** exp`.

Example:
```python
# AST: Binary("^", VarRef("x"), Const(2))
# GAMS: x ** 2
```

### Operator Precedence

nlp2mcp handles precedence correctly:

| Precedence | Operators | Associativity |
|-----------|-----------|---------------|
| Highest | `**` (power) | Right |
| High | `*`, `/` | Left |
| Medium | `+`, `-` | Left |
| Low | Comparisons | Left |
| Lowest | `and`, `or` | Left |

Parentheses are added automatically when needed:

```python
# Expression: (a + b) * (c - d)
# AST: Binary("*", Binary("+", a, b), Binary("-", c, d))
# GAMS: (a + b) * (c - d)
```

### Indexed Expressions

Variables and parameters with indices:

```gams
x(i)              * Single index
y(i,j)            * Multiple indices
c(i) * x(i)       * Indexed product
sum(i, x(i))      * Sum over index set
```

### Implementation

**Module**: `src/emit/expr_to_gams.py`

```python
def expr_to_gams(expr: Expr) -> str:
    """Convert AST expression to GAMS syntax."""
    match expr:
        case Const(value):
            return str(value)
        
        case VarRef(name, indices):
            if indices:
                idx_str = ",".join(indices)
                return f"{name}({idx_str})"
            return name
        
        case Binary("^", left, right):
            # Power: use **
            left_str = _maybe_paren(left)
            right_str = _maybe_paren(right)
            return f"{left_str} ** {right_str}"
        
        case Sum(index_sets, index_vars, body):
            idx_str = ",".join(index_vars)
            body_str = expr_to_gams(body)
            return f"sum({idx_str}, {body_str})"
```

## Equation Emission

### Equation Declaration

All equations must be declared before use:

```gams
Equations
    stat_x
    stat_y
    comp_g
    bound_lo_x
    objective
    balance(i)    * Indexed equation
;
```

**Indexed equations** include domain in parentheses.

### Equation Definition

Format: `eq_name(domain).. lhs =E= rhs;`

Relation types:
- `=E=` : Equality (`==`)
- `=L=` : Less than or equal (`<=`)
- `=G=` : Greater than or equal (`>=`)

Example:
```gams
* Stationarity
stat_x.. 2 * x + nu_eq - piL_x =E= 0;

* Inequality complementarity
comp_g.. -(x + y - 10) =E= 0;

* Bound complementarity
bound_lo_x.. x - 0 =E= 0;

* Original equality
objective.. obj =E= x ** 2 + y ** 2;

* Indexed equation
balance(i).. sum(j, x(i,j)) =E= demand(i);
```

### Implementation

**Module**: `src/emit/equations.py`

```python
def emit_equation_def(eq_name: str, eq_def: EquationDef) -> str:
    """Emit single equation definition."""
    # Convert LHS and RHS to GAMS
    lhs_str = expr_to_gams(eq_def.lhs)
    rhs_str = expr_to_gams(eq_def.rhs)
    
    # Relation type
    rel_map = {Relation.EQ: "=E=", Relation.LE: "=L=", Relation.GE: "=G="}
    rel_str = rel_map[eq_def.relation]
    
    # Domain (for indexed equations)
    if eq_def.domain:
        domain_indices = ",".join(eq_def.domain)
        return f"{eq_name}({domain_indices}).. {lhs_str} {rel_str} {rhs_str};"
    
    return f"{eq_name}.. {lhs_str} {rel_str} {rhs_str};"
```

## Model MCP Declaration

### Syntax

GAMS Model MCP syntax:
```gams
Model model_name /
    equation1.variable1,
    equation2.variable2,
    ...
/;
```

### Pairing Rules

nlp2mcp follows these pairing rules:

1. **Stationarity**: `stat_x.x`
   - Stationarity equation paired with primal variable

2. **Inequality complementarity**: `comp_g.lam_g`
   - Complementarity equation paired with inequality multiplier

3. **Lower bound complementarity**: `bound_lo_x.piL_x`
   - Lower bound equation paired with lower bound multiplier

4. **Upper bound complementarity**: `bound_up_y.piU_y`
   - Upper bound equation paired with upper bound multiplier

5. **Equality constraints**: `balance.nu_balance`
   - Equality equation paired with free multiplier

6. **Objective defining equation**: `objective.obj`
   - Special case: Paired with objective variable (NOT a multiplier)

### GAMS Syntax Requirements

**Critical**: GAMS does NOT allow:
- Comments inside Model block
- Empty lines inside Model block
- Missing commas between pairs

❌ **WRONG**:
```gams
Model mcp_model /
    * Stationarity
    stat_x.x
    stat_y.y
    
    * Equality
    objective.obj
/;
```

✅ **CORRECT**:
```gams
Model mcp_model /
    stat_x.x,
    stat_y.y,
    objective.obj
/;
```

### Implementation

**Module**: `src/emit/model.py`

```python
def emit_model_mcp(kkt: KKTSystem, model_name: str = "mcp_model") -> str:
    pairs = []
    
    # 1. Stationarity (skip objvar)
    for eq_name, eq_def in kkt.stationarity.items():
        var_name = extract_var_from_stat_eq(eq_name)
        if var_name != objvar:
            pairs.append(f"    {eq_name}.{var_name}")
    
    # 2. Inequality complementarity
    for eq_name, comp_pair in kkt.complementarity_ineq.items():
        pairs.append(f"    {comp_pair.equation.name}.{comp_pair.variable}")
    
    # 3. Bound complementarity (lo and up)
    # ... similar ...
    
    # 4. Equality constraints (including objective defining equation)
    for mult_name, mult_def in kkt.multipliers_eq.items():
        eq_name = mult_def.associated_constraint
        if eq_name == objvar_defining_eq:
            # Special: pair with objvar
            pairs.append(f"    {eq_name}.{objvar}")
        else:
            # Regular: pair with multiplier
            pairs.append(f"    {eq_name}.{mult_name}")
    
    # Filter out comments and empty lines
    actual_pairs = [p for p in pairs if p.strip() and not p.strip().startswith("*")]
    
    # Build with commas
    lines = [f"Model {model_name} /"]
    for i, pair in enumerate(actual_pairs):
        if i < len(actual_pairs) - 1:
            lines.append(pair + ",")
        else:
            lines.append(pair)
    lines.append("/;")
    
    return "\n".join(lines)
```

## Sign Conventions

### Inequality Complementarity

nlp2mcp negates inequalities to create positive slack:

**Original**: `g(x) ≤ 0`  
**Complementarity equation**: `-g(x) = 0`  
**Pairing**: `comp_g.λ_g`

**Why negate?** To ensure:
- If constraint satisfied with slack (`g(x) < 0`), then `-g(x) > 0`, so `λ = 0`
- If constraint active (`g(x) = 0`), then `-g(x) = 0`, so `λ ≥ 0`

### Bound Complementarity

**Lower bound** `x ≥ lo`:
- **Equation**: `x - lo = 0`
- **Pairing**: `bound_lo_x.π^L`

**Upper bound** `x ≤ up`:
- **Equation**: `up - x = 0`
- **Pairing**: `bound_up_x.π^U`

### Stationarity

Signs in stationarity equation:

```
∇f + J_h^T ν + J_g^T λ - π^L + π^U = 0
```

- **Gradient**: `+∇f`
- **Equality Jacobian**: `+J_h^T ν`
- **Inequality Jacobian**: `+J_g^T λ`
- **Lower bound multiplier**: `-π^L`
- **Upper bound multiplier**: `+π^U`

## Examples

### Example 1: Simple Scalar NLP

**Input**:
```gams
Variables x, obj;
Scalars a /2.0/;

Equations objective, stationarity;

objective.. obj =E= x;
stationarity.. x + a =E= 0;

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

**Output** (nlp2mcp generated):
```gams
Scalars
    a /2.0/
;

Variables
    x
    obj
    nu_objective
    nu_stationarity
;

Equations
    stat_x
    objective
    stationarity
;

stat_x.. 1 + (1 + 0 - 0) * nu_stationarity =E= 0;
objective.. obj =E= x;
stationarity.. x + a =E= 0;

Model mcp_model /
    stat_x.x,
    objective.obj,
    stationarity.nu_stationarity
/;

Solve mcp_model using MCP;
```

### Example 2: Indexed Variables with Bounds

**Input**:
```gams
Sets I /i1, i2, i3/;
Parameters c(I) / i1 1.0, i2 2.0, i3 3.0 /;

Positive Variables x(I);
Variables obj;

Equations objective, balance(I);

objective.. obj =E= sum(I, c(I) * x(I));
balance(I).. x(I) =G= c(I);

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

**Output** (nlp2mcp generated):
```gams
Sets
    I /i1, i2, i3/
;

Parameters
    c(I) /
        i1 1.0
        i2 2.0
        i3 3.0
    /
;

Variables
    obj
;

Positive Variables
    x(I)
    lam_balance(I)
    piL_x(I)
;

Equations
    stat_x_i1
    stat_x_i2
    stat_x_i3
    comp_balance(I)
    bound_lo_x(I)
    objective
;

stat_x_i1.. c('i1') + lam_balance('i1') - piL_x('i1') =E= 0;
stat_x_i2.. c('i2') + lam_balance('i2') - piL_x('i2') =E= 0;
stat_x_i3.. c('i3') + lam_balance('i3') - piL_x('i3') =E= 0;

comp_balance(I).. -(x(I) - c(I)) =E= 0;
bound_lo_x(I).. x(I) - 0 =E= 0;

objective.. obj =E= sum(I, c(I) * x(I));

Model mcp_model /
    stat_x_i1.x('i1'),
    stat_x_i2.x('i2'),
    stat_x_i3.x('i3'),
    comp_balance.lam_balance,
    bound_lo_x.piL_x,
    objective.obj
/;

Solve mcp_model using MCP;
```

### Example 3: Mixed Variable Kinds

**Input**:
```gams
Positive Variables x, y;
Binary Variables z;
Variables obj;

Equations objective, constraint;

objective.. obj =E= x ** 2 + y ** 2;
constraint.. x + y + z =E= 10;

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

**Output** (highlighting variable kind preservation):
```gams
Variables
    obj
    nu_constraint
;

Positive Variables
    x
    y
    piL_x
    piL_y
;

Binary Variables
    z
;

Equations
    stat_x
    stat_y
    stat_z
    bound_lo_x
    bound_lo_y
    objective
    constraint
;

* Variable kinds preserved:
* x, y → Positive Variables
* z → Binary Variables
* Multipliers → Positive Variables

stat_x.. 2 * x + nu_constraint - piL_x =E= 0;
stat_y.. 2 * y + nu_constraint - piL_y =E= 0;
stat_z.. nu_constraint =E= 0;

bound_lo_x.. x - 0 =E= 0;
bound_lo_y.. y - 0 =E= 0;

objective.. obj =E= x ** 2 + y ** 2;
constraint.. x + y + z =E= 10;

Model mcp_model /
    stat_x.x,
    stat_y.y,
    stat_z.z,
    bound_lo_x.piL_x,
    bound_lo_y.piL_y,
    objective.obj,
    constraint.nu_constraint
/;

Solve mcp_model using MCP;
```

## See Also

- [KKT Assembly Documentation](../kkt/KKT_ASSEMBLY.md) - KKT system construction
- [System Architecture](../architecture/SYSTEM_ARCHITECTURE.md) - Overall system design
- [Data Structures](../architecture/DATA_STRUCTURES.md) - IR and KKT data structures
