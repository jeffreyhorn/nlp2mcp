# GAMS Emission Documentation

This document explains how nlp2mcp converts the KKT system into executable GAMS MCP code.

## Table of Contents

1. [Overview](#overview)
2. [Output Structure](#output-structure)
3. [Original Symbols Emission](#original-symbols-emission)
4. [Variable Kind Preservation](#variable-kind-preservation)
5. [AST to GAMS Conversion](#ast-to-gams-conversion)
6. [Equation Emission](#equation-emission)
7. [Model MCP Declaration](#model-mcp-declaration)
8. [Sign Conventions](#sign-conventions)
9. [Examples](#examples)

## Overview

The GAMS emission process transforms the KKT system into a complete, runnable GAMS MCP file. The emission pipeline:

```
KKTSystem + ModelIR → GAMS MCP Code
```

Key modules:
- `src/emit/emit_gams.py` - Main orchestration
- `src/emit/templates.py` - Variable/equation declarations
- `src/emit/original_symbols.py` - Sets/parameters emission (Finding #3)
- `src/emit/equations.py` - Equation definitions
- `src/emit/expr_to_gams.py` - AST → GAMS conversion
- `src/emit/model.py` - Model MCP block

## Output Structure

A generated GAMS MCP file has the following structure with extensive comments for readability:

```gams
$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================
Sets
    ...
;

Alias(...);

Scalars
    ...
;

Parameters
    ...
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================
Variables       * Free variables (CONTINUOUS)
    ...
;

Positive Variables  * Positive variables + multipliers
    ...
;

Binary Variables    * Binary variables (0-1)
    ...
;

* ... other variable kinds ...

* ============================================
* Equations
* ============================================
Equations
    ...
;

* ============================================
* Equation Definitions
* ============================================
* Stationarity equations
stat_x.. ...;

* Inequality complementarity
comp_g.. ...;

* Bound complementarity
bound_lo_x.. ...;

* Original equality equations
objective.. ...;

* ============================================
* Model MCP Declaration
* ============================================
Model mcp_model /
    stat_x.x,
    comp_g.lam_g,
    bound_lo_x.piL_x,
    objective.obj
/;

* ============================================
* Solve Statement
* ============================================
Solve mcp_model using MCP;
```

## Original Symbols Emission

### Finding #3: Use Actual IR Fields

**Critical**: nlp2mcp uses **actual IR dataclass fields**, not invented ones. This was identified as Finding #3 during Sprint 3 planning.

### Sets Emission

**Source**: `SetDef.members` (list of strings)

```python
# Actual IR field (CORRECT):
set_def.members: list[str]

# NOT set_def.elements (does not exist)
```

**Output**:
```gams
Sets
    I /i1, i2, i3/
    J /j1, j2/
;
```

**Implementation** (`src/emit/original_symbols.py`):
```python
def emit_original_sets(model_ir: ModelIR) -> str:
    for set_name, set_def in model_ir.sets.items():
        members_str = ", ".join(set_def.members)  # Use .members
        lines.append(f"    {set_name} /{members_str}/")
```

### Aliases Emission

**Source**: `AliasDef.target` and `AliasDef.universe`

```python
# Actual IR fields (CORRECT):
alias_def.target: str  # Target set name
alias_def.universe: Optional[str]  # Universe constraint (may be None)
```

**Output**:
```gams
Alias(I, i);
Alias(J, j);
```

**Implementation**:
```python
def emit_original_aliases(model_ir: ModelIR) -> str:
    for alias_name, alias_def in model_ir.aliases.items():
        lines.append(f"Alias({alias_def.target}, {alias_name});")
```

### Parameters Emission

**Source**: `ParameterDef.domain` and `ParameterDef.values`

```python
# Actual IR fields (CORRECT):
param_def.domain: tuple[str, ...]  # Empty () for scalars
param_def.values: dict[tuple[str, ...], float]  # Keys are index tuples

# Scalars: domain = (), accessed via values[()] = value
# Multi-dimensional: keys like ("i1", "j2") → format as "i1.j2"
```

**Output**:
```gams
Scalars
    a /2.0/
    b /3.5/
;

Parameters
    c(i) /
        i1 1.0
        i2 2.0
    /
    d(i,j) /
        i1.j1 0.5
        i1.j2 0.7
    /
;
```

**Implementation**:
```python
def emit_original_parameters(model_ir: ModelIR) -> str:
    # Detect scalars: empty domain ()
    scalars = {
        name: param
        for name, param in model_ir.parameters.items()
        if len(param.domain) == 0
    }
    
    # Scalars: access via values[()]
    for name, param in scalars.items():
        value = param.values[()]
        lines.append(f"    {name} /{value}/")
    
    # Multi-dimensional: format keys as "i1.j2"
    for name, param in parameters.items():
        for key_tuple, value in param.values.items():
            key_str = ".".join(key_tuple)  # ("i1", "j2") → "i1.j2"
            lines.append(f"        {key_str} {value}")
```

### Common Mistakes to Avoid

❌ **WRONG**:
```python
# These fields do NOT exist:
set_def.elements  # Use set_def.members
param_def.is_scalar  # Use len(param_def.domain) == 0
param_def.value  # Use param_def.values[()]
param_def.data  # Use param_def.values
```

✅ **CORRECT**:
```python
# Use actual IR fields:
set_def.members
param_def.domain
param_def.values
```

## Variable Kind Preservation

### Finding #4: Preserve Variable Kinds

**Critical**: nlp2mcp preserves original variable kinds (Positive, Binary, Integer, etc.) from the source model. This was identified as Finding #4 during Sprint 3 planning.

### Variable Kinds in GAMS

GAMS supports several variable kinds:

| Kind | GAMS Declaration | IR Enum | Meaning |
|------|-----------------|---------|---------|
| Free | `Variables` | `VarKind.CONTINUOUS` | Unrestricted (-∞, +∞) |
| Positive | `Positive Variables` | `VarKind.POSITIVE` | x ≥ 0 |
| Negative | `Negative Variables` | `VarKind.NEGATIVE` | x ≤ 0 |
| Binary | `Binary Variables` | `VarKind.BINARY` | x ∈ {0, 1} |
| Integer | `Integer Variables` | `VarKind.INTEGER` | x ∈ ℤ |

### Why Preservation Matters

Original variable semantics must be maintained:
- **Positive variables**: May represent quantities (counts, prices)
- **Binary variables**: Represent on/off decisions
- **Integer variables**: Represent discrete counts

Losing this information would make the MCP incorrect or unsolvable.

### Implementation

**Source**: `VariableDef.kind` (VarKind enum)

```python
# Actual IR field (CORRECT):
var_def.kind: VarKind  # Enum value
```

**Grouping by Kind** (`src/emit/templates.py`):
```python
def emit_variables(kkt: KKTSystem) -> str:
    # Group primal variables by kind
    var_groups: dict[VarKind, list[tuple[str, tuple]]] = defaultdict(list)
    
    for var_name, var_def in kkt.model_ir.variables.items():
        if var_name != objvar:
            # Use var_def.kind to group
            var_groups[var_def.kind].append((var_name, var_def.domain))
    
    # Add multipliers to appropriate groups
    # Free multipliers (ν) → CONTINUOUS
    for mult_name in kkt.multipliers_eq:
        var_groups[VarKind.CONTINUOUS].append(mult_name)
    
    # Positive multipliers (λ, π) → POSITIVE
    for mult_name in kkt.multipliers_ineq:
        var_groups[VarKind.POSITIVE].append(mult_name)
    
    # Emit separate blocks per kind
    for kind in [VarKind.CONTINUOUS, VarKind.POSITIVE, VarKind.BINARY, ...]:
        if var_groups[kind]:
            emit_block_for_kind(kind, var_groups[kind])
```

**Output**:
```gams
Variables
    obj           * Objective variable (free)
    nu_eq         * Free multiplier for equality
;

Positive Variables
    x             * Primal variable (positive)
    y             * Primal variable (positive)
    lam_g         * Inequality multiplier
    piL_x         * Lower bound multiplier
;

Binary Variables
    z             * Binary decision variable
;
```

### Mixed Example

For a model with multiple variable kinds:

```gams
* Original model
Positive Variables x, y;
Binary Variables z;
Variables obj;
```

nlp2mcp generates:

```gams
Variables
    obj             * Objective (free)
    nu_balance      * Free multiplier
;

Positive Variables
    x               * Primal (positive)
    y               * Primal (positive)
    lam_capacity    * Inequality multiplier
    piL_x           * Lower bound multiplier
;

Binary Variables
    z               * Primal (binary)
;
```

## AST to GAMS Conversion

### Expression Types

nlp2mcp converts all AST expression nodes to GAMS syntax:

| AST Node | GAMS Syntax | Example |
|----------|-------------|---------|
| `Const` | Literal number | `2.0` |
| `VarRef` | Variable name | `x` or `x(i)` |
| `ParamRef` | Parameter name | `a` or `c(i)` |
| `MultiplierRef` | Multiplier name | `nu_eq` or `lam_g(i)` |
| `Binary("+")` | `+` | `x + y` |
| `Binary("-")` | `-` | `x - y` |
| `Binary("*")` | `*` | `x * y` |
| `Binary("/")` | `/` | `x / y` |
| `Binary("^")` | `**` | `x ** 2` |
| `Unary("+")` | `+` | `+x` |
| `Unary("-")` | `-` | `-x` |
| `Call("exp")` | `exp(...)` | `exp(x)` |
| `Call("log")` | `log(...)` | `log(x)` |
| `Call("sqrt")` | `sqrt(...)` | `sqrt(x)` |
| `Call("sin")` | `sin(...)` | `sin(x)` |
| `Call("cos")` | `cos(...)` | `cos(x)` |
| `Call("tan")` | `tan(...)` | `tan(x)` |
| `Sum` | `sum(...)` | `sum(i, c(i) * x(i))` |

### Power Operator

**Critical**: GAMS uses `**` for exponentiation, not `^`.

AST `Binary("^", base, exp)` converts to GAMS `base ** exp`.

Example:
```python
# AST: Binary("^", VarRef("x"), Const(2))
# GAMS: x ** 2
```

### Operator Precedence

nlp2mcp handles precedence correctly:

| Precedence | Operators | Associativity |
|-----------|-----------|---------------|
| Highest | `**` (power) | Right |
| High | `*`, `/` | Left |
| Medium | `+`, `-` | Left |
| Low | Comparisons | Left |
| Lowest | `and`, `or` | Left |

Parentheses are added automatically when needed:

```python
# Expression: (a + b) * (c - d)
# AST: Binary("*", Binary("+", a, b), Binary("-", c, d))
# GAMS: (a + b) * (c - d)
```

### Indexed Expressions

Variables and parameters with indices:

```gams
x(i)              * Single index
y(i,j)            * Multiple indices
c(i) * x(i)       * Indexed product
sum(i, x(i))      * Sum over index set
```

### Implementation

**Module**: `src/emit/expr_to_gams.py`

```python
def expr_to_gams(expr: Expr) -> str:
    """Convert AST expression to GAMS syntax."""
    match expr:
        case Const(value):
            return str(value)
        
        case VarRef(name, indices):
            if indices:
                idx_str = ",".join(indices)
                return f"{name}({idx_str})"
            return name
        
        case Binary("^", left, right):
            # Power: use **
            left_str = _maybe_paren(left)
            right_str = _maybe_paren(right)
            return f"{left_str} ** {right_str}"
        
        case Sum(index_sets, index_vars, body):
            idx_str = ",".join(index_vars)
            body_str = expr_to_gams(body)
            return f"sum({idx_str}, {body_str})"
```

## Equation Emission

### Equation Declaration

All equations must be declared before use:

```gams
Equations
    stat_x
    stat_y
    comp_g
    bound_lo_x
    objective
    balance(i)    * Indexed equation
;
```

**Indexed equations** include domain in parentheses.

### Equation Definition

Format: `eq_name(domain).. lhs =REL= rhs;`

Relation types:
- `=E=` : Equality (`==`)
- `=L=` : Less than or equal (`<=`)
- `=G=` : Greater than or equal (`>=`)

**Note on MCP format**: nlp2mcp uses:
- `=E=` for **stationarity equations** and **original equalities**
- `=G=` for **complementarity equations** (inequalities and bounds)

Example:
```gams
* Stationarity equations (always =E=)
stat_x.. 2 * x + nu_eq - piL_x =E= 0;
stat_y.. 2 * y + nu_eq - piL_y =E= 0;

* Inequality complementarity (uses =G=)
comp_balance(i).. -x(i) =G= 0;

* Bound complementarity (uses =G=)
comp_lo_x.. x + 1 =G= 0;        * Lower bound: x >= -1
comp_up_x.. 2 - x =G= 0;        * Upper bound: x <= 2

* Original equality constraints (always =E=)
objective.. obj =E= x ** 2 + y ** 2;
balance(i).. sum(j, x(i,j)) =E= demand(i);
```

### Implementation

**Module**: `src/emit/equations.py`

```python
def emit_equation_def(eq_name: str, eq_def: EquationDef) -> str:
    """Emit single equation definition."""
    # Convert LHS and RHS to GAMS
    lhs_str = expr_to_gams(eq_def.lhs)
    rhs_str = expr_to_gams(eq_def.rhs)
    
    # Relation type
    rel_map = {Relation.EQ: "=E=", Relation.LE: "=L=", Relation.GE: "=G="}
    rel_str = rel_map[eq_def.relation]
    
    # Domain (for indexed equations)
    if eq_def.domain:
        domain_indices = ",".join(eq_def.domain)
        return f"{eq_name}({domain_indices}).. {lhs_str} {rel_str} {rhs_str};"
    
    return f"{eq_name}.. {lhs_str} {rel_str} {rhs_str};"
```

## Index Handling (Issue #47 Fix)

### Indexed Equations and Variables

**Critical insight from Issue #47:** GAMS MCP requires indexed equations for indexed variables.

#### Correct Approach (Post Issue #47)

For indexed variables like `x(i)`, generate indexed equations:

```gams
* Variable declaration
Variables x(i);

* Equation declaration (includes domain)
Equations stat_x(i);

* Equation definition (uses set index 'i')
stat_x(i).. 2*x(i) + lam_balance(i) =E= 0;

* Model MCP declaration (NO explicit indices)
Model mcp_model /
    stat_x.x,              * GAMS infers indexing from declarations
    comp_balance.lam_balance,
    ...
/;
```

**Key principle:** In Model MCP declarations, equation and variable names are listed WITHOUT explicit indices (e.g., `stat_x.x`, not `stat_x(i).x(i)`). GAMS automatically expands indexed pairs based on each equation's declared domain.

#### Incorrect Approach (Before Issue #47 Fix)

**Do NOT generate element-specific equations:**

```gams
* WRONG - Element-specific equations
stat_x_i1.. 2*x("i1") + lam_balance("i1") =E= 0;
stat_x_i2.. 2*x("i2") + lam_balance("i2") =E= 0;

* WRONG - Cannot pair with indexed variable
Model mcp_model /
    stat_x_i1.x,    * ERROR: Domain violation
    stat_x_i2.x,    * stat_x_i1 has no domain, x has domain (i)
    ...
/;
```

**Why this fails:**
- Variable `x` declared as `Variables x(i);` has domain `(i)`
- Equation `stat_x_i1` declared as `Equations stat_x_i1;` has no domain
- GAMS requires: "If variable has domain, paired equation must have matching domain"

### Set Indices vs Element Labels

- **Set indices** (e.g., `i`, `j`, `k`): Used in indexed equation definitions, remain unquoted
- **Element labels** (e.g., `i1`, `i2`, `j3`): Specific set members, must be quoted when used in expressions

```gams
* Indexed equation uses set indices (unquoted)
balance(i).. sum(j, flow(i,j)) =E= demand(i);

* If you need to reference specific element in expression, quote it
specific_constraint.. x("i1") + x("i2") =E= 10;
```

### Multi-Dimensional Indexing

For variables with multiple indices:

```gams
Variables x(i,j);
Equations stat_x(i,j);

stat_x(i,j).. <expr using i and j> =E= 0;

Model mcp_model /
    stat_x.x,    * Expands to all (i,j) pairs
    ...
/;
```

## Model MCP Declaration

### Syntax

GAMS Model MCP syntax:
```gams
Model model_name /
    equation1.variable1,
    equation2.variable2,
    ...
/;
```

### Pairing Rules

nlp2mcp follows these pairing rules:

1. **Stationarity**: `stat_x.x`
   - Stationarity equation paired with primal variable
   - For indexed variables: equation domain must match variable domain

2. **Inequality complementarity**: `comp_g.lam_g`
   - Complementarity equation paired with inequality multiplier
   - Both equation and multiplier have matching indices

3. **Lower bound complementarity**: `bound_lo_x.piL_x`
   - Lower bound equation paired with lower bound multiplier
   - For indexed bounds, equation and multiplier share indices

4. **Upper bound complementarity**: `bound_up_y.piU_y`
   - Upper bound equation paired with upper bound multiplier
   - For indexed bounds, equation and multiplier share indices

5. **Equality constraints**: `balance.nu_balance`
   - Equality equation paired with free multiplier
   - For indexed equations, multiplier has matching indices

6. **Objective defining equation**: `objective.obj`
   - Special case: Paired with objective variable (NOT a multiplier)
   - Objective variable is typically scalar (no indices)

### GAMS Syntax Requirements

**Critical**: GAMS does NOT allow:
- Comments inside Model block
- Empty lines inside Model block
- Missing commas between pairs

However, nlp2mcp **includes comments BEFORE the Model block** to explain the pairing:

```gams
* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_x.x,
    stat_y.y,
    objective.obj
/;
```

❌ **WRONG** (comments inside Model block):
```gams
Model mcp_model /
    * Stationarity
    stat_x.x,
    stat_y.y,
    
    * Equality
    objective.obj
/;
```

✅ **CORRECT** (comments before Model block):
```gams
* Stationarity equations paired with primal variables
* Equality constraints paired with multipliers

Model mcp_model /
    stat_x.x,
    stat_y.y,
    objective.obj
/;
```

### Implementation

**Module**: `src/emit/model.py`

```python
def emit_model_mcp(kkt: KKTSystem, model_name: str = "mcp_model") -> str:
    pairs = []
    
    # 1. Stationarity (skip objvar)
    for eq_name, eq_def in kkt.stationarity.items():
        var_name = extract_var_from_stat_eq(eq_name)
        if var_name != objvar:
            pairs.append(f"    {eq_name}.{var_name}")
    
    # 2. Inequality complementarity
    for eq_name, comp_pair in kkt.complementarity_ineq.items():
        pairs.append(f"    {comp_pair.equation.name}.{comp_pair.variable}")
    
    # 3. Bound complementarity (lo and up)
    # ... similar ...
    
    # 4. Equality constraints (including objective defining equation)
    for mult_name, mult_def in kkt.multipliers_eq.items():
        eq_name = mult_def.associated_constraint
        if eq_name == objvar_defining_eq:
            # Special: pair with objvar
            pairs.append(f"    {eq_name}.{objvar}")
        else:
            # Regular: pair with multiplier
            pairs.append(f"    {eq_name}.{mult_name}")
    
    # Filter out comments and empty lines
    actual_pairs = [p for p in pairs if p.strip() and not p.strip().startswith("*")]
    
    # Build with commas
    lines = [f"Model {model_name} /"]
    for i, pair in enumerate(actual_pairs):
        if i < len(actual_pairs) - 1:
            lines.append(pair + ",")
        else:
            lines.append(pair)
    lines.append("/;")
    
    return "\n".join(lines)
```

## Sign Conventions

### Inequality Complementarity

nlp2mcp negates inequalities and uses `=G=` (greater than or equal) relation:

**Original**: `g(x) ≤ 0`  
**Complementarity equation**: `-g(x) ≥ 0`  
**GAMS syntax**: `-g(x) =G= 0`  
**Pairing**: `comp_g.λ_g`

**Why negate and use ≥?** MCP format requires:
- If constraint satisfied with slack (`g(x) < 0`), then `-g(x) > 0`, equation satisfied, `λ = 0`
- If constraint active (`g(x) = 0`), then `-g(x) = 0`, boundary of feasible region, `λ ≥ 0`

**Example:**
```gams
* Original: x(i) >= c(i)  (normalized to: -(x(i) - c(i)) <= 0)
* Complementarity: -x(i) =G= 0
* Meaning: Either x(i) > 0 (equation active) or lam = 0 (equation slack)
```

### Bound Complementarity

**Lower bound** `x ≥ lo`:
- **Equation**: `x - lo ≥ 0` (GAMS: `x - lo =G= 0`)
- **Pairing**: `comp_lo_x.π^L`

**Upper bound** `x ≤ up`:
- **Equation**: `up - x ≥ 0` (GAMS: `up - x =G= 0`)
- **Pairing**: `comp_up_x.π^U`

**Example from actual output:**
```gams
* Lower bound complementarity equations
comp_lo_x.. x + 1 =G= 0;        * x >= -1
comp_lo_y.. y - 0 =G= 0;        * y >= 0

* Upper bound complementarity equations
comp_up_x.. 2 - x =G= 0;        * x <= 2
```

### Stationarity

Signs in stationarity equation:

```
∇f + J_h^T ν + J_g^T λ - π^L + π^U = 0
```

- **Gradient**: `+∇f`
- **Equality Jacobian**: `+J_h^T ν`
- **Inequality Jacobian**: `+J_g^T λ`
- **Lower bound multiplier**: `-π^L`
- **Upper bound multiplier**: `+π^U`

## Examples

### Example 1: Simple Scalar NLP

**Input**:
```gams
Scalars a /2.0/;

Variables
    x
    obj
;

Equations
    objective
    stationarity
;

objective.. obj =E= x;
stationarity.. x + a =E= 0;

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

**Output** (nlp2mcp generated):
```gams
$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Scalars
    a /2.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    x
    obj
    nu_objective
    nu_stationarity
;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_x
    objective
    stationarity
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_x.. 1 + (1 + 0 - 0) * nu_stationarity =E= 0;

* Original equality equations
objective.. obj =E= x;
stationarity.. x + a =E= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_x.x,
    objective.obj,
    stationarity.nu_stationarity
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;
```

### Example 2: Indexed Variables with Inequalities

**Input**:
```gams
* Minimal NLP with indexed variables and inequality constraints
Sets
    i /i1, i2, i3/ ;

Parameters
    a(i) /i1 1, i2 2, i3 3/ ;

Variables
    x(i)
    obj ;

Equations
    objective
    balance(i) ;

objective..
    obj =e= sum(i, a(i) * x(i));

balance(i)..
    x(i) =g= 0 ;

Model sample_nlp / all / ;
Solve sample_nlp using NLP minimizing obj ;
```

**Output** (nlp2mcp generated):
```gams
$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /i1, i2, i3/
;

Parameters
    a(i) /i1 1.0, i2 2.0, i3 3.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    x(i)
    obj
    nu_objective
;

Positive Variables
    lam_balance(i)
;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_x(i)
    comp_balance(i)
    objective
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_x(i).. x(i) * 0 + a(i) * 1 + (1 - 0) * lam_balance(i) =E= 0;

* Inequality complementarity equations
comp_balance(i).. -x(i) =G= 0;

* Original equality equations
objective.. obj =E= sum(i, a(i) * x(i));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_x.x,
    comp_balance.lam_balance,
    objective.obj
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;
```

### Example 3: Mixed Variable Kinds

**Note**: This example shows a **condensed version** focusing on variable kind preservation. The actual output includes all headers, comments, and sections shown in Examples 1 and 2.

**Input**:
```gams
* Note: Parser requires variable kinds as prefixes, not separate blocks
Variables
    positive x
    positive y
    binary z
    obj
;

Equations
    objective
    constraint
;

objective.. obj =E= x ** 2 + y ** 2;
constraint.. x + y + z =E= 10;

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

**Output** (condensed, highlighting variable kind preservation):
```gams
Variables
    obj
    nu_constraint
;

Positive Variables
    x
    y
    piL_x
    piL_y
;

Binary Variables
    z
;

Equations
    stat_x
    stat_y
    stat_z
    comp_lo_x
    comp_lo_y
    objective
    constraint
;

* Variable kinds preserved:
* x, y → Positive Variables (originally declared as 'positive')
* z → Binary Variables (originally declared as 'binary')
* Multipliers → Positive Variables (piL_* for bounds)

* Stationarity equations (=E=)
stat_x.. 2 * x + nu_constraint - piL_x =E= 0;
stat_y.. 2 * y + nu_constraint - piL_y =E= 0;
stat_z.. nu_constraint =E= 0;

* Bound complementarity equations (=G=)
comp_lo_x.. x - 0 =G= 0;
comp_lo_y.. y - 0 =G= 0;

* Original equality constraints (=E=)
objective.. obj =E= x ** 2 + y ** 2;
constraint.. x + y + z =E= 10;

Model mcp_model /
    stat_x.x,
    stat_y.y,
    stat_z.z,
    comp_lo_x.piL_x,
    comp_lo_y.piL_y,
    objective.obj,
    constraint.nu_constraint
/;

Solve mcp_model using MCP;
```

## See Also

- [KKT Assembly Documentation](../kkt/KKT_ASSEMBLY.md) - KKT system construction
- [System Architecture](../architecture/SYSTEM_ARCHITECTURE.md) - Overall system design
- [Data Structures](../architecture/DATA_STRUCTURES.md) - IR and KKT data structures
