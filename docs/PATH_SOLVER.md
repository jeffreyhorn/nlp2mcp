# PATH Solver Guide for nlp2mcp

**Last Updated:** November 7, 2025  
**For:** nlp2mcp users working with MCP (Mixed Complementarity Problem) models

---

## Table of Contents

1. [Overview](#overview)
2. [Quick Start](#quick-start)
3. [PATH Solver Options Reference](#path-solver-options-reference)
4. [Configuration Templates](#configuration-templates)
5. [Troubleshooting Decision Tree](#troubleshooting-decision-tree)
6. [Interpreting PATH Output](#interpreting-path-output)
7. [Advanced Topics](#advanced-topics)
8. [FAQ](#faq)

---

## Overview

### What is PATH?

PATH is a state-of-the-art solver for Mixed Complementarity Problems (MCP). It implements a stabilized Newton method with global convergence properties, making it well-suited for solving the KKT (Karush-Kuhn-Tucker) systems generated by nlp2mcp.

**Key Features:**
- Robust convergence for complementarity problems
- Handles inequality constraints efficiently
- Crash method for identifying active constraints
- Stabilization scheme for difficult problems
- Comprehensive diagnostic output

### When to Use PATH?

PATH is the **recommended solver** for all MCP models generated by nlp2mcp. It handles:
- ✅ Standard NLP-to-MCP reformulations
- ✅ Models with many inequality constraints
- ✅ Min/max reformulations (after bug fix)
- ✅ Indexed variables and equations
- ✅ Bounded and unbounded variables

**Research Finding (Sprint 5):** Default PATH options work well for min/max reformulated MCPs. Custom tuning is rarely needed.

---

## Quick Start

### Basic Usage

After converting your NLP to MCP with nlp2mcp, solve it with PATH:

```gams
* Generated by nlp2mcp
$include your_model_mcp.gms

* Specify PATH solver
option mcp = path;

* Solve the MCP
solve your_model using MCP;
```

**That's it!** Default options work for most cases.

### Checking the Solution

After solving, check the model status:

```gams
* Check if solution was found
if (your_model.modelstat = 1,
    display "Solution found (Optimal)";
else
    display "Solver did not converge", your_model.modelstat;
);

* Display solution
display x.l, y.l, obj.l;
```

---

## PATH Solver Options Reference

### How to Set Options

Create a `path.opt` file in your working directory:

```gams
$onecho > path.opt
convergence_tolerance 1e-6
major_iteration_limit 1000
crash_method pnewton
output_major_iterations 1
$offecho

option mcp = path;
your_model.optfile = 1;  * Tell PATH to read path.opt
solve your_model using MCP;
```

### Critical Options

| Option | Default | Description | When to Change |
|--------|---------|-------------|----------------|
| `convergence_tolerance` | `1e-6` | Primary stopping criterion | Use `1e-8` for high precision, `1e-4` for difficult models |
| `major_iteration_limit` | `500` | Max major iterations | Increase to `1000-2000` for complex reformulations |
| `cumulative_iteration_limit` | Inherits `iterlim` | Total pivots allowed | Set `iterlim >= 1000 * N` for N min/max calls |
| `crash_method` | `pnewton` | Active set identification | Try `none` if default fails |
| `proximal_perturbation` | `0` | Singular matrix handling | Enable `1e-4` to `1e-2` for ill-conditioned systems |

### Convergence Control

**`convergence_tolerance`** (Default: `1e-6`)
- Solver declares convergence when residual error falls below this value
- **Tighter (1e-8):** For high-precision requirements, verification, academic work
- **Looser (1e-4):** For difficult models where exact convergence is unattainable
- **Recommendation:** Keep default `1e-6` for nlp2mcp models

**`major_iteration_limit`** (Default: `500`)
- Maximum major (outer) iterations before termination
- **When to increase:** Complex min/max reformulations with many auxiliary variables
- **Recommendation:** Increase to 1000 or 2000 if seeing iteration limit messages

### Iteration Limits

**`cumulative_iteration_limit`** (Set via GAMS `iterlim`)
- Total minor iterations (pivots) across all major iterations
- Set in GAMS: `option iterlim = 2000;`
- **Formula for min/max models:** `iterlim >= 1000 * N` where N is the total number of min/max function calls in the model
- **Example:** Model with 3 min() calls → set `iterlim = 3000` or higher

### Crash Method Options

**`crash_method`** (Default: `pnewton`)
- Quickly identifies active/inactive constraints from starting point
- **`pnewton` (default):** Proximal Newton crash - works well for most problems
- **`none`:** Skip crash, use user-provided initial point
- **When to change:** If crash phase fails or consumes too many iterations, try `none`

**`crash_iteration_limit`** (Default: `50`)
- Maximum iterations for crash procedure
- **Recommendation:** Usually sufficient; increase to `100` if crash shows progress

**`crash_perturb`** (Default: `1`)
- Applies proximal perturbation during crash
- **Recommendation:** Keep enabled for reformulated problems

### Handling Singular Systems

**`proximal_perturbation`** (Default: `0`)
- Initial perturbation to overcome singular basis matrices
- **Critical for:** Min/max reformulations that create near-singular Jacobians
- **Values:** Try `1e-4`, `1e-3`, or `1e-2` if seeing "singular basis" errors
- **When to use:** Enable if PATH reports ill-conditioning or singularity

### Output and Diagnostics

**`output_major_iterations`** (Default: `1`)
- Display major iteration progress
- **0:** Silent, **1:** Summary, **2:** Detailed
- **Recommendation:** Keep at `1` for debugging

**`output_crash_iterations`** (Default: `1`)
- Show crash procedure details
- **Recommendation:** Enable when tuning crash method

**`output_final_statistics`** (Default: `1`)
- Reports merit function, residuals at solution
- **Recommendation:** Always enable for validation

### Resource Limits

**`time_limit`** (Set via GAMS `reslim`)
- Wall-clock seconds allowed
- Set in GAMS: `option reslim = 300;` (5 minutes)

---

## Configuration Templates

### Template 1: Standard (Default - Works for Most Cases)

Use this for typical nlp2mcp models:

```gams
$onecho > path.opt
convergence_tolerance 1e-6
crash_method pnewton
crash_iteration_limit 50
output_major_iterations 1
output_final_statistics 1
$offecho

option mcp = path;
your_model.optfile = 1;
option iterlim = 2000;
solve your_model using MCP;
```

**When to use:** First attempt for any model. Works for 90%+ of cases.

### Template 2: Difficult/Large Min/Max Models

Use this for complex reformulations or large-scale problems:

```gams
$onecho > path.opt
convergence_tolerance 1e-6
major_iteration_limit 1000
crash_method pnewton
crash_iteration_limit 100
proximal_perturbation 1e-4
output_major_iterations 1
output_crash_iterations 1
output_final_statistics 1
$offecho

option mcp = path;
your_model.optfile = 1;
option iterlim = 5000;
solve your_model using MCP;
```

**When to use:** 
- Model has many min/max calls (>10)
- Default configuration hits iteration limits
- Seeing slow convergence

### Template 3: Models Failing with Default Options

Last resort for problematic models:

```gams
$onecho > path.opt
convergence_tolerance 1e-4
major_iteration_limit 2000
crash_method none
proximal_perturbation 1e-3
output_major_iterations 1
output_final_statistics 1
$offecho

option mcp = path;
your_model.optfile = 1;
option iterlim = 10000;
solve your_model using MCP;
```

**When to use:**
- Templates 1 and 2 fail
- Model is known to be ill-conditioned
- Accepting looser convergence tolerance

**Trade-off:** Looser tolerance (`1e-4`) may give less accurate solution.

---

## Troubleshooting Decision Tree

```
┌─────────────────────────────┐
│ PATH solve failed?          │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ Check Model Status          │
│ (your_model.modelstat)      │
└──────────┬──────────────────┘
           │
           ├─── Model Status 1 or 2 ───► ✅ Success (Optimal/Locally Optimal)
           │
           ├─── Model Status 3 ────────► ❌ Unbounded - Check model formulation
           │
           ├─── Model Status 4 or 5 ───► Infeasible - Follow tree below
           │
           └─── Model Status 13 ───────► Iteration limit - Increase iterlim


┌─────────────────────────────┐
│ Model Status 4 or 5         │
│ (Infeasible)                │
└──────────┬──────────────────┘
           │
           ▼
   Try Template 2 (difficult)
           │
           ▼
   ┌─────────────┐
   │ Still fails? │
   └──────┬───────┘
          │
          ├─ YES ──► Try Template 3 (failing)
          │                   │
          │                   ▼
          │          ┌─────────────────┐
          │          │ Still fails?    │
          │          └────────┬─────────┘
          │                   │
          │                   ├─ YES ──► Check model formulation
          │                   │          - Is NLP feasible?
          │                   │          - Constraint conflicts?
          │                   │          - Check bounds
          │                   │
          │                   └─ NO ───► ✅ Success
          │
          └─ NO ───► ✅ Success


┌─────────────────────────────┐
│ Model Status 13             │
│ (Iteration Limit)           │
└──────────┬──────────────────┘
           │
           ▼
   Increase iteration limits:
   - Set iterlim = 5000 or 10000
   - Set major_iteration_limit = 1000 or 2000
           │
           ▼
   ┌─────────────┐
   │ Still fails? │
   └──────┬───────┘
          │
          ├─ YES ──► Model may be very difficult
          │          - Try looser tolerance (1e-4)
          │          - Check for degeneracy
          │
          └─ NO ───► ✅ Success
```

### Quick Troubleshooting Checklist

1. **Check Model Status first**
   ```gams
   display your_model.modelstat;
   ```

2. **For Infeasibility (Status 4/5):**
   - Verify original NLP is feasible
   - Check for constraint conflicts
   - Try Template 2 or 3

3. **For Iteration Limit (Status 13):**
   - Increase `iterlim` to 5000+
   - Increase `major_iteration_limit` to 1000+

4. **For "Singular Basis" errors:**
   - Enable `proximal_perturbation 1e-4`
   - Try `crash_method none`

5. **For Slow Convergence:**
   - Check problem scaling
   - Try tighter or looser tolerance
   - Review initial points

---

## Interpreting PATH Output

### Model Status Codes

| Code | Status | Meaning | Action |
|------|--------|---------|--------|
| 1 | Optimal | Global optimum found | ✅ Accept solution |
| 2 | Locally Optimal | Local optimum found | ✅ Accept solution (may not be global) |
| 3 | Unbounded | Problem is unbounded | ❌ Check model formulation |
| 4 | Infeasible | Problem is infeasible | ❌ Check constraints, try Template 2/3 |
| 5 | Locally Infeasible | Cannot find feasible point | ❌ Try Template 2/3, check formulation |
| 13 | Iteration Limit | Ran out of iterations | ⚠️ Increase `iterlim`, try Template 2 |

### Solve Status Codes

| Code | Status | Meaning |
|------|--------|---------|
| 1 | Normal Completion | Solver finished normally |
| 2 | Iteration Interrupt | Hit iteration limit |
| 3 | Resource Interrupt | Hit time/memory limit |
| 4 | Terminated by Solver | Solver detected error |

### Reading PATH Output

Typical PATH output:

```
Reading options from path.opt
--- PATH 5.0.00 (Release 2022)
*** Status: Normal termination
--- Termination: Complementarity satisfies tolerance
Major Iterations. . . . 15
Minor Iterations. . . . 87
Complementarity Error . 1.2e-07
---
Model Status: 1 (Optimal)
Solve Status: 1 (Normal Completion)
```

**Key Metrics:**
- **Major Iterations:** Number of Newton steps (typically 10-50)
- **Minor Iterations:** Total pivots (typically 50-500)
- **Complementarity Error:** Final residual (should be < convergence_tolerance)

**Good signs:**
- Model Status 1 or 2
- Complementarity Error < 1e-6
- Reasonable iteration counts

**Warning signs:**
- Model Status 4, 5, or 13
- Complementarity Error > 1e-4
- Very high iteration counts (>500 major)

---

## Advanced Topics

### For Min/Max Reformulated Models

**Iteration Scaling:**
- Min/max reformulations add auxiliary variables and constraints
- **Rule of thumb:** Set `iterlim >= 1000 * N` where N is number of min/max calls
- **Example:** 5 min() functions → `iterlim = 5000`

**Convergence Characteristics:**
- May require more iterations than standard MCP
- Complementarity transitions can create near-singular Jacobians
- Default options still work for most cases (validated Sprint 5)

**If convergence fails:**
1. Try Template 2 (proximal perturbation helps with singularity)
2. Check that auxiliary variables have reasonable bounds
3. Verify original NLP solves

### Scaling Recommendations

PATH works best with well-scaled problems:

**Variable Scaling:**
- Avoid variables with vastly different magnitudes (e.g., 1e-6 and 1e6)
- Use GAMS scaling: `x.scale = 100;`

**Constraint Scaling:**
- Keep constraint residuals in similar ranges
- Use equation scaling: `myeq.scale = 1000;`

**Parameter Scaling:**
- Normalize parameters when possible
- Example: Scale prices to 0-100 range

### Warm Starting

PATH can use previous solution as starting point:

```gams
* First solve
solve model1 using MCP;

* Use solution as starting point for related problem
x.l = x.l;  * Keep solution levels
solve model2 using MCP;
```

**When useful:**
- Parameter sensitivity analysis
- Sequential optimization
- Time-stepping problems

### Multiple Solutions

MCPs may have multiple solutions. PATH finds one solution:

```gams
* Try different starting points
x.l = 0;
solve model1 using MCP;
display x.l;  * Solution 1

x.l = 10;
solve model1 using MCP;
display x.l;  * Possibly different solution
```

---

## FAQ

### Q: Do I need to tune PATH options for nlp2mcp models?

**A:** No, in most cases. Sprint 5 research validated that **default PATH options work well** for min/max reformulated MCPs and standard KKT systems. Custom tuning is only needed for:
- Very large models (1000+ variables)
- Ill-conditioned problems
- Models failing with defaults

**Recommendation:** Start with defaults, only tune if you encounter convergence issues.

### Q: What should I do if PATH reports "Locally Infeasible"?

**A:** Follow this sequence:
1. Verify the original NLP is feasible (solve with CONOPT/IPOPT)
2. Check for constraint conflicts in the model
3. Try Template 2 (difficult models configuration)
4. Try Template 3 (looser tolerance)
5. If still failing, the problem may be genuinely infeasible

### Q: How do I know if my solution is accurate?

**A:** Check these indicators:
- ✅ Model Status 1 or 2
- ✅ Complementarity Error < 1e-6
- ✅ All complementarity conditions satisfied (F⊥x means F·x ≈ 0)
- ✅ Constraint violations < tolerance

Display final statistics:
```gams
display your_model.modelstat, your_model.solvestat;
```

### Q: Can I use PATH without GAMS?

**A:** PATH is distributed with GAMS. For nlp2mcp workflow:
1. nlp2mcp generates GAMS-format MCP file
2. GAMS calls PATH solver
3. Solution is returned in GAMS format

Alternative: PATH has a standalone C API, but GAMS integration is recommended for nlp2mcp users.

### Q: What's the difference between major and minor iterations?

**A:**
- **Major iterations:** Newton steps (outer loop)
- **Minor iterations:** Pivots within each Newton step (inner loop, linear solve)

Typical ratio: 1 major iteration = 5-20 minor iterations

**High minor/major ratio** may indicate:
- Degeneracy
- Poor scaling
- Near-singular Jacobian

### Q: Why does PATH sometimes take longer than NLP solvers?

**A:** Several reasons:
1. **MCP is more general** than NLP (complementarity vs optimization)
2. **KKT reformulation** doubles the number of variables (adds multipliers)
3. **Complementarity handling** requires specialized algorithms
4. **Active set identification** (crash phase) takes time

**Trade-off:** PATH handles complementarity rigorously, NLP solvers may miss degenerate solutions.

### Q: How do I report PATH issues?

**A:** Include in your bug report:
1. Model Status and Solve Status
2. PATH iteration counts (major/minor)
3. Complementarity error
4. PATH options used (attach path.opt if custom)
5. Model size (number of variables/equations)
6. Whether original NLP solves

Example:
```
PATH failed with Model Status 5 (Locally Infeasible)
- Major iterations: 347
- Minor iterations: 2891
- Complementarity error: 1.2e-3
- Model: 50 variables, 45 equations
- Original NLP: Solves with CONOPT (optimal)
- Options: Default (no path.opt)
```

---

## Additional Resources

### Documentation
- **PATH Solver Manual:** https://www.gams.com/latest/docs/S_PATH.html
- **GAMS MCP Documentation:** https://www.gams.com/latest/docs/UG_ModelSolve.html#UG_ModelSolve_ModelClassificationOfModels_MCP
- **nlp2mcp User Guide:** [USER_GUIDE.md](USER_GUIDE.md)

### Research Papers
- Dirkse, S. P., and Ferris, M. C., "The PATH Solver: A Non-monotone Stabilization Scheme for Mixed Complementarity Problems," *Optimization Methods and Software*, 1995.
- Ferris, M. C., and Munson, T. S., "Complementarity Problems in GAMS and the PATH Solver," *Journal of Economic Dynamics and Control*, 2000.

### Support
- **nlp2mcp Issues:** https://github.com/your-repo/nlp2mcp/issues
- **GAMS Support:** https://www.gams.com/support/
- **PATH Solver:** Contact GAMS support for PATH-specific questions

---

**Document Version:** 1.0  
**Last Reviewed:** November 7, 2025 (Sprint 5, Day 3)  
**Maintained by:** nlp2mcp development team
