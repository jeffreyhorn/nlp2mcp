# KKT Assembly Documentation

This document explains how nlp2mcp transforms a Nonlinear Programming (NLP) model into a Mixed Complementarity Problem (MCP) using Karush-Kuhn-Tucker (KKT) conditions.

## Table of Contents

1. [Mathematical Background](#mathematical-background)
2. [KKT System Components](#kkt-system-components)
3. [Stationarity Equations](#stationarity-equations)
4. [Complementarity Conditions](#complementarity-conditions)
5. [Multiplier Naming Conventions](#multiplier-naming-conventions)
6. [Infinite Bounds Handling](#infinite-bounds-handling)
7. [Objective Variable Handling](#objective-variable-handling)
8. [Duplicate Bounds Exclusion](#duplicate-bounds-exclusion)
9. [Implementation Details](#implementation-details)

## Mathematical Background

### Standard NLP Form

An NLP problem in standard form is:

```
minimize   f(x)
subject to h(x) = 0     (equality constraints)
           g(x) ≤ 0     (inequality constraints)
           lo ≤ x ≤ up  (variable bounds)
```

Where:
- `x ∈ ℝⁿ` is the vector of decision variables
- `f: ℝⁿ → ℝ` is the objective function
- `h: ℝⁿ → ℝᵐ` are equality constraints
- `g: ℝⁿ → ℝᵖ` are inequality constraints
- `lo, up ∈ ℝⁿ` are variable bounds (may include ±∞)

### KKT Conditions

The Karush-Kuhn-Tucker conditions for an NLP are necessary conditions for optimality:

1. **Stationarity**: ∇f(x) + J_h(x)ᵀν + J_g(x)ᵀλ - π^L + π^U = 0
2. **Primal Feasibility**: 
   - h(x) = 0
   - g(x) ≤ 0
   - lo ≤ x ≤ up
3. **Dual Feasibility**: λ ≥ 0, π^L ≥ 0, π^U ≥ 0
4. **Complementarity**:
   - λᵢ · gᵢ(x) = 0 for all i (inequality complementarity)
   - π^L_j · (x_j - lo_j) = 0 for all j (lower bound complementarity)
   - π^U_j · (up_j - x_j) = 0 for all j (upper bound complementarity)

Where:
- `ν ∈ ℝᵐ` are free multipliers for equality constraints (unrestricted in sign)
- `λ ∈ ℝᵖ` are positive multipliers for inequality constraints (λ ≥ 0)
- `π^L ∈ ℝⁿ` are positive multipliers for lower bounds (π^L ≥ 0)
- `π^U ∈ ℝⁿ` are positive multipliers for upper bounds (π^U ≥ 0)

### MCP Formulation

nlp2mcp converts these KKT conditions into an MCP where each equation is paired with a complementary variable:

```
equation ⊥ variable
```

This notation means:
- If variable > 0, then equation = 0 (equation holds with equality)
- If equation > 0, then variable = 0 (variable at its lower bound)

## KKT System Components

The KKT system generated by nlp2mcp consists of:

1. **Stationarity Equations**: One per primal variable (except objective variable)
2. **Inequality Complementarity Pairs**: Equation-multiplier pairs for g(x) ≤ 0
3. **Lower Bound Complementarity Pairs**: Equation-multiplier pairs for x ≥ lo
4. **Upper Bound Complementarity Pairs**: Equation-multiplier pairs for x ≤ up
5. **Equality Constraints**: Original equality constraints h(x) = 0
6. **Objective Defining Equation**: Equation that defines the objective variable

## Stationarity Equations

### Mathematical Form

For each primal variable xⱼ (except the objective variable), nlp2mcp generates a stationarity equation:

```
stat_xⱼ: ∂f/∂xⱼ + Σᵢ (∂hᵢ/∂xⱼ · νᵢ) + Σᵢ (∂gᵢ/∂xⱼ · λᵢ) - π^L_j + π^U_j = 0
```

### Implementation

The stationarity builder (`src/kkt/stationarity.py`):

1. **Iterates over variable instances** using index mapping
2. **Builds gradient term**: `∂f/∂xⱼ` from the objective gradient
3. **Adds Jacobian transpose terms**: 
   - Equality: `Σᵢ (∂hᵢ/∂xⱼ · νᵢ)`
   - Inequality: `Σᵢ (∂gᵢ/∂xⱼ · λᵢ)`
4. **Subtracts lower bound multiplier**: `-π^L_j` (if finite bound exists)
5. **Adds upper bound multiplier**: `+π^U_j` (if finite bound exists)
6. **Skips objective variable**: No stationarity equation for objvar
7. **Skips objective defining equation** in Jacobian terms

### Example

For a simple problem:
```
minimize   x² + y²
subject to x + y = 10
           0 ≤ x, 0 ≤ y ≤ 5
```

Stationarity equations:
```
stat_x: 2x + ν_eq - π^L_x = 0     (paired with x)
stat_y: 2y + ν_eq - π^L_y + π^U_y = 0  (paired with y)
```

### Indexed Variables

For indexed variables, nlp2mcp creates one stationarity equation per instance:

```
stat_x_i1: ∂f/∂x(i1) + Σⱼ (∂hⱼ/∂x(i1) · νⱼ) + ... = 0
stat_x_i2: ∂f/∂x(i2) + Σⱼ (∂hⱼ/∂x(i2) · νⱼ) + ... = 0
...
```

Each stationarity equation is paired with its corresponding variable instance in the MCP.

## Complementarity Conditions

### Inequality Complementarity

For each inequality constraint `gᵢ(x) ≤ 0`, nlp2mcp creates:

**Equation**:
```
comp_gᵢ: -gᵢ(x) = 0
```

**Pairing**:
```
comp_gᵢ.λᵢ
```

**Sign Convention**: The inequality is negated to `-gᵢ(x)` to represent the slack. This ensures:
- If `-gᵢ(x) > 0` (constraint satisfied with slack), then `λᵢ = 0`
- If `λᵢ > 0` (constraint active), then `-gᵢ(x) = 0` (i.e., `gᵢ(x) = 0`)

### Lower Bound Complementarity

For each finite lower bound `xⱼ ≥ loⱼ`, nlp2mcp creates:

**Equation**:
```
bound_lo_xⱼ: xⱼ - loⱼ = 0
```

**Pairing**:
```
bound_lo_xⱼ.π^L_j
```

**Interpretation**:
- If `xⱼ - loⱼ > 0` (variable above bound), then `π^L_j = 0`
- If `π^L_j > 0` (lower bound active), then `xⱼ - loⱼ = 0` (i.e., `xⱼ = loⱼ`)

### Upper Bound Complementarity

For each finite upper bound `xⱼ ≤ upⱼ`, nlp2mcp creates:

**Equation**:
```
bound_up_xⱼ: upⱼ - xⱼ = 0
```

**Pairing**:
```
bound_up_xⱼ.π^U_j
```

**Interpretation**:
- If `upⱼ - xⱼ > 0` (variable below bound), then `π^U_j = 0`
- If `π^U_j > 0` (upper bound active), then `upⱼ - xⱼ = 0` (i.e., `xⱼ = upⱼ`)

### Indexed Bounds

For indexed variables with per-instance bounds, nlp2mcp creates separate complementarity pairs for each instance:

```
bound_lo_x_i1: x(i1) - lo(i1) = 0  ⊥  π^L_x_i1
bound_lo_x_i2: x(i2) - lo(i2) = 0  ⊥  π^L_x_i2
...
```

This handles cases where different instances have different bound values.

## Multiplier Naming Conventions

nlp2mcp uses consistent naming conventions for multipliers:

| Multiplier Type | Prefix | Sign | Example |
|----------------|--------|------|---------|
| Equality constraints | `nu_` | Free (unrestricted) | `nu_balance` |
| Inequality constraints | `lam_` | Positive (≥ 0) | `lam_capacity` |
| Lower bounds | `piL_` | Positive (≥ 0) | `piL_x` |
| Upper bounds | `piU_` | Positive (≥ 0) | `piU_y` |

### Indexed Multipliers

For indexed constraints and bounds:
- **Equality**: `nu_balance_i` for constraint `balance(i)`
- **Inequality**: `lam_capacity_j` for constraint `capacity(j)`
- **Lower bound**: `piL_x_i` for bound on `x(i)`
- **Upper bound**: `piU_y_j_k` for bound on `y(j,k)`

The index suffixes match the constraint/variable indices.

## Infinite Bounds Handling

### Mathematical Rationale

When a bound is infinite (`±∞`), the corresponding bound multiplier is meaningless:
- An infinite lower bound means the variable is effectively unbounded below
- An infinite upper bound means the variable is effectively unbounded above
- The complementarity condition for an infinite bound is trivial

### Implementation

nlp2mcp **filters out infinite bounds** during constraint partitioning:

1. **Scalar variables**: Check `var_def.lo` and `var_def.up` for `±INF`
2. **Indexed variables**: Check each instance in `var_def.lo_map` and `var_def.up_map`
3. **Skip infinite bounds**: Do not create bound multipliers or complementarity pairs
4. **Stationarity impact**: Omit π terms for infinite bounds in stationarity equations

### Example

```python
# Scalar variable with infinite lower bound
x.lo = float('-inf')  # No π^L_x created
x.up = 10.0           # π^U_x created

# Indexed variable with mixed bounds
x.lo_map = {
    ('i1',): 0.0,              # π^L_x_i1 created
    ('i2',): float('-inf'),    # No π^L_x_i2 created
}
```

### Tracked Information

The `KKTSystem` tracks skipped infinite bounds in `skipped_infinite_bounds`:
```python
skipped_infinite_bounds: list[tuple[str, tuple, str]]
# Each entry: (var_name, indices, 'lo'|'up')
```

This allows reporting to users which bounds were excluded.

## Objective Variable Handling

### Background

In GAMS NLP models, the objective is often defined by an equation rather than being the direct optimization expression. For example:

```gams
Variables x, y, obj;
Equations objective;

objective.. obj =E= x**2 + y**2;

Model mymodel /all/;
Solve mymodel using NLP minimizing obj;
```

Here, `obj` is the objective variable, and `objective` is the objective defining equation.

### Special Treatment

nlp2mcp gives the objective variable special treatment:

1. **No stationarity equation** for `obj`
   - The objective variable is not a primal decision variable
   - Its value is determined by the objective defining equation
   - Creating a stationarity equation for it would be redundant

2. **Objective defining equation excluded** from Jacobian terms
   - When building stationarity for other variables, the objective defining equation is not included in the Jacobian transpose sum
   - This prevents circular dependencies

3. **Pairing in Model MCP**
   - The objective defining equation is paired with the objective variable:
     ```
     objective.obj
     ```
   - This is NOT a complementarity pair—it's a direct equation-variable pairing
   - The objective variable is free (unrestricted), not a multiplier

### Identification

The objective information is extracted in `src/kkt/objective.py`:

```python
def extract_objective_info(model_ir: ModelIR) -> ObjectiveInfo:
    """Extract objective variable and defining equation.
    
    Returns:
        ObjectiveInfo with:
        - objvar: Name of objective variable (e.g., 'obj')
        - sense: 'min' or 'max'
        - defining_equation: Name of equation defining objvar (may be None)
    """
```

### Example

For the problem above:
```
minimize obj
subject to obj = x² + y²
```

The KKT system includes:
- **No** `stat_obj` equation
- **Yes** `objective.obj` pairing in Model MCP
- Stationarity for x and y **does not** include terms from `objective` equation

## Duplicate Bounds Exclusion

### Finding #1 from Sprint 3 Planning

One critical issue identified during planning was: **Duplicate bounds must be excluded, not just warned.**

### Problem

In GAMS, users may specify both:
1. **Variable bounds**: `x.lo = 0; x.up = 10;`
2. **Explicit inequality constraints**: `x =G= 0; x =L= 10;`

If nlp2mcp creates complementarity pairs for both, we get:
- **Duplicate lower bound**: Both `bound_lo_x.π^L_x` and `comp_x_ge_0.λ_x_ge_0`
- **Duplicate upper bound**: Both `bound_up_x.π^U_x` and `comp_x_le_10.λ_x_le_10`

This is mathematically incorrect—each bound should have only one multiplier.

### Solution

During constraint partitioning (`src/kkt/partition.py`), nlp2mcp:

1. **Detects duplicate bounds**: Checks if an inequality constraint duplicates a variable bound
2. **Excludes from inequality list**: Skips the duplicate inequality
3. **Tracks excluded bounds**: Stores in `duplicate_bounds_excluded` list
4. **Reports with `--show-excluded`**: CLI option shows which bounds were excluded

### Detection Logic

```python
def _duplicates_variable_bound(model_ir: ModelIR, ineq_name: str) -> bool:
    """Check if inequality duplicates a variable bound.
    
    Returns True if inequality is of form:
    - x =G= constant (duplicates x.lo)
    - x =L= constant (duplicates x.up)
    """
```

### CLI Reporting

```bash
$ nlp2mcp model.gms --show-excluded
...
Excluded duplicate bounds:
  - x_lower_bound (duplicates x.lo = 0)
  - y_upper_bound (duplicates y.up = 10)
```

## Implementation Details

### Module Structure

The KKT assembly is split across several modules in `src/kkt/`:

| Module | Purpose |
|--------|---------|
| `partition.py` | Constraint partitioning (equalities, inequalities, bounds) |
| `objective.py` | Objective variable and defining equation extraction |
| `multipliers.py` | Multiplier definition creation |
| `stationarity.py` | Stationarity equation generation |
| `complementarity.py` | Complementarity pair generation |
| `assemble.py` | Main orchestration—assembles complete KKT system |
| `kkt_system.py` | KKTSystem dataclass definition |

### Assembly Pipeline

The main assembly function (`src/kkt/assemble.py`):

```python
def assemble_kkt_system(
    model_ir: ModelIR,
    gradient: GradientVector,
    J_eq: JacobianStructure,
    J_ineq: JacobianStructure
) -> KKTSystem:
    """Assemble complete KKT system from NLP model and derivatives."""
```

Steps:
1. Partition constraints → equalities, inequalities, bounds
2. Extract objective info → objvar, defining_equation
3. Create multiplier definitions → ν, λ, π^L, π^U
4. Initialize KKTSystem with multipliers
5. Build stationarity equations → one per variable (except objvar)
6. Build complementarity pairs → inequalities and bounds
7. Return assembled KKTSystem

### Key Data Structures

**KKTSystem**:
```python
@dataclass
class KKTSystem:
    model_ir: ModelIR
    stationarity: dict[str, EquationDef]  # stat_x → equation
    complementarity_ineq: dict[str, ComplementarityPair]  # g_i → (eq, var)
    complementarity_bounds_lo: dict[tuple, ComplementarityPair]  # (var, idx) → (eq, var)
    complementarity_bounds_up: dict[tuple, ComplementarityPair]  # (var, idx) → (eq, var)
    multipliers_eq: dict[str, MultiplierDef]  # nu_* multipliers
    multipliers_ineq: dict[str, MultiplierDef]  # lam_* multipliers
    multipliers_bounds_lo: dict[tuple, MultiplierDef]  # piL_* multipliers
    multipliers_bounds_up: dict[tuple, MultiplierDef]  # piU_* multipliers
    skipped_infinite_bounds: list[tuple[str, tuple, str]]
    duplicate_bounds_excluded: list[str]
```

**ComplementarityPair**:
```python
@dataclass
class ComplementarityPair:
    equation: EquationDef  # The equation
    variable: str  # Variable name
    variable_indices: tuple  # Variable indices (empty for scalar)
```

### Index Handling

For indexed constraints and variables:
- **Inequality keys**: Simple string (constraint name)
- **Bound keys**: Tuple `(var_name, indices)` for per-instance tracking
- **Multiplier indices**: Match constraint/variable indices

Example:
```python
# Inequality: capacity(i,j) ≤ 0
complementarity_ineq['capacity'] = ComplementarityPair(...)

# Bounds: x(i).lo = 0
complementarity_bounds_lo[('x', ('i1',))] = ComplementarityPair(...)
complementarity_bounds_lo[('x', ('i2',))] = ComplementarityPair(...)
```

## References

- **KKT Conditions**: Nocedal & Wright, "Numerical Optimization", 2nd ed., Chapter 12
- **MCP Formulation**: Ferris & Pang, "Engineering and Economic Applications of Complementarity Problems", SIAM Review, 1997
- **GAMS PATH Solver**: Dirkse & Ferris, "The PATH Solver: A Non-monotone Stabilization Scheme for Mixed Complementarity Problems", Optimization Methods and Software, 1995

## See Also

- [GAMS Emission Documentation](../emit/GAMS_EMISSION.md) - How the KKT system is converted to GAMS MCP code
- [System Architecture](../architecture/SYSTEM_ARCHITECTURE.md) - Overall system design
- [Data Structures](../architecture/DATA_STRUCTURES.md) - IR and KKT data structures
