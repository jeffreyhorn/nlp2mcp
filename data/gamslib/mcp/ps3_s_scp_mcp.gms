$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /0, 1, 2/
;

Alias(i, j);

Parameters
    theta(i) /0 0.1, 1 0.4, 2 0.9/
    p(i) /0 0.2, 1 0.5, 2 0.3/
;

Scalars
    ru /0.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    Util
    nu_rev(i)
;

Positive Variables
    x(i)
    b(i)
    w(i)
    lam_pc(i)
    lam_ic(i,j)
    lam_licd(i)
    lam_licu(i)
    piL_x(i)
;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_b(i)
    stat_util
    stat_w(i)
    stat_x(i)
    comp_ic(i,j)
    comp_licd(i)
    comp_licu(i)
    comp_pc(i)
    comp_lo_x(i)
    obj
    rev(i)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_b(i).. ((-1) * p(i)) + 1 * nu_rev(i) + 0 * lam_pc(i) + sum(j, 0 * lam_ic(i,j)) + 0 * lam_licd(i) + 0 * lam_licu(i) =E= 0;
stat_util.. ((-1) * sum(i, 0)) + 0 * nu_rev("0") + 0 * nu_rev("1") + 0 * nu_rev("2") + 0 * lam_pc("0") + 0 * lam_pc("1") + 0 * lam_pc("2") + 0 * lam_ic("0","0") + 0 * lam_ic("0","1") + 0 * lam_ic("0","2") + 0 * lam_ic("1","0") + 0 * lam_ic("1","1") + 0 * lam_ic("1","2") + 0 * lam_ic("2","0") + 0 * lam_ic("2","1") + 0 * lam_ic("2","2") + 0 * lam_licd("0") + 0 * lam_licd("1") + 0 * lam_licd("2") + 0 * lam_licu("0") + 0 * lam_licu("1") + 0 * lam_licu("2") =E= 0;
stat_w(i).. ((-1) * (p(i) * (-1))) + 0 * nu_rev(i) + (-1) * lam_pc(i) + sum(j, 0 * lam_ic(i,j)) + (-1) * lam_licd(i) + (-1) * lam_licu(i) =E= 0;
stat_x(i).. 0 + ((-1) * (0.5 * power(x(i), -0.5))) * nu_rev(i) + (1 - theta(i) + sqr(theta(i))) * lam_pc(i) + sum(j, 0 * lam_ic(i,j)) + (1 - theta(i) + sqr(theta(i))) * lam_licd(i) + (1 - theta(i) + sqr(theta(i))) * lam_licu(i) - piL_x(i) =E= 0;

* Inequality complementarity equations
comp_ic(i,j).. w(i) - (theta(i) + (1 - theta(i) + sqr(theta(i))) * x(i)) =G= 0;
comp_licd(i).. w(i) - (theta(i) + (1 - theta(i) + sqr(theta(i))) * x(i)) =G= 0;
comp_licu(i).. w(i) - (theta(i) + (1 - theta(i) + sqr(theta(i))) * x(i)) =G= 0;
comp_pc(i).. w(i) - (theta(i) + (1 - theta(i) + sqr(theta(i))) * x(i)) =G= 0;

* Lower bound complementarity equations
comp_lo_x(i).. x(i) - 0.0001 =G= 0;

* Original equality equations
obj.. Util =E= sum(i, p(i) * (b(i) - w(i)));
rev(i).. b(i) =E= x(i) ** 0.5;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_b.b,
    stat_util.util,
    stat_w.w,
    stat_x.x,
    comp_ic.lam_ic,
    comp_licd.lam_licd,
    comp_licu.lam_licu,
    comp_pc.lam_pc,
    obj.Util,
    rev.nu_rev,
    comp_lo_x.piL_x
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;