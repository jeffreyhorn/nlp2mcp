$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    t /'1990', '1991', '1992', '1993', '1994', '1995', '1996', '1997', '1998', '1999', '2000'/
    tfirst(t)
    tlast(t)
;

Parameters
    beta(t)
    al(t)
;

Scalars
    bet /0.95/
    b /0.25/
    g /0.03/
    ac /0.15/
    k0 /3.0/
    i0 /0.05/
    c0 /0.95/
    a /0.0/
;

tfirst(t) = 1$(ord(t) = 1);
tlast(t) = 1$(ord(t) = card(t));

a = (c0 + i0) / k0 ** b;
beta(t) = bet ** ord(t);
beta(tlast) = beta(tlast) / (1 - bet);
al(t) = a * (1 + g) ** ((1 - b) * (ord(t) - 1));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    k(t)
    c(t)
    i(t)
    utility
    nu_cc(t)
    nu_kk(t)
;

Positive Variables
    lam_tc(t)
    piL_k(t)
    piL_c(t)
    piL_i(t)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

k.l("1990") = 3.0;
k.l("1991") = 3.0;
k.l("1992") = 3.0;
k.l("1993") = 3.0;
k.l("1994") = 3.0;
k.l("1995") = 3.0;
k.l("1996") = 3.0;
k.l("1997") = 3.0;
k.l("1998") = 3.0;
k.l("1999") = 3.0;
k.l("2000") = 3.0;
c.l("1990") = 0.95;
c.l("1991") = 0.95;
c.l("1992") = 0.95;
c.l("1993") = 0.95;
c.l("1994") = 0.95;
c.l("1995") = 0.95;
c.l("1996") = 0.95;
c.l("1997") = 0.95;
c.l("1998") = 0.95;
c.l("1999") = 0.95;
c.l("2000") = 0.95;
i.l("1990") = 0.05;
i.l("1991") = 0.05;
i.l("1992") = 0.05;
i.l("1993") = 0.05;
i.l("1994") = 0.05;
i.l("1995") = 0.05;
i.l("1996") = 0.05;
i.l("1997") = 0.05;
i.l("1998") = 0.05;
i.l("1999") = 0.05;
i.l("2000") = 0.05;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_c(t)
    stat_i(t)
    stat_k(t)
    comp_tc(t)
    comp_lo_c(t)
    comp_lo_i(t)
    comp_lo_k(t)
    cc(t)
    kk(t)
    util
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_c(t).. ((-1) * (beta(t) * 1 / c(t))) - nu_cc(t) - piL_c(t) =E= 0;
stat_i(t).. ((-1) * nu_cc(t)) - nu_kk(t) + sum(tlast, (-1) * lam_tc(tlast)) - piL_i(t) =E= 0;
stat_k(t).. al(t) * k(t) ** b * b / k(t) * nu_cc(t) - nu_kk(t) + sum(tlast, g * lam_tc(tlast)) - piL_k(t) =E= 0;

* Inequality complementarity equations
comp_tc(tlast).. ((-1) * (g * k(tlast) - i(tlast))) =G= 0;

* Lower bound complementarity equations
comp_lo_c(t).. c(t) - 0.95 =G= 0;
comp_lo_i(t).. i(t) - 0.05 =G= 0;
comp_lo_k(t).. k(t) - 3 =G= 0;

* Original equality equations
cc(t).. al(t) * k(t) ** b =E= c(t) + i(t);
kk(t)$(ord(t) <= card(t) - 1).. k(t+1) =E= k(t) + i(t);
util.. utility =E= sum(t, beta(t) * log(c(t)));


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_kk.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_c.c,
    stat_i.i,
    stat_k.k,
    comp_tc.lam_tc,
    cc.nu_cc,
    kk.nu_kk,
    util.utility,
    comp_lo_c.piL_c,
    comp_lo_i.piL_i,
    comp_lo_k.piL_k
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = utility.l;
Display nlp2mcp_obj_val;