$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /ahmsa, fundidora, sicartsa, hylsa, hylsap/
    j /'mexico-df', monterrey, guadalaja/
    c /pellets, coke, 'nat-gas', electric, scrap, 'pig-iron', sponge, steel/
    cf(c) /steel/
    ci(c) /sponge, 'pig-iron'/
    cr(c) /pellets, coke, 'nat-gas', electric, scrap/
    p /'pig-iron', sponge, 'steel-oh', 'steel-el', 'steel-bof'/
    m /'blast-furn', openhearth, bof, 'direct-red', 'elec-arc'/
;

Parameters
    a(c,p) /pellets.'pig-iron' -1.58, pellets.sponge -1.38, coke.'pig-iron' -0.63, 'nat-gas'.sponge -0.57, electric.'steel-el' -0.58, scrap.'steel-oh' -0.33, scrap.'steel-el' -0.12, 'pig-iron'.'pig-iron' 1.0, 'pig-iron'.'steel-oh' -0.77, 'pig-iron'.'steel-bof' -0.95, sponge.sponge 1.0, sponge.'steel-oh' -1.09, steel.'steel-oh' 1.0, steel.'steel-el' 1.0, steel.'steel-bof' 1.0, sponge.'pig-iron' 0.0, sponge.'steel-el' 0.0, sponge.'steel-bof' 0.0, 'nat-gas'.'pig-iron' 0.0, 'nat-gas'.'steel-oh' 0.0, 'nat-gas'.'steel-el' 0.0, 'nat-gas'.'steel-bof' 0.0, coke.sponge 0.0, coke.'steel-oh' 0.0, coke.'steel-el' 0.0, coke.'steel-bof' 0.0, pellets.'steel-oh' 0.0, pellets.'steel-el' 0.0, pellets.'steel-bof' 0.0, 'pig-iron'.sponge 0.0, 'pig-iron'.'steel-el' 0.0, steel.'pig-iron' 0.0, steel.sponge 0.0, electric.'pig-iron' 0.0, electric.sponge 0.0, electric.'steel-oh' 0.0, electric.'steel-bof' 0.0, scrap.'pig-iron' 0.0, scrap.sponge 0.0, scrap.'steel-bof' 0.0/
    b(m,p) /'blast-furn'.'pig-iron' 1.0, openhearth.'steel-oh' 1.0, bof.'steel-bof' 1.0, 'direct-red'.sponge 1.0, 'elec-arc'.'steel-el' 1.0, 'direct-red'.'pig-iron' 0.0, 'direct-red'.'steel-oh' 0.0, 'direct-red'.'steel-el' 0.0, 'direct-red'.'steel-bof' 0.0, openhearth.'pig-iron' 0.0, openhearth.sponge 0.0, openhearth.'steel-el' 0.0, openhearth.'steel-bof' 0.0, bof.'pig-iron' 0.0, bof.sponge 0.0, bof.'steel-oh' 0.0, bof.'steel-el' 0.0, 'blast-furn'.sponge 0.0, 'blast-furn'.'steel-oh' 0.0, 'blast-furn'.'steel-el' 0.0, 'blast-furn'.'steel-bof' 0.0, 'elec-arc'.'pig-iron' 0.0, 'elec-arc'.sponge 0.0, 'elec-arc'.'steel-oh' 0.0, 'elec-arc'.'steel-bof' 0.0/
    k(m,i) /'blast-furn'.ahmsa 3.25, 'blast-furn'.fundidora 1.4, 'blast-furn'.sicartsa 1.1, openhearth.ahmsa 1.5, openhearth.fundidora 0.85, bof.ahmsa 2.07, bof.fundidora 1.5, bof.sicartsa 1.3, 'direct-red'.hylsa 0.98, 'direct-red'.hylsap 1.0, 'elec-arc'.hylsa 1.13, 'elec-arc'.hylsap 0.56, 'direct-red'.ahmsa 0.0, 'direct-red'.fundidora 0.0, 'direct-red'.sicartsa 0.0, openhearth.sicartsa 0.0, openhearth.hylsa 0.0, openhearth.hylsap 0.0, bof.hylsa 0.0, bof.hylsap 0.0, 'blast-furn'.hylsa 0.0, 'blast-furn'.hylsap 0.0, 'elec-arc'.ahmsa 0.0, 'elec-arc'.fundidora 0.0, 'elec-arc'.sicartsa 0.0/
    d(c,j)
    dd(j) /'mexico-df' 55.0, monterrey 30.0, guadalaja 15.0/
    rd(*,*) /ahmsa.'mexico-df' 1204.0, ahmsa.monterrey 218.0, ahmsa.guadalaja 1125.0, ahmsa.export 739.0, fundidora.'mexico-df' 1017.0, fundidora.guadalaja 1030.0, fundidora.export 521.0, sicartsa.'mexico-df' 819.0, sicartsa.monterrey 1305.0, sicartsa.guadalaja 704.0, hylsa.'mexico-df' 1017.0, hylsa.guadalaja 1030.0, hylsa.export 521.0, hylsap.'mexico-df' 185.0, hylsap.monterrey 1085.0, hylsap.guadalaja 760.0, hylsap.export 315.0, import.'mexico-df' 428.0, import.monterrey 521.0, import.guadalaja 300.0, fundidora.monterrey 0.0, hylsa.monterrey 0.0, import.export 0.0, sicartsa.export 0.0/
    muf(i,j)
    muv(j)
    mue(i)
    prices(c,*) /pellets.domestic 18.7, coke.domestic 52.17, 'nat-gas'.domestic 14.0, electric.domestic 24.0, scrap.domestic 105.0, steel.import 150.0, steel.export 140.0, 'nat-gas'.import 0.0, 'nat-gas'.export 0.0, coke.import 0.0, coke.export 0.0, pellets.import 0.0, pellets.export 0.0, steel.domestic 0.0, electric.import 0.0, electric.export 0.0, scrap.import 0.0, scrap.export 0.0/
    pd(c)
    pv(c)
    pe(c)
;

Scalars
    dt /5.209/
    rse /40.0/
    eb /1.0/
;

d("steel",j) = dt * (1 + rse / 100) * dd(j) / 100;
muf(i,j) = (2.48 + 0.0084 * rd(i,j))$rd(i,j);
muv(j) = (2.48 + 0.0084 * rd("import",j))$rd("import",j);
mue(i) = (2.48 + 0.0084 * rd(i,"export"))$rd(i,"export");
pd(c) = prices(c,"domestic");
pv(c) = prices(c,"import");
pe(c) = prices(c,"export");

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    phi
    phipsi
    philam
    phipi
    phieps
    nu_apsi
    nu_alam
    nu_api
    nu_aeps
;

Positive Variables
    z(p,i)
    x(c,i,j)
    u(c,i)
    v(c,j)
    e(c,i)
    lam_mbf(cf,i)
    lam_mbi(ci,i)
    lam_mbr(cr,i)
    lam_cc(m,i)
    lam_mr(cf,j)
    lam_me(cf)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables are set to 1.

z.l(p,i) = 1;
x.l(c,i,j) = 1;
u.l(c,i) = 1;
v.l(c,j) = 1;
e.l(c,i) = 1;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_e(c,i)
    stat_phieps
    stat_philam
    stat_phipi
    stat_phipsi
    stat_u(c,i)
    stat_v(c,j)
    stat_x(c,i,j)
    stat_z(p,i)
    comp_cc(m,i)
    comp_mbf(cf,i)
    comp_mbi(ci,i)
    comp_mbr(cr,i)
    comp_me(cf)
    comp_mr(cf,j)
    aeps
    alam
    api
    apsi
    obj
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_e(c,i)$(cf(c)).. (((-1) * mue(i)) * nu_alam)$(sameas(c, 'steel') and sameas(i, 'ahmsa')) + (((-1) * pe(c)) * nu_aeps)$(sameas(c, 'steel') and sameas(i, 'ahmsa')) + sum(cf, lam_mbf(cf,i)) + sum(cf, lam_me(cf)) =E= 0;
stat_phieps.. -1 + nu_aeps =E= 0;
stat_philam.. 1 + nu_alam =E= 0;
stat_phipi.. 1 + nu_api =E= 0;
stat_phipsi.. 1 + nu_apsi =E= 0;
stat_u(c,i)$(cr(c)).. (((-1) * pd(c)) * nu_apsi)$(sameas(c, 'coke') and sameas(i, 'ahmsa')) + sum(cr, (-1) * lam_mbr(cr,i)) =E= 0;
stat_v(c,j)$(cf(c)).. (((-1) * muv(j)) * nu_alam)$(sameas(c, 'steel') and sameas(j, 'guadalaja')) + (((-1) * pv(c)) * nu_api)$(sameas(c, 'steel') and sameas(j, 'guadalaja')) + sum(cf, (-1) * lam_mr(cf,j)) =E= 0;
stat_x(c,i,j)$(cf(c)).. (((-1) * muf(i,j)) * nu_alam)$(sameas(c, 'steel') and sameas(i, 'ahmsa') and sameas(j, 'guadalaja')) + sum(cf, lam_mbf(cf,i)) + sum(cf, (-1) * lam_mr(cf,j)) =E= 0;
stat_z(p,i).. sum(c, sum(cf, ((-1) * a(c,p)) * lam_mbf(cf,i))) + sum(c, sum(ci, ((-1) * a(c,p)) * lam_mbi(ci,i))) + sum(c, sum(cr, ((-1) * a(c,p)) * lam_mbr(cr,i))) + sum(m, b(m,p) * lam_cc(m,i)) =E= 0;

* Inequality complementarity equations
comp_cc(m,i).. ((-1) * (sum(p, b(m,p) * z(p,i)) - k(m,i))) =G= 0;
comp_mbf(cf,i).. sum(p, a(cf,p) * z(p,i)) - (sum(j, x(cf,i,j)) + e(cf,i)) =G= 0;
comp_mbi(ci,i).. sum(p, a(ci,p) * z(p,i)) =G= 0;
comp_mbr(cr,i).. sum(p, a(cr,p) * z(p,i)) + u(cr,i) =G= 0;
comp_me(cf).. ((-1) * (sum(i, e(cf,i)) - eb)) =G= 0;
comp_mr(cf,j).. sum(i, x(cf,i,j)) + v(cf,j) - d(cf,j) =G= 0;

* Original equality equations
obj.. phi =E= phipsi + philam + phipi - phieps;
apsi.. phipsi =E= sum((cr,i), pd(cr) * u(cr,i));
alam.. philam =E= sum((cf,i,j), muf(i,j) * x(cf,i,j)) + sum((cf,j), muv(j) * v(cf,j)) + sum((cf,i), mue(i) * e(cf,i));
api.. phipi =E= sum((cf,j), pv(cf) * v(cf,j));
aeps.. phieps =E= sum((cf,i), pe(cf) * e(cf,i));


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

e.fx(c,i)$(not (cf(c))) = 0;
u.fx(c,i)$(not (cr(c))) = 0;
v.fx(c,j)$(not (cf(c))) = 0;
x.fx(c,i,j)$(not (cf(c))) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_e.e,
    stat_phieps.phieps,
    stat_philam.philam,
    stat_phipi.phipi,
    stat_phipsi.phipsi,
    stat_u.u,
    stat_v.v,
    stat_x.x,
    stat_z.z,
    comp_cc.lam_cc,
    comp_mbf.lam_mbf,
    comp_mbi.lam_mbi,
    comp_mbr.lam_mbr,
    comp_me.lam_me,
    comp_mr.lam_mr,
    aeps.nu_aeps,
    alam.nu_alam,
    api.nu_api,
    apsi.nu_apsi,
    obj.phi
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = phi.l;
Display nlp2mcp_obj_val;