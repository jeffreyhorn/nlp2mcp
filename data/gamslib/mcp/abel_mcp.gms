$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    n /consumpt, invest/
    m /'gov-expend', money/
    k /'1964-i', '1964-ii', '1964-iii', '1964-iv', '1965-i', '1965-ii', '1965-iii', '1965-iv'/
    ku(k)
    ki(k)
    kt(k)
;

Alias(n, np);
Alias(m, mp);

Parameters
    a(n,np) /consumpt.consumpt 0.914, consumpt.invest -0.016, invest.consumpt 0.097, invest.invest 0.424/
    b(n,m) /consumpt.'gov-expend' 0.305, consumpt.money 0.424, invest.'gov-expend' -0.101, invest.money 1.459/
    wk(n,np) /consumpt.consumpt 0.0625, invest.invest 1.0, consumpt.invest 0.0, invest.consumpt 0.0/
    lambda(m,mp) /'gov-expend'.'gov-expend' 1.0, money.'gov-expend' 0.444, money.money 0.0, 'gov-expend'.money 0.0/
    c(n) /consumpt -59.4, invest -184.7/
    xinit(n) /consumpt 387.9, invest 85.3/
    uinit(m) /'gov-expend' 110.5, money 147.1/
    xtilde(n,k)
    utilde(m,k)
    w(n,np,k)
;

ku(k) = 1$(ord(k) < card(k));
ki(k) = 1$(ord(k) = 1);
kt(k) = (not ku(k));

xtilde(n,k) = xinit(n) * 1.0075 ** (ord(k) - 1);
utilde(m,k) = uinit(m) * 1.0075 ** (ord(k) - 1);
w(n,np,ku) = wk(n,np);
w(n,np,kt) = 100 * wk(n,np);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    x(n,k)
    u(m,k)
    j
    nu_stateq(n,k)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

x.l(n,k) = xinit(n);
u.l(m,k) = uinit(m);

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_u(m,k)
    stat_x(n,k)
    criterion
    stateq(n,k)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_u(m,k)$(ku(k)).. sum(n, ((-1) * b(n,m)) * nu_stateq(n,k)) =E= 0;
stat_x(n,k).. ((-1) * a(n,n)) * nu_stateq(n,k) =E= 0;

* Original equality equations
criterion.. j =E= 0.5 * sum((k,n,np), (x(n,k) - xtilde(n,k)) * w(n,np,k) * (x(np,k) - xtilde(np,k))) + 0.5 * sum((ku,m,mp), (u(m,ku) - utilde(m,ku)) * lambda(m,mp) * (u(mp,ku) - utilde(mp,ku)));
stateq(n,k)$(ord(k) <= card(k) - 1).. x(n,k+1) =E= sum(np, a(n,np) * x(np,k)) + sum(m, b(n,m) * u(m,k)) + c(n);


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

u.fx(m,k)$(not (ku(k))) = 0;
nu_stateq.fx(n,k)$(not (ord(k) <= card(k) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_u.u,
    stat_x.x,
    criterion.j,
    stateq.nu_stateq
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = j.l;
Display nlp2mcp_obj_val;