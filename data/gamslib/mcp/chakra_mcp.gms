$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    t /'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'/
    tb(t)
    tt(t)
;

Parameters
    dis(t)
    alpha(t)
;

Scalars
    delt /0.05/
    beta /0.75/
    a /0.0/
    r /0.025/
    eta /0.9/
    z /0.01/
    rho /0.03/
    y0 /4.275/
    k0 /15.0/
;

tb(t) = 1$(ord(t) = 1);
tt(t) = 1$(ord(t) = card(t));

a = y0 / k0 ** beta;
dis(t) = (1 + rho) ** (1 - ord(t)) / (1 - eta);
alpha(t) = a * (1 + r * (1 - beta) + z) ** (ord(t) - 1);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    c(t)
    y(t)
    k(t)
    j
    nu_yd(t)
    nu_kb(t)
;

Positive Variables
    piL_c(t)
    piL_y(t)
    piL_k(t)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

c.l(t) = y.l(t) + (1 - delt) * k.l(t) - k.l(t+1);
y.l(t) = y0 * 1.06 ** (ord(t) - 1);
k.l(t) = (y.l(t) / alpha(t)) ** (1 / beta);

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_c(t)
    stat_k(t)
    stat_y(t)
    comp_lo_c(t)
    comp_lo_k(t)
    comp_lo_y(t)
    jd
    kb(t)
    yd(t)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_c(t).. nu_kb(t) - piL_c(t) =E= 0;
stat_k(t).. ((-1) * (alpha(t) * k(t) ** beta * beta / k(t))) * nu_yd(t) + ((-1) * (1 - delt)) * nu_kb(t) - piL_k(t) =E= 0;
stat_y(t).. nu_yd(t) - nu_kb(t) - piL_y(t) =E= 0;

* Lower bound complementarity equations
comp_lo_c(t).. c(t) - 1 =G= 0;
comp_lo_k(t).. k(t) - 1 =G= 0;
comp_lo_y(t).. y(t) - 1 =G= 0;

* Original equality equations
jd.. j =E= sum(t, dis(t-1) * c(t-1) ** (1 - eta));
yd(t).. y(t) =E= alpha(t) * k(t) ** beta;
kb(t)$(ord(t) <= card(t) - 1).. k(t+1) =E= y(t) - c(t) + (1 - delt) * k(t);


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_kb.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_c.c,
    stat_k.k,
    stat_y.y,
    jd.j,
    kb.nu_kb,
    yd.nu_yd,
    comp_lo_c.piL_c,
    comp_lo_k.piL_k,
    comp_lo_y.piL_y
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = j.l;
Display nlp2mcp_obj_val;