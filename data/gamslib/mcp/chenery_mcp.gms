$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /'light-ind', 'food+agr', 'heavy-ind', services/
    t(i) /'light-ind', 'food+agr', 'heavy-ind'/
    lmh /low, medium, high/
    sde /subst, distr, effic/
;

Alias(i, j);

Parameters
    aio(i,i) /'food+agr'.'light-ind' 0.1, 'heavy-ind'.'light-ind' 0.2, 'heavy-ind'.'food+agr' 0.1, services.'light-ind' 0.2, services.'food+agr' 0.3, services.'heavy-ind' 0.1, 'heavy-ind'.'heavy-ind' 0.0, 'heavy-ind'.services 0.0, services.services 0.0, 'food+agr'.'food+agr' 0.0, 'food+agr'.'heavy-ind' 0.0, 'food+agr'.services 0.0/
    pdat(lmh,*,sde,i) /low.a.distr.'light-ind' 0.915, low.a.distr.'food+agr' 0.944, low.a.distr.'heavy-ind' 2.6, low.a.distr.services 0.8, low.a.effic.'light-ind' 3.83, low.a.effic.'food+agr' 3.24, low.a.effic.'heavy-ind' 4.0, low.a.effic.services 1.8, low.b.distr.'light-ind' 0.276, low.b.distr.'food+agr' 1.034, low.b.distr.'heavy-ind' 2.6, low.b.distr.services 0.77, low.b.effic.'light-ind' 2.551, low.b.effic.'food+agr' 3.39, low.b.effic.'heavy-ind' 4.0, low.b.effic.services 1.77, medium.a.subst.'light-ind' 0.11, medium.a.subst.'food+agr' 0.29, medium.a.subst.'heavy-ind' 0.2, medium.a.subst.services 0.05, medium.a.distr.'light-ind' 0.326, medium.a.distr.'food+agr' 0.443, medium.a.distr.'heavy-ind' 0.991, medium.a.distr.services 0.00798, medium.a.effic.'light-ind' 3.97, medium.a.effic.'food+agr' 3.33, medium.a.effic.'heavy-ind' 1.67, medium.a.effic.services 1.84, medium.b.subst.'light-ind' 0.22, medium.b.subst.'food+agr' 0.58, medium.b.subst.'heavy-ind' 0.4, medium.b.subst.services 0.1, medium.b.distr.'light-ind' 0.41, medium.b.distr.'food+agr' 0.47, medium.b.distr.'heavy-ind' 0.92, medium.b.distr.services 0.08, medium.b.effic.'light-ind' 3.99, medium.b.effic.'food+agr' 3.33, medium.b.effic.'heavy-ind' 1.8, medium.b.effic.services 1.89, high.a.subst.'light-ind' 0.45, high.a.subst.'food+agr' 1.15, high.a.subst.'heavy-ind' 0.4, high.a.subst.services 0.2, high.a.distr.'light-ind' 0.456, high.a.distr.'food+agr' 0.483, high.a.distr.'heavy-ind' 0.917, high.a.distr.services 0.23, high.a.effic.'light-ind' 4.0, high.a.effic.'food+agr' 3.33, high.a.effic.'heavy-ind' 1.8, high.a.effic.services 1.92, high.b.subst.'light-ind' 0.93, high.b.subst.'food+agr' 1.15, high.b.subst.'heavy-ind' 0.8, high.b.subst.services 0.4, high.b.distr.'light-ind' 0.484, high.b.distr.'food+agr' 0.483, high.b.distr.'heavy-ind' 0.769, high.b.distr.services 0.344, high.b.effic.'light-ind' 4.0, high.b.effic.'food+agr' 3.33, high.b.effic.'heavy-ind' 1.96, high.b.effic.services 1.96/
    ddat(lmh,*,i) /low.ynot.'light-ind' 100.0, low.ynot.'food+agr' 230.0, low.ynot.'heavy-ind' 220.0, low.ynot.services 450.0, medium.ynot.'light-ind' 100.0, medium.ynot.'food+agr' 230.0, medium.ynot.'heavy-ind' 220.0, medium.ynot.services 450.0, high.ynot.'light-ind' 100.0, high.ynot.'food+agr' 230.0, high.ynot.'heavy-ind' 220.0, high.ynot.services 450.0, medium.'p-elas'.'light-ind' -0.674, medium.'p-elas'.'food+agr' -0.246, medium.'p-elas'.'heavy-ind' -0.587, medium.'p-elas'.services -0.352, high.'p-elas'.'light-ind' -1.0, high.'p-elas'.'food+agr' -1.0, high.'p-elas'.'heavy-ind' -1.0, high.'p-elas'.services -1.0/
    tdat(lmh,*,t) /medium.alp.'light-ind' 0.005, medium.alp.'food+agr' 0.001, medium.alp.'heavy-ind' 0.01, high.alp.'light-ind' 0.0025, high.alp.'food+agr' 0.0005, high.alp.'heavy-ind' 0.00178, medium.gam.'light-ind' 1.0, medium.gam.'food+agr' 1.1, medium.gam.'heavy-ind' 1.0, high.gam.'light-ind' 1.0, high.gam.'food+agr' 1.1, high.gam.'heavy-ind' 1.0, medium.xsi.'light-ind' 0.005, medium.xsi.'food+agr' 0.0157, medium.xsi.'heavy-ind' 0.00178, high.xsi.'light-ind' 0.005, high.xsi.'food+agr' 0.0157, high.xsi.'heavy-ind' 0.00178/
    mew(t) /'light-ind' 1.0, 'food+agr' 1.0, 'heavy-ind' 1.0/
    xsi(t)
    gam(t)
    alp(t)
    ynot(i)
    sig(i)
    thet(i)
    rho(i)
    del(i)
    efy(i)
;

Scalars
    lbar /750.0/
    plab /1.0/
    kbar /500.0/
    dbar /0.0/
    cva /0.0/
    rva /0.0/
    fve /0.0/
    emp /0.0/
    cli /0.0/
;

xsi(t) = tdat("medium","xsi",t);
gam(t) = tdat("medium","gam",t);
alp(t) = tdat("medium","alp",t);
ynot(i) = ddat("medium","ynot",i);
sig(i) = pdat("medium","a","subst",i);
thet(i) = ddat("medium","p-elas",i);
rho(i) = 1 / sig(i) - 1;
del(i) = pdat("medium","a","distr",i);
efy(i) = pdat("medium","a","effic",i);
rva = cva / cli;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    pk
    pi
    pd
    td
    vv(i)
    nu_dg(t)
    nu_dh(t)
    nu_dem(i)
    nu_kc
    nu_sup(i)
    nu_fpr
    nu_dvv(i)
    nu_dl(i)
    nu_dk(i)
    nu_dv(i)
;

Positive Variables
    x(i)
    v(i)
    y(i)
    p(i)
    l(i)
    k(i)
    e(i)
    m(i)
    g(t)
    h(t)
    lam_mb(i)
    lam_tb
    lam_lc
    piL_p(i)
    piL_pk
    piL_pi
    piL_pd
    piL_vv(i)
    piU_x(i)
    piU_v(i)
    piU_y(i)
    piU_p(i)
    piU_l(i)
    piU_k(i)
    piU_e(i)
    piU_m(i)
    piU_g(t)
    piU_h(t)
    piU_pk
    piU_pi
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1.

x.l("light-ind") = 200.0;
x.l("food+agr") = 200.0;
x.l("heavy-ind") = 200.0;
x.l("services") = 200.0;
x.l(i) = min(max(x.l(i), 1e-6), x.up(i));
v.l(i) = 1;
y.l("light-ind") = 250.0;
y.l("food+agr") = 250.0;
y.l("heavy-ind") = 250.0;
y.l("services") = 250.0;
y.l(i) = min(max(y.l(i), 1e-6), y.up(i));
p.l("light-ind") = 3.0;
p.l("food+agr") = 3.0;
p.l("heavy-ind") = 3.0;
p.l("services") = 3.0;
p.l(i) = min(max(p.l(i), 1e-6), p.up(i));
l.l(i) = 1;
k.l(i) = 1;
e.l("light-ind") = 0.0;
e.l("food+agr") = 0.0;
e.l("heavy-ind") = 0.0;
e.l("services") = 0.0;
e.l(i) = min(max(e.l(i), 1e-6), e.up(i));
m.l("light-ind") = 0.0;
m.l("food+agr") = 0.0;
m.l("heavy-ind") = 0.0;
m.l("services") = 0.0;
m.l(i) = min(max(m.l(i), 1e-6), m.up(i));
g.l(t) = 1;
h.l(t) = 1;
pk.l = 3.5;
pi.l = 0.25;
pd.l = 0.3;
vv.l("light-ind") = 0.001;
vv.l("food+agr") = 0.001;
vv.l("heavy-ind") = 0.001;
vv.l("services") = 0.001;

* ============================================
* Post-solve Calibration (variable .l references)
* ============================================

$onImplicitAssign
cva = sum(i, v.l(i) * x.l(i));
fve = sum(t, e.l(t) * h.l(t));
emp = sum(i, l.l(i) * x.l(i));
cli = sum(i, p.l(i) * ynot(i)) / sum(i, ynot(i));
$offImplicitAssign

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_e(i)
    stat_g(t)
    stat_h(t)
    stat_k(i)
    stat_l(i)
    stat_m(i)
    stat_p(i)
    stat_pd
    stat_pi
    stat_pk
    stat_v(i)
    stat_vv(i)
    stat_x(i)
    stat_y(i)
    comp_lc
    comp_mb(i)
    comp_tb
    comp_lo_p(i)
    comp_lo_pd
    comp_lo_pi
    comp_lo_pk
    comp_lo_vv(i)
    comp_up_e(i)
    comp_up_g(t)
    comp_up_h(t)
    comp_up_k(i)
    comp_up_l(i)
    comp_up_m(i)
    comp_up_p(i)
    comp_up_pi
    comp_up_pk
    comp_up_v(i)
    comp_up_x(i)
    comp_up_y(i)
    dem(i)
    dg(t)
    dh(t)
    dk(i)
    dl(i)
    dty
    dv(i)
    dvv(i)
    fpr
    kc
    sup(i)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_e(i).. sum(t, alp(t) * nu_dh(t)) + sum(t, ((-1) * h(t)) * lam_tb) + piU_e(i) =E= 0;
stat_g(t).. nu_dg(t) + m(t) * lam_tb + piU_g(t) =E= 0;
stat_h(t).. nu_dh(t) + ((-1) * e(t)) * lam_tb + piU_h(t) =E= 0;
stat_k(i).. x(i) * nu_kc + efy(i) * nu_dk(i) + ((-1) * pk) * nu_dv(i) + piU_k(i) =E= 0;
stat_l(i).. efy(i) * nu_dl(i) + ((-1) * plab) * nu_dv(i) + x(i) * lam_lc + piU_l(i) =E= 0;
stat_m(i).. sum(t, ((-1) * xsi(t)) * nu_dg(t)) + sum(t, g(t) * lam_tb) + piU_m(i) =E= 0;
stat_p(i).. ((-1) * (ynot(i) * (pd * p(i)) ** thet(i) * thet(i) / (pd * p(i)) * pd)) * nu_dem(i) + (1 - aio(i,i)) * nu_sup(i) - piL_p(i) + piU_p(i) =E= 0;
stat_pd.. sum(i, ((-1) * (ynot(i) * (pd * p(i)) ** thet(i) * thet(i) / (pd * p(i)) * p(i))) * nu_dem(i)) - piL_pd =E= 0;
stat_pi.. nu_fpr + sum(i$(sig(i) <> 0), ((-1) * ((pi * (1 - del(i)) / del(i)) ** (((-1) * rho(i)) / (1 + rho(i))) * ((-1) * rho(i)) / (1 + rho(i)) / (pi * (1 - del(i)) / del(i)) * del(i) * (1 - del(i)) / del(i) ** 2)) * nu_dvv(i)) - piL_pi + piU_pi =E= 0;
stat_pk.. ((-1) * (1 / plab ** 1)) * nu_fpr + sum(i, ((-1) * k(i)) * nu_dv(i)) - piL_pk + piU_pk =E= 0;
stat_v(i).. ((-1) * nu_sup(i)) + nu_dv(i) + piU_v(i) =E= 0;
stat_vv(i).. nu_dvv(i) - piL_vv(i) =E= 0;
stat_x(i).. k(i) * nu_kc + (aio(i,i) - 1) * lam_mb(i) + l(i) * lam_lc + piU_x(i) =E= 0;
stat_y(i).. -1 + nu_dem(i) + lam_mb(i) + piU_y(i) =E= 0;

* Inequality complementarity equations
comp_lc.. ((-1) * (sum(i, l(i) * x(i)) - lbar)) =G= 0;
comp_mb(i).. x(i) - (y(i) + sum(j, aio(i,j) * x(j)) + (e(i) - m(i))$t(i)) =G= 0;
comp_tb.. ((-1) * (sum(t, g(t) * m(t) - h(t) * e(t)) - dbar)) =G= 0;

* Lower bound complementarity equations
comp_lo_p(i).. p(i) - 0.1 =G= 0;
comp_lo_pd.. pd - 0.01 =G= 0;
comp_lo_pi.. pi - 0.25 =G= 0;
comp_lo_pk.. pk - 0.25 =G= 0;
comp_lo_vv(i).. vv(i) - 0.001 =G= 0;

* Upper bound complementarity equations
comp_up_e(i).. 400 - e(i) =G= 0;
comp_up_g(t).. 4 - g(t) =G= 0;
comp_up_h(t).. 4 - h(t) =G= 0;
comp_up_k(i).. 1 - k(i) =G= 0;
comp_up_l(i).. 1 - l(i) =G= 0;
comp_up_m(i).. 400 - m(i) =G= 0;
comp_up_p(i).. 100 - p(i) =G= 0;
comp_up_pi.. 4 - pi =G= 0;
comp_up_pk.. 4 - pk =G= 0;
comp_up_v(i).. 100 - v(i) =G= 0;
comp_up_x(i).. 2000 - x(i) =G= 0;
comp_up_y(i).. 2000 - y(i) =G= 0;

* Original equality equations
dty.. td =E= sum(i, y(i));
dg(t).. g(t) =E= mew(t) + xsi(t) * m(t);
dh(t).. h(t) =E= gam(t) - alp(t) * e(t);
dem(i).. y(i) =E= ynot(i) * (pd * p(i)) ** thet(i);
kc.. sum(i, k(i) * x(i)) =E= kbar;
sup(i).. p(i) =E= sum(j, aio(j,i) * p(j)) + v(i);
fpr.. pi =E= pk / plab;
dvv(i)$(sig(i) <> 0).. vv(i) =E= (pi * (1 - del(i)) / del(i)) ** (((-1) * rho(i)) / (1 + rho(i)));
dl(i).. l(i) * efy(i) =E= ((del(i) / vv(i) + 1 - del(i)) ** (1 / rho(i)))$(sig(i) <> 0) + 1$(sig(i) = 0);
dk(i).. k(i) * efy(i) =E= ((del(i) + (1 - del(i)) * vv(i)) ** (1 / rho(i)))$(sig(i) <> 0) + del(i)$(sig(i) = 0);
dv(i).. v(i) =E= pk * k(i) + plab * l(i);


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_dvv.fx(i)$(not (sig(i) <> 0)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_e.e,
    stat_g.g,
    stat_h.h,
    stat_k.k,
    stat_l.l,
    stat_m.m,
    stat_p.p,
    stat_pd.pd,
    stat_pi.pi,
    stat_pk.pk,
    stat_v.v,
    stat_vv.vv,
    stat_x.x,
    stat_y.y,
    comp_lc.lam_lc,
    comp_mb.lam_mb,
    comp_tb.lam_tb,
    dem.nu_dem,
    dg.nu_dg,
    dh.nu_dh,
    dk.nu_dk,
    dl.nu_dl,
    dty.td,
    dv.nu_dv,
    dvv.nu_dvv,
    fpr.nu_fpr,
    kc.nu_kc,
    sup.nu_sup,
    comp_lo_p.piL_p,
    comp_lo_pd.piL_pd,
    comp_lo_pi.piL_pi,
    comp_lo_pk.piL_pk,
    comp_lo_vv.piL_vv,
    comp_up_e.piU_e,
    comp_up_g.piU_g,
    comp_up_h.piU_h,
    comp_up_k.piU_k,
    comp_up_l.piU_l,
    comp_up_m.piU_m,
    comp_up_p.piU_p,
    comp_up_pi.piU_pi,
    comp_up_pk.piU_pk,
    comp_up_v.piU_v,
    comp_up_x.piU_x,
    comp_up_y.piU_y
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;