$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    n /one, two, three, four, five, six/
    l(n) /one, two, three/
    iter /iter1, iter2, iter3, iter4, iter5, iter6, iter7, iter8, iter9, iter10, iter11, iter12, iter13, iter14, iter15, iter16, iter17, iter18, iter19, iter20/
;

Alias(l, lp);
Alias(n, np);

Sets
    arc(n,np)
;

Parameters
    coefs(l,*) /one.alpha 1.0, one.beta 0.5, one.rho 19.0, one.eta 0.2, two.alpha 2.0, two.beta 0.4, two.rho 27.0, two.eta 0.01, three.alpha 1.5, three.beta 0.3, three.rho 30.0, three.eta 0.3/
    pairs(n,np,*) /one.four.kappa 1.0, one.four.nu 0.5, one.five.kappa 2.0, one.five.nu 0.2, two.six.kappa 3.0, two.six.nu 0.3, three.six.kappa 1.0, three.six.nu 0.4, four.one.kappa 2.0, four.one.nu 0.3, four.five.kappa 1.0, four.five.nu 0.1, four.six.kappa 1.0, four.six.nu 0.1, five.one.kappa 3.0, five.one.nu 0.5, five.four.kappa 2.0, five.four.nu 0.2, five.six.kappa 1.0, five.six.nu 1.0, six.two.kappa 2.0, six.two.nu 0.25, six.three.kappa 2.0, six.three.nu 0.2, six.four.kappa 1.0, six.four.nu 0.9, six.five.kappa 3.0, six.five.nu 0.8/
    irep(iter,n,np)
;

Scalars
    pm /1.0/
    tm /1.0/
    objold /0.0/
;

arc(n,np) = pairs(n,np,"kappa");

tm = 1 / 3;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    tt(l,lp)
    obj
    nu_bal
    nu_sbal(l)
    nu_dbal(l)
    nu_in(l)
    nu_objoli
;

Positive Variables
    t(n,np)
    d(n)
    s(n)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1.

t.l(n,np) = 1;
tt.l("one","one") = 1.0;
tt.l("one","two") = 1.0;
tt.l("one","three") = 1.0;
tt.l("two","one") = 1.0;
tt.l("two","two") = 1.0;
tt.l("two","three") = 1.0;
tt.l("three","one") = 1.0;
tt.l("three","two") = 1.0;
tt.l("three","three") = 1.0;
d.l("one") = 25.0;
d.l("two") = 25.0;
d.l("three") = 25.0;
d.l("four") = 25.0;
d.l("five") = 25.0;
d.l("six") = 25.0;
d.l(n) = min(max(d.l(n), 1e-6), d.up(n));
s.l("one") = 25.0;
s.l("two") = 25.0;
s.l("three") = 25.0;
s.l("four") = 25.0;
s.l("five") = 25.0;
s.l("six") = 25.0;
s.l(n) = min(max(s.l(n), 1e-6), s.up(n));

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_d(n)
    stat_s(n)
    stat_t(n,np)
    stat_tt(l,lp)
    bal
    dbal(l)
    in(l)
    objdef
    objoli
    sbal(l)
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(l, l__);

* Stationarity equations
stat_d(n).. nu_bal$sameas(n, 'one') + sum(l, nu_dbal(l)) + sum(l, nu_in(l)) + sum(l, ((-1) * (coefs(l,"rho") - pm * coefs(l,"eta") * sum(lp, tt(l,lp)))) * nu_objoli)$sameas(n, 'one') =E= 0;
stat_s(n).. ((-1) * nu_bal)$sameas(n, 'one') + sum(l, nu_sbal(l)) + sum(l, (coefs(l,"alpha") + 2 * coefs(l,"beta") * s(n)) * nu_objoli)$sameas(n, 'one') =E= 0;
stat_t(n,np).. sum(l, (-1) * nu_in(l)) =E= 0;
stat_tt(l,lp).. ((-1) * nu_dbal(l)) - nu_in(l) =E= 0;

* Original equality equations
bal.. sum(l, d(l)) =E= sum(l, s(l));
objdef.. obj =E= sum(l, coefs(l,"rho") * d(l) - pm * coefs(l,"eta") * sqr(d(l))) - sum(l, coefs(l,"alpha") * s(l) + coefs(l,"beta") * sqr(s(l))) - sum(arc, pairs(n,np,"kappa") * t(n,np) + tm * pairs(n,np,"nu") * power(t(n,np), 3));
sbal(l).. s(l) =E= sum(lp, tt(l,lp));
dbal(l).. d(l) =E= sum(lp, tt(lp,l));
in(l).. d(l) =E= tt(l,l) + sum((n,l__), t(n,l__));
objoli.. obj =E= sum(l, coefs(l,"rho") * d(l) - pm * coefs(l,"eta") * sum(lp, (d.l(l) - tt.l(lp,l) + tt(lp,l)) * tt(lp,l))) - sum(l, coefs(l,"alpha") * s(l) + coefs(l,"beta") * sqr(s(l))) - sum(arc, pairs(n,np,"kappa") * t(n,np) + tm * pairs(n,np,"nu") * power(t(n,np), 3));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_d.d,
    stat_s.s,
    stat_t.t,
    stat_tt.tt,
    bal.nu_bal,
    dbal.nu_dbal,
    in.nu_in,
    objdef.obj,
    objoli.nu_objoli,
    sbal.nu_sbal
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = obj.l;
Display nlp2mcp_obj_val;