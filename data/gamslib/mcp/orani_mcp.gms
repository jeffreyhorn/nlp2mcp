$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    c /food, clothing/
    ca(c) /food/
    cm(c) /clothing/
    f /labor, capital/
    h /families/
    i /agric, manuf/
    s /domestic, imported/
    ce(c,c)
;

Alias(c, cp);
Alias(s, sp);
Alias(i, ip);

Parameters
    amc(c,s,*) /food.domestic.agric 10.0, food.domestic.manuf 8.0, food.domestic.families 17.0, food.domestic.exp 19.0, clothing.domestic.agric 15.0, clothing.domestic.manuf 1.0, clothing.domestic.families 34.0, clothing.domestic.exp 1.0, food.imported.agric 1.0, food.imported.manuf 8.0, food.imported.families 1.0, food.imported.duty -1.0, clothing.imported.agric 5.0, clothing.imported.manuf 2.0, clothing.imported.families 10.0, clothing.imported.duty -5.0, food.domestic.duty 0.0, food.imported.exp 0.0, clothing.domestic.duty 0.0, clothing.imported.exp 0.0/
    amf(f,i) /labor.agric 20.0, labor.manuf 20.0, capital.agric 10.0, capital.manuf 5.0/
    amq(c,i) /food.agric 45.0, food.manuf 9.0, clothing.agric 16.0, clothing.manuf 35.0/
    epsilon(c,s) /food.domestic 1.0, food.imported 1.0, clothing.domestic 1.0, clothing.imported 1.0/
    amt(i)
    gamma(c) /food 0.5, clothing 0.05/
    wl(i) /agric 0.5, manuf 0.5/
    alpha(c,s,i)
    alphak(i)
    alphal(i)
    alphae(c,s)
    etabar(c,s,cp,sp) /food.domestic.food.domestic 0.0, food.domestic.food.imported 0.0, food.domestic.clothing.domestic 0.0, food.domestic.clothing.imported 0.0, food.imported.food.domestic 0.0, food.imported.food.imported 0.0, food.imported.clothing.domestic 0.0, food.imported.clothing.imported 0.0, clothing.domestic.food.domestic 0.0, clothing.domestic.food.imported 0.0, clothing.domestic.clothing.domestic 0.0, clothing.domestic.clothing.imported 0.0, clothing.imported.food.domestic 0.0, clothing.imported.food.imported 0.0, clothing.imported.clothing.domestic 0.0, clothing.imported.clothing.imported 0.0/
    sb(c,s)
    eta(c,s,cp,sp)
    m(c,i)
    mu(c,s)
    nm(c)
    nx(c)
    r(c,i)
    sc(c,s,i)
    sk(i)
    sl(i)
    wc(c,s)
    we(c)
    wi(c,s,i)
    varcomm(c,*)
    varindus(i,*)
;

Scalars
    theta /1.0/
    elevel /0.0/
    mlevel /0.0/
;

ce(c,c) = 1;

amc(c,s,"total") = sum(i, amc(c,s,i)) + amc(c,s,"families") + amc(c,s,"exp") + amc(c,s,"duty");
amt(i) = sum((c,s), amc(c,s,i)) + sum(f, amf(f,i));
alpha(c,s,i) = amc(c,s,i) / sum(sp, amc(c,sp,i));
alphak(i) = amf("capital",i) / sum(f, amf(f,i));
alphal(i) = amf("labor",i) / sum(f, amf(f,i));
alphae(c,s) = amc(c,s,"families") / sum(sp, amc(c,sp,"families"));
etabar(c,s,cp,sp) = alphae(cp,sp);
etabar(c,s,c,s) = -1 + alphae(c,s);
sb(c,s) = amc(c,s,"families") / sum((cp,sp), amc(cp,sp,"families"));
eta(c,s,cp,sp) = ((-1) * epsilon(c,s)) * sb(cp,sp) + etabar(c,s,cp,sp);
elevel = sum((c,s), amc(c,s,"exp"));
m(c,i) = amq(c,i) / sum(ip, amq(c,ip));
mlevel = sum(c, amc(c,"imported","total"));
mu(c,s) = sb(c,s);
nm(c) = amc(c,"imported","total") / sum(cp, amc(cp,"imported","total"));
nx(c) = amc(c,"domestic","exp") / sum(cp, amc(cp,"domestic","exp"));
r(c,i) = amq(c,i) / sum(cp, amq(cp,i));
sc(c,s,i) = amc(c,s,i) / amt(i);
sk(i) = amf("capital",i) / amt(i);
sl(i) = amf("labor",i) / amt(i);
wc(c,s) = amc(c,s,"families") / (amc(c,s,"total") - amc(c,s,"duty"));
we(c) = amc(c,"domestic","exp") / amc(c,"domestic","total");
wi(c,s,i) = amc(c,s,i) / (amc(c,s,"total") - amc(c,s,"duty"));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    b
    cn(c,s)
    cr
    df(c)
    e(c)
    et
    k(i)
    kappa(i)
    l
    li(i)
    mt
    p(c,s)
    pc
    phi
    pk(i)
    px(c)
    pm(c)
    q(c,i)
    t(c)
    v(c)
    w
    ws
    x(c,s,i)
    ye
    z(i)
    nu_con(c,s)
    nu_expd(c)
    nu_supply(c,i)
    nu_indc(c,s,i)
    nu_indcap(i)
    nu_indlab(i)
    nu_pric(i)
    nu_priexp(c)
    nu_priimp(c)
    nu_bald(c)
    nu_ballab
    nu_balcap(i)
    nu_imports
    nu_exports
    nu_baltrade
    nu_wage
    nu_realc
    nu_df_fx_food
    nu_df_fx_clothing
    nu_e_fx_food
    nu_e_fx_clothing
    nu_kappa_fx_agric
    nu_kappa_fx_manuf
    nu_phi_fx
    nu_pm_fx_food
    nu_pm_fx_clothing
    nu_t_fx_food
    nu_t_fx_clothing
    nu_v_fx_food
    nu_v_fx_clothing
    nu_ws_fx
    nu_ye_fx
;

* ============================================
* Post-solve Calibration (variable .l references)
* ============================================

$onImplicitAssign
varcomm(c,"t") = t.l(c);
varcomm(c,"v") = v.l(c);
varcomm(c,"df") = df.l(c);
varcomm(c,"e") = e.l(c);
varcomm(c,"px") = px.l(c);
varcomm(c,"pm") = pm.l(c);
varindus(i,"k") = k.l(i);
varindus(i,"li") = li.l(i);
varindus(i,"pk") = pk.l(i);
varindus(i,"z") = z.l(i);
varindus(i,"kappa") = kappa.l(i);
$offImplicitAssign

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_b
    stat_cn(c,s)
    stat_cr
    stat_df(c)
    stat_e(c)
    stat_et
    stat_k(i)
    stat_kappa(i)
    stat_l
    stat_li(i)
    stat_mt
    stat_p(c,s)
    stat_phi
    stat_pk(i)
    stat_pm(c)
    stat_px(c)
    stat_q(c,i)
    stat_t(c)
    stat_v(c)
    stat_w
    stat_ws
    stat_x(c,s,i)
    stat_ye
    stat_z(i)
    balcap(i)
    bald(c)
    ballab
    baltrade
    con(c,s)
    cpi
    df_fx_clothing
    df_fx_food
    e_fx_clothing
    e_fx_food
    expd(c)
    exports
    imports
    indc(c,s,i)
    indcap(i)
    indlab(i)
    kappa_fx_agric
    kappa_fx_manuf
    phi_fx
    pm_fx_clothing
    pm_fx_food
    pric(i)
    priexp(c)
    priimp(c)
    realc
    supply(c,i)
    t_fx_clothing
    t_fx_food
    v_fx_clothing
    v_fx_food
    wage
    ws_fx
    ye_fx
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_b.. nu_baltrade =E= 0;
stat_cn(c,s).. nu_con(c,s) =E= 0;
stat_cr.. nu_realc =E= 0;
stat_df(c).. ((-1) * nu_expd(c)) + nu_df_fx_clothing$sameas(c, 'clothing') + nu_df_fx_food$sameas(c, 'food') =E= 0;
stat_e(c).. gamma(c) * nu_expd(c) + ((-1) * we(c)) * nu_bald(c) + ((-1) * nx(c)) * nu_exports + nu_e_fx_clothing$sameas(c, 'clothing') + nu_e_fx_food$sameas(c, 'food') =E= 0;
stat_et.. nu_exports + ((-1) * (100 * elevel / 10000)) * nu_baltrade =E= 0;
stat_k(i).. nu_indcap(i) + nu_balcap(i) =E= 0;
stat_kappa(i).. ((-1) * nu_balcap(i)) + nu_kappa_fx_agric$sameas(i, 'agric') + nu_kappa_fx_manuf$sameas(i, 'manuf') =E= 0;
stat_l.. (-1) * nu_ballab =E= 0;
stat_li(i).. nu_indlab(i) + wl(i) * nu_ballab =E= 0;
stat_mt.. nu_imports + ((-1) * (100 * ((-1) * mlevel) / 10000)) * nu_baltrade =E= 0;
stat_p(c,s).. mu(c,s) + ((-1) * eta(c,s,c,s)) * nu_con(c,s) + sum(i, (1 - alpha(c,s,i)) * nu_indc(c,s,i)) + sum(i, ((-1) * sc(c,s,i)) * nu_pric(i)) =E= 0;
stat_phi.. sum(c, (-1) * nu_priexp(c)) + sum(c, (-1) * nu_priimp(c)) + nu_phi_fx =E= 0;
stat_pk(i).. (1 - alphak(i)) * nu_indcap(i) + ((-1) * alphak(i)) * nu_indlab(i) + ((-1) * sk(i)) * nu_pric(i) =E= 0;
stat_pm(c).. ((-1) * nu_priimp(c)) + ((-1) * nm(c)) * nu_imports + nu_pm_fx_clothing$sameas(c, 'clothing') + nu_pm_fx_food$sameas(c, 'food') =E= 0;
stat_px(c).. nu_expd(c) - nu_priexp(c) + ((-1) * nx(c)) * nu_exports =E= 0;
stat_q(c,i).. nu_supply(c,i) + m(c,i) * nu_bald(c) =E= 0;
stat_t(c).. ((-1) * nu_priimp(c)) + nu_t_fx_clothing$sameas(c, 'clothing') + nu_t_fx_food$sameas(c, 'food') =E= 0;
stat_v(c).. ((-1) * nu_priexp(c)) + nu_v_fx_clothing$sameas(c, 'clothing') + nu_v_fx_food$sameas(c, 'food') =E= 0;
stat_w.. sum(i, ((-1) * alphal(i)) * nu_indcap(i)) + sum(i, (1 - alphal(i)) * nu_indlab(i)) + sum(i, ((-1) * sl(i)) * nu_pric(i)) + nu_wage =E= 0;
stat_ws.. ((-1) * nu_wage) + nu_ws_fx =E= 0;
stat_x(c,s,i).. nu_indc(c,s,i) =E= 0;
stat_ye.. sum((c,s), ((-1) * epsilon(c,s)) * nu_con(c,s)) - nu_realc + nu_ye_fx =E= 0;
stat_z(i).. sum(c, (-1) * nu_supply(c,i)) + sum((c,s), (-1) * nu_indc(c,s,i)) - nu_indcap(i) - nu_indlab(i) =E= 0;

* Inequality complementarity equations

* Original equality equations
con(c,s).. cn(c,s) =E= epsilon(c,s) * ye + sum((cp,sp), eta(c,s,cp,sp) * p(cp,sp));
expd(c).. px(c) =E= ((-1) * (gamma(c))) * e(c) + df(c);
supply(c,i).. q(c,i) =E= z(i) + p(c,"domestic") - sum(cp, r(cp,i) * p(cp,"domestic"));
indc(c,s,i).. x(c,s,i) =E= z(i) - (p(c,s) - sum(sp, alpha(c,sp,i) * p(c,sp)));
indcap(i).. k(i) =E= z(i) - (pk(i) - alphal(i) * w - alphak(i) * pk(i));
indlab(i).. li(i) =E= z(i) - (w - alphal(i) * w - alphak(i) * pk(i));
pric(i).. sum(c, r(c,i) * p(c,"domestic")) =E= sum((c,sp), sc(c,sp,i) * p(c,sp)) + sk(i) * pk(i) + sl(i) * w;
priexp(c).. p(c,"domestic") =E= px(c) + v(c) + phi;
priimp(c).. p(c,"imported") =E= pm(c) + t(c) + phi;
bald(c).. sum(i, m(c,i) * q(c,i)) =E= sum(i, wi(c,"domestic",i) * x(c,"domestic",i)) + wc(c,"domestic") * cn(c,"domestic") + we(c) * e(c);
ballab.. sum(i, wl(i) * li(i)) =E= l;
balcap(i).. k(i) =E= kappa(i);
imports.. mt =E= sum(c, nm(c) * (pm(c) + sum(i, wi(c,"imported",i) * x(c,"imported",i)) + wc(c,"imported") * cn(c,"imported")));
exports.. et =E= sum(c, nx(c) * px(c) + nx(c) * e(c));
baltrade.. b =E= (elevel * et - mlevel * mt) / 100;
cpi.. pc =E= sum((c,s), mu(c,s) * p(c,s));
wage.. w =E= theta * pc + ws;
realc.. cr =E= ye - pc;
df_fx_food.. df("food") - 1 =E= 0;
df_fx_clothing.. df("clothing") - 1 =E= 0;
e_fx_food.. e("food") - 1 =E= 0;
e_fx_clothing.. e("clothing") - 1 =E= 0;
kappa_fx_agric.. kappa("agric") - 3 =E= 0;
kappa_fx_manuf.. kappa("manuf") - 3 =E= 0;
phi_fx.. phi - 0 =E= 0;
pm_fx_food.. pm("food") + 2 =E= 0;
pm_fx_clothing.. pm("clothing") + 2 =E= 0;
t_fx_food.. t("food") - 0 =E= 0;
t_fx_clothing.. t("clothing") - 0 =E= 0;
v_fx_food.. v("food") - 0 =E= 0;
v_fx_clothing.. v("clothing") - 0 =E= 0;
ws_fx.. ws - 0 =E= 0;
ye_fx.. ye - 2 =E= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_b.b,
    stat_cn.cn,
    stat_cr.cr,
    stat_df.df,
    stat_e.e,
    stat_et.et,
    stat_k.k,
    stat_kappa.kappa,
    stat_l.l,
    stat_li.li,
    stat_mt.mt,
    stat_p.p,
    stat_phi.phi,
    stat_pk.pk,
    stat_pm.pm,
    stat_px.px,
    stat_q.q,
    stat_t.t,
    stat_v.v,
    stat_w.w,
    stat_ws.ws,
    stat_x.x,
    stat_ye.ye,
    stat_z.z,
    balcap.nu_balcap,
    bald.nu_bald,
    ballab.nu_ballab,
    baltrade.nu_baltrade,
    con.nu_con,
    cpi.pc,
    df_fx_clothing.nu_df_fx_clothing,
    df_fx_food.nu_df_fx_food,
    e_fx_clothing.nu_e_fx_clothing,
    e_fx_food.nu_e_fx_food,
    expd.nu_expd,
    exports.nu_exports,
    imports.nu_imports,
    indc.nu_indc,
    indcap.nu_indcap,
    indlab.nu_indlab,
    kappa_fx_agric.nu_kappa_fx_agric,
    kappa_fx_manuf.nu_kappa_fx_manuf,
    phi_fx.nu_phi_fx,
    pm_fx_clothing.nu_pm_fx_clothing,
    pm_fx_food.nu_pm_fx_food,
    pric.nu_pric,
    priexp.nu_priexp,
    priimp.nu_priimp,
    realc.nu_realc,
    supply.nu_supply,
    t_fx_clothing.nu_t_fx_clothing,
    t_fx_food.nu_t_fx_food,
    v_fx_clothing.nu_v_fx_clothing,
    v_fx_food.nu_v_fx_food,
    wage.nu_wage,
    ws_fx.nu_ws_fx,
    ye_fx.nu_ye_fx
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = pc.l;
Display nlp2mcp_obj_val;