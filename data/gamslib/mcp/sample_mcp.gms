$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    h /1, 2, 3, 4/
    j /a, b/
;

Parameters
    data(h,*)
    vmax(j) /a 0.04, b 0.01/
    w(h)
    k1(h,j)
    k2(j)
;

Scalars
    tpop /0.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    n(h)
    nr(h)
    c
    nu_cbalr
;

Positive Variables
    lam_vbal(j)
    lam_vbalr(j)
    piL_n_1
    piL_n_2
    piL_n_3
    piL_n_4
;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_n_1
    stat_n_2
    stat_n_3
    stat_n_4
    stat_nr(h)
    comp_vbal(j)
    comp_vbalr(j)
    comp_lo_n_1
    comp_lo_n_2
    comp_lo_n_3
    comp_lo_n_4
    cbal
    cbalr
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_n_1.. data("1","cost") + 0 * nu_cbalr - ((-1) * k1("1",a)) / n("1") ** 2 * lam_vbal(a) - ((-1) * k1("1",b)) / n("1") ** 2 * lam_vbal(b) - 0 * lam_vbalr(a) - 0 * lam_vbalr(b) - piL_n_1 =E= 0;
stat_n_2.. data("2","cost") + 0 * nu_cbalr - ((-1) * k1("2",a)) / n("2") ** 2 * lam_vbal(a) - ((-1) * k1("2",b)) / n("2") ** 2 * lam_vbal(b) - 0 * lam_vbalr(a) - 0 * lam_vbalr(b) - piL_n_2 =E= 0;
stat_n_3.. data("3","cost") + 0 * nu_cbalr - ((-1) * k1("3",a)) / n("3") ** 2 * lam_vbal(a) - ((-1) * k1("3",b)) / n("3") ** 2 * lam_vbal(b) - 0 * lam_vbalr(a) - 0 * lam_vbalr(b) - piL_n_3 =E= 0;
stat_n_4.. data("4","cost") + 0 * nu_cbalr - ((-1) * k1("4",a)) / n("4") ** 2 * lam_vbal(a) - ((-1) * k1("4",b)) / n("4") ** 2 * lam_vbal(b) - 0 * lam_vbalr(a) - 0 * lam_vbalr(b) - piL_n_4 =E= 0;
stat_nr(h).. 0 + ((-1) * (((-1) * data(h,"cost")) / nr(h) ** 2)) * nu_cbalr + sum(j, 0 * lam_vbal(j)) + sum(j, k1(h,j) * lam_vbalr(j)) =E= 0;

* Inequality complementarity equations
comp_vbal(j).. ((-1) * (sum(h, k1(h,j) / n(h)) - k2(j))) =G= 0;
comp_vbalr(j).. ((-1) * (sum(h, k1(h,j) * nr(h)) - k2(j))) =G= 0;

* Lower bound complementarity equations
comp_lo_n_1.. n("1") - 100 =G= 0;
comp_lo_n_2.. n("2") - 100 =G= 0;
comp_lo_n_3.. n("3") - 100 =G= 0;
comp_lo_n_4.. n("4") - 100 =G= 0;

* Original equality equations
cbal.. c =E= sum(h, data(h,"cost") * n(h));
cbalr.. c =E= sum(h, data(h,"cost") / nr(h));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_n_1.n,
    stat_n_2.n,
    stat_n_3.n,
    stat_n_4.n,
    stat_nr.nr,
    comp_vbal.lam_vbal,
    comp_vbalr.lam_vbalr,
    cbal.c,
    cbalr.nu_cbalr,
    comp_lo_n_1.piL_n_1,
    comp_lo_n_2.piL_n_2,
    comp_lo_n_3.piL_n_3,
    comp_lo_n_4.piL_n_4
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;