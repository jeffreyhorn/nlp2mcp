$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33, i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47, i48, i49, i50, i51, i52, i53, i54, i55, i56, i57, i58, i59, i60, i61, i62, i63, i64, i65, i66, i67, i68, i69, i70, i71, i72, i73, i74, i75, i76, i77, i78, i79, i80, i81, i82, i83, i84, i85, i86, i87, i88, i89, i90, i91, i92, i93, i94, i95, i96, i97, i98, i99, i100/
    first(i)
    last(i)
    middle(i)
;

Alias(i, j);

Scalars
    R_v /1.0/
    R_max /2.0/
    R_min /1.0/
    alpha /1.5/
    d_theta /0.0/
;

first("i1") = 1;
last("i100") = 1;
middle(i) = 1;
middle(first) = 0;
middle(last) = 0;

d_theta = 2 * pi / (5 * (100 + 1));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    r(i)
    rdiff(i)
    area
    nu_eqrdiff(i)
;

Positive Variables
    lam_convexity(i)
    lam_convex_edge1(i)
    lam_convex_edge3(i)
    lam_convex_edge4(i)
    piL_r(i)
    piU_r(i)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

r.l(i) = (R_min + R_max) / 2;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_r(i)
    stat_rdiff(i)
    comp_convex_edge1(i)
    comp_convex_edge3(i)
    comp_convex_edge4(i)
    comp_convexity(i)
    comp_lo_r(i)
    comp_up_r(i)
    eqrdiff(i)
    obj
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_r(i).. ((-1) * (pi * R_v / 100)) + nu_eqrdiff(i) + (((-1) * r(i)) - r(i)) * lam_convexity(i) + (((-1) * R_min) - r(i)) * lam_convex_edge1(i) + (((-1) * r(i)) - R_max) * lam_convex_edge3(i) + ((-2) * R_max + 4 * cos(d_theta) * r(i)) * lam_convex_edge4(i) - piL_r(i) + piU_r(i) =E= 0;
stat_rdiff(i).. nu_eqrdiff(i) =E= 0;

* Inequality complementarity equations
comp_convex_edge1(i)$(ord(i) <= card(i) - 1).. ((-1) * (((-1) * R_min) * r(i) - r(i) * r(i+1) + 2 * R_min * r(i+1) * cos(d_theta))) =G= 0;
comp_convex_edge3(i)$(ord(i) > 1).. ((-1) * (((-1) * r(i-1)) * r(i) - r(i) * R_max + 2 * r(i-1) * R_max * cos(d_theta))) =G= 0;
comp_convex_edge4(i).. ((-1) * ((-2) * R_max * r(i) + 2 * sqr(r(i)) * cos(d_theta))) =G= 0;
comp_convexity(i)$((ord(i) <= card(i) - 1) and (ord(i) > 1)).. ((-1) * (((-1) * r(i-1)) * r(i) - r(i) * r(i+1) + 2 * r(i-1) * r(i+1) * cos(d_theta))) =G= 0;

* Lower bound complementarity equations
comp_lo_r(i).. r(i) - 1 =G= 0;

* Upper bound complementarity equations
comp_up_r(i).. 2 - r(i) =G= 0;

* Original equality equations
obj.. area =E= pi * R_v / 100 * sum(i, r(i));
eqrdiff(i)$(ord(i) <= card(i) - 1).. rdiff(i) =E= r(i+1) - r(i);


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_eqrdiff.fx(i)$(not (ord(i) <= card(i) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_r.r,
    stat_rdiff.rdiff,
    comp_convex_edge1.lam_convex_edge1,
    comp_convex_edge3.lam_convex_edge3,
    comp_convex_edge4.lam_convex_edge4,
    comp_convexity.lam_convexity,
    eqrdiff.nu_eqrdiff,
    obj.area,
    comp_lo_r.piL_r,
    comp_up_r.piU_r
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = area.l;
Display nlp2mcp_obj_val;