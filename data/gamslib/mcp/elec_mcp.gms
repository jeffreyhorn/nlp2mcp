$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25/
    ut(i,i)
;

Alias(i, j);

Parameters
    theta(i)
    phi(i)
;

ut(i,j) = 1;

* Fix random seed for deterministic MCP evaluation
execseed = 12345;

theta(i) = 2 * pi * uniform(0, 1);
phi(i) = pi * uniform(0, 1);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    x(i)
    y(i)
    z(i)
    potential
    nu_ball(i)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

x.l(i) = cos(theta(i)) * sin(phi(i));
y.l(i) = sin(theta(i)) * sin(phi(i));
z.l(i) = cos(phi(i));

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_x(i)
    stat_y(i)
    stat_z(i)
    ball(i)
    obj
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_x(i).. sum(j, ((-1) * (1 / (2 * sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j)))) * 2 * (x(i) - x(j)))) / sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j))) ** 2) + 2 * x(i) * nu_ball(i) =E= 0;
stat_y(i).. sum(j, ((-1) * (1 / (2 * sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j)))) * 2 * (y(i) - y(j)))) / sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j))) ** 2) + 2 * y(i) * nu_ball(i) =E= 0;
stat_z(i).. sum(j, ((-1) * (1 / (2 * sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j)))) * 2 * (z(i) - z(j)))) / sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j))) ** 2) + 2 * z(i) * nu_ball(i) =E= 0;

* Original equality equations
obj.. potential =E= sum((i,j), 1 / sqrt(sqr(x(i) - x(j)) + sqr(y(i) - y(j)) + sqr(z(i) - z(j))));
ball(i).. sqr(x(i)) + sqr(y(i)) + sqr(z(i)) =E= 1;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_x.x,
    stat_y.y,
    stat_z.z,
    ball.nu_ball,
    obj.potential
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = potential.l;
Display nlp2mcp_obj_val;