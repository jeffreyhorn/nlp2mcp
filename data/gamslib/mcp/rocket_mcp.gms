$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    h /h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23, h24, h25, h26, h27, h28, h29, h30, h31, h32, h33, h34, h35, h36, h37, h38, h39, h40, h41, h42, h43, h44, h45, h46, h47, h48, h49, h50/
;

Scalars
    h_0 /1.0/
    v_0 /0.0/
    m_0 /1.0/
    g_0 /1.0/
    nh /50.0/
    t_c /3.5/
    v_c /620.0/
    h_c /500.0/
    m_c /0.6/
    D_c /0.0/
    m_f /0.0/
    c /0.0/
;

D_c = 0.5 * v_c * m_0 / g_0;
m_f = m_c * m_0;
c = 0.5 * sqrt(g_0 * h_0);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    final_velocity
    nu_df(h)
    nu_gf(h)
    nu_h_eqn(h)
    nu_m_eqn(h)
    nu_v_eqn(h)
    nu_v_fx_h0
    nu_ht_fx_h0
    nu_m_fx_h0
;

Positive Variables
    step
    v(h)
    ht(h)
    g(h)
    m(h)
    t(h)
    d(h)
    piL_ht(h)
    piL_t(h)
    piU_m(h)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound).

step.l = 1 / nh;
step.l = min(max(step.l, 1e-6), step.up);
v.l(h) = (ord(h) - 1) / nh * (1 - (ord(h) - 1) / nh);
v.l(h) = min(max(v.l(h), 1e-6), v.up(h));
ht.l("h0") = 1.0;
ht.l("h1") = 1.0;
ht.l("h2") = 1.0;
ht.l("h3") = 1.0;
ht.l("h4") = 1.0;
ht.l("h5") = 1.0;
ht.l("h6") = 1.0;
ht.l("h7") = 1.0;
ht.l("h8") = 1.0;
ht.l("h9") = 1.0;
ht.l("h10") = 1.0;
ht.l("h11") = 1.0;
ht.l("h12") = 1.0;
ht.l("h13") = 1.0;
ht.l("h14") = 1.0;
ht.l("h15") = 1.0;
ht.l("h16") = 1.0;
ht.l("h17") = 1.0;
ht.l("h18") = 1.0;
ht.l("h19") = 1.0;
ht.l("h20") = 1.0;
ht.l("h21") = 1.0;
ht.l("h22") = 1.0;
ht.l("h23") = 1.0;
ht.l("h24") = 1.0;
ht.l("h25") = 1.0;
ht.l("h26") = 1.0;
ht.l("h27") = 1.0;
ht.l("h28") = 1.0;
ht.l("h29") = 1.0;
ht.l("h30") = 1.0;
ht.l("h31") = 1.0;
ht.l("h32") = 1.0;
ht.l("h33") = 1.0;
ht.l("h34") = 1.0;
ht.l("h35") = 1.0;
ht.l("h36") = 1.0;
ht.l("h37") = 1.0;
ht.l("h38") = 1.0;
ht.l("h39") = 1.0;
ht.l("h40") = 1.0;
ht.l("h41") = 1.0;
ht.l("h42") = 1.0;
ht.l("h43") = 1.0;
ht.l("h44") = 1.0;
ht.l("h45") = 1.0;
ht.l("h46") = 1.0;
ht.l("h47") = 1.0;
ht.l("h48") = 1.0;
ht.l("h49") = 1.0;
ht.l("h50") = 1.0;
ht.l(h) = min(max(ht.l(h), 1e-6), ht.up(h));
g.l(h) = g_0 * sqr(h_0 / ht.l(h));
g.l(h) = min(max(g.l(h), 1e-6), g.up(h));
m.l(h) = (m_f - m_0) * (ord(h) - 1) / nh + m_0;
m.l(h) = min(max(m.l(h), 1e-6), m.up(h));
t.l(h) = t.up(h) / 2;
t.l(h) = min(max(t.l(h), 1e-6), t.up(h));
d.l(h) = D_c * sqr(v.l(h)) * exp(((-1) * h_c) * (ht.l(h) - h_0) / h_0);
d.l(h) = min(max(d.l(h), 1e-6), d.up(h));

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_d(h)
    stat_g(h)
    stat_ht(h)
    stat_m(h)
    stat_step
    stat_t(h)
    stat_v(h)
    comp_lo_ht(h)
    comp_lo_t(h)
    comp_up_m(h)
    df(h)
    gf(h)
    h_eqn(h)
    ht_fx_h0
    m_eqn(h)
    m_fx_h0
    obj
    v_eqn(h)
    v_fx_h0
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_d(h).. nu_df(h) + ((-1) * (0.5 * step * m(h) * (-1) / m(h) ** 2)) * nu_v_eqn(h) =E= 0;
stat_g(h).. nu_gf(h) + ((-1) * (0.5 * step * m(h) * ((-1) * m(h)) / m(h) ** 2)) * nu_v_eqn(h) =E= 0;
stat_ht(h).. ((-1) * (D_c * sqr(v(h)) * exp(((-1) * h_c) * (ht(h) - h_0) / h_0) * h_0 * ((-1) * h_c) / h_0 ** 2)) * nu_df(h) + ((-1) * (g_0 * 2 * h_0 / ht(h) * ((-1) * h_0) / ht(h) ** 2)) * nu_gf(h) + nu_h_eqn(h) + nu_ht_fx_h0$sameas(h, 'h0') - piL_ht(h) =E= 0;
stat_m(h).. nu_m_eqn(h) + ((-1) * (0.5 * step * (m(h) * ((-1) * g(h)) - (t(h) - d(h) - m(h) * g(h))) / m(h) ** 2)) * nu_v_eqn(h) + nu_m_fx_h0$sameas(h, 'h0') + piU_m(h) =E= 0;
stat_step.. sum(h, ((-1) * (2 * v(h) * 0.5)) * nu_h_eqn(h)) + sum(h, c * 2 * t(h) * 0.5 / c ** 2 * nu_m_eqn(h)) + sum(h, ((-1) * (2 * (t(h) - d(h) - m(h) * g(h)) / m(h) * 0.5)) * nu_v_eqn(h)) =E= 0;
stat_t(h).. c * 0.5 * step / c ** 2 * nu_m_eqn(h) + ((-1) * (0.5 * step * 1 / m(h) ** 1)) * nu_v_eqn(h) - piL_t(h) =E= 0;
stat_v(h).. ((-1) * (exp(((-1) * h_c) * (ht(h) - h_0) / h_0) * D_c * 2 * v(h))) * nu_df(h) + ((-1) * (0.5 * step)) * nu_h_eqn(h) + nu_v_eqn(h) + nu_v_fx_h0$sameas(h, 'h0') =E= 0;

* Lower bound complementarity equations
comp_lo_ht(h).. ht(h) - 1 =G= 0;
comp_lo_t(h).. t(h) - 0 =G= 0;

* Upper bound complementarity equations
comp_up_m(h).. 1 - m(h) =G= 0;

* Original equality equations
obj.. final_velocity =E= ht("h50");
df(h).. d(h) =E= D_c * sqr(v(h)) * exp(((-1) * h_c) * (ht(h) - h_0) / h_0);
gf(h).. g(h) =E= g_0 * sqr(h_0 / ht(h));
h_eqn(h)$(ord(h) > 1).. ht(h) =E= ht(h-1) + 0.5 * step * (v(h) + v(h-1));
m_eqn(h)$(ord(h) > 1).. m(h) =E= m(h-1) - 0.5 * step * (t(h) + t(h-1)) / c;
v_eqn(h)$(ord(h) > 1).. v(h) =E= v(h-1) + 0.5 * step * ((t(h) - d(h) - m(h) * g(h)) / m(h) + (t(h-1) - d(h-1) - m(h-1) * g(h-1)) / m(h-1));
v_fx_h0.. v("h0") - 0 =E= 0;
ht_fx_h0.. ht("h0") - 1 =E= 0;
m_fx_h0.. m("h0") - 1 =E= 0;


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_h_eqn.fx(h)$(not (ord(h) > 1)) = 0;
nu_m_eqn.fx(h)$(not (ord(h) > 1)) = 0;
nu_v_eqn.fx(h)$(not (ord(h) > 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_d.d,
    stat_g.g,
    stat_ht.ht,
    stat_m.m,
    stat_step.step,
    stat_t.t,
    stat_v.v,
    df.nu_df,
    gf.nu_gf,
    h_eqn.nu_h_eqn,
    ht_fx_h0.nu_ht_fx_h0,
    m_eqn.nu_m_eqn,
    m_fx_h0.nu_m_fx_h0,
    obj.final_velocity,
    v_eqn.nu_v_eqn,
    v_fx_h0.nu_v_fx_h0,
    comp_lo_ht.piL_ht,
    comp_lo_t.piL_t,
    comp_up_m.piU_m
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = final_velocity.l;
Display nlp2mcp_obj_val;