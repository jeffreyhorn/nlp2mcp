$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    u /BRD, MLK, CAP, LAB, IDT, TRF, HOH, GOV, INV, EXT/
    i(u) /BRD, MLK/
    h(u) /CAP, LAB/
    r /JPN, USA/
;

Alias(u, v);
Alias(i, j);
Alias(h, k);
Alias(r, rr);

Parameters
    SAM(u,v,r)
    Y0(j,r)
    F0(h,j,r)
    X0(i,j,r)
    Z0(j,r)
    Xp0(i,r)
    Xg0(i,r)
    Xv0(i,r)
    E0(i,r)
    M0(i,r)
    Q0(i,r)
    D0(i,r)
    Sp0(r)
    Sg0(r)
    Td0(r)
    Tz0(j,r)
    Tm0(j,r)
    FF(h,r)
    Sf(r)
    tauz(i,r)
    taum(i,r) /BRD.JPN 0.0, BRD.USA 0.0, MLK.JPN 0.0, MLK.USA 0.0/
    sigma(i) /BRD 2.0, MLK 2.0/
    psi(i) /BRD 2.0, MLK 2.0/
    eta(i)
    phi(i)
    alpha(i,r)
    beta(h,j,r)
    b(j,r)
    ax(i,j,r)
    ay(j,r)
    mu(i,r)
    lambda(i,r)
    deltam(i,r)
    deltad(i,r)
    gamma(i,r)
    xid(i,r)
    xie(i,r)
    theta(i,r)
    ssp(r)
    ssg(r)
    taud(r)
    dY(j,r)
    dF(h,j,r)
    dX(i,j,r)
    dZ(j,r)
    dXp(i,r)
    dXg(i,r)
    dXv(i,r)
    dQ(i,r)
    dE(i,r)
    dM(i,r)
    dD(i,r)
    dpf(h,r)
    dpy(j,r)
    dpz(i,r)
    dpq(i,r)
    dpe(i,r)
    dpm(i,r)
    dpd(i,r)
    depsilon(r)
    dpWe(i,r)
    dpWm(i,r)
    dSp(r)
    dSg(r)
    dTd(r)
    dTz(i,r)
    dTm(i,r)
;

Y0(j,r) = sum(h, F0(h,j,r));
F0(h,j,r) = SAM(h,j,r);
X0(i,j,r) = SAM(i,j,r);
Z0(j,r) = Y0(j,r) + sum(i, X0(i,j,r));
Xp0(i,r) = SAM(i,"HOH",r);
Xg0(i,r) = SAM(i,"GOV",r);
Xv0(i,r) = SAM(i,"INV",r);
E0(i,r) = SAM(i,"EXT",r);
M0(i,r) = SAM("EXT",i,r);
Q0(i,r) = Xp0(i,r) + Xg0(i,r) + Xv0(i,r) + sum(j, X0(i,j,r));
D0(i,r) = (1 + tauz(i,r)) * Z0(i,r) - E0(i,r);
Sp0(r) = SAM("INV","HOH",r);
Sg0(r) = SAM("INV","GOV",r);
Td0(r) = SAM("GOV","HOH",r);
Tz0(j,r) = SAM("IDT",j,r);
Tm0(j,r) = SAM("TRF","J",r);
FF(h,r) = SAM("HOH",h,r);
Sf(r) = SAM("INV","EXT",r);
tauz(j,r) = Tz0(j,r) / Z0(j,r);
taum(j,r) = Tm0(j,r) / M0(j,r);
eta(i) = (sigma(i) - 1) / sigma(i);
phi(i) = (psi(i) + 1) / psi(i);
alpha(i,r) = Xp0(i,r) / sum(j, Xp0(j,r));
beta(h,j,r) = F0(h,j,r) / sum(k, F0(k,j,r));
b(j,r) = Y0(j,r) / prod(h, F0(h,j,r) ** beta(h,j,r));
ax(i,j,r) = X0(i,j,r) / Z0(j,r);
ay(j,r) = Y0(j,r) / Z0(j,r);
mu(i,r) = Xg0(i,r) / sum(j, Xg0(j,r));
lambda(i,r) = Xv0(i,r) / (Sp0(r) + Sg0(r) + Sf(r));
deltam(i,r) = (1 + taum(i,r)) * M0(i,r) ** (1 - eta(i)) / ((1 + taum(i,r)) * M0(i,r) ** (1 - eta(i)) + D0(i,r) ** (1 - eta(i)));
deltad(i,r) = D0(i,r) ** (1 - eta(i)) / ((1 + taum(i,r)) * M0(i,r) ** (1 - eta(i)) + D0(i,r) ** (1 - eta(i)));
gamma(i,r) = Q0(i,r) / (deltam(i,r) * M0(i,r) ** eta(i) + deltad(i,r) * D0(i,r) ** eta(i)) ** (1 / eta(i));
xid(i,r) = D0(i,r) ** (1 - phi(i)) / (E0(i,r) ** (1 - phi(i)) + D0(i,r) ** (1 - phi(i)));
xie(i,r) = E0(i,r) ** (1 - phi(i)) / (E0(i,r) ** (1 - phi(i)) + D0(i,r) ** (1 - phi(i)));
theta(i,r) = Z0(i,r) / (xie(i,r) * E0(i,r) ** phi(i) + xid(i,r) * D0(i,r) ** phi(i)) ** (1 / phi(i));
ssp(r) = Sp0(r) / sum(h, FF(h,r));
ssg(r) = Sg0(r) / (Td0(r) + sum(j, Tz0(j,r)) + sum(j, Tm0(j,r)));
taud(r) = Td0(r) / sum(h, FF(h,r));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    Y(j,r)
    F(h,j,r)
    X(i,j,r)
    Z(j,r)
    Xp(i,r)
    Xg(i,r)
    Xv(i,r)
    E(i,r)
    M(i,r)
    Q(i,r)
    D(i,r)
    pf(h,r)
    py(j,r)
    pz(i,r)
    pq(i,r)
    pe(i,r)
    pm(i,r)
    pd(i,r)
    epsilon(r)
    pWe(i,r)
    pWm(i,r)
    Sp(r)
    Sg(r)
    Td(r)
    Tz(j,r)
    Tm(i,r)
    UU(r)
    SW
    nu_eqpy(j,r)
    nu_eqX(i,j,r)
    nu_eqY(j,r)
    nu_eqF(h,j,r)
    nu_eqpzs(j,r)
    nu_eqTd(r)
    nu_eqTz(i,r)
    nu_eqTm(i,r)
    nu_eqXg(i,r)
    nu_eqXv(i,r)
    nu_eqSp(r)
    nu_eqSg(r)
    nu_eqXp(i,r)
    nu_eqpe(i,r)
    nu_eqpm(i,r)
    nu_eqepsilon(r)
    nu_eqpqs(i,r)
    nu_eqM(i,r)
    nu_eqD(i,r)
    nu_eqpzd(i,r)
    nu_eqE(i,r)
    nu_eqDs(i,r)
    nu_eqpqd(i,r)
    nu_eqpf(h,r)
    nu_eqUU(r)
    nu_pf_fx_LAB_JPN
    nu_pf_fx_LAB_USA
    nu_epsilon_fx_USA
;

Positive Variables
    piL_y(j,r)
    piL_f(h,j,r)
    piL_x(i,j,r)
    piL_z(j,r)
    piL_xp(i,r)
    piL_xg(i,r)
    piL_xv(i,r)
    piL_e(i,r)
    piL_m(i,r)
    piL_q(i,r)
    piL_d(i,r)
    piL_pf(h,r)
    piL_py(j,r)
    piL_pz(i,r)
    piL_pq(i,r)
    piL_pe(i,r)
    piL_pm(i,r)
    piL_pd(i,r)
    piL_epsilon(r)
    piL_pwe(i,r)
    piL_pwm(i,r)
    piL_sp(r)
    piL_sg(r)
    piL_td(r)
    piL_tz(j,r)
    piL_tm(i,r)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

Y.l("BRD","JPN") = 1e-05;
Y.l("BRD","USA") = 1e-05;
Y.l("MLK","JPN") = 1e-05;
Y.l("MLK","USA") = 1e-05;
F.l("CAP","BRD","JPN") = 1e-05;
F.l("CAP","BRD","USA") = 1e-05;
F.l("CAP","MLK","JPN") = 1e-05;
F.l("CAP","MLK","USA") = 1e-05;
F.l("LAB","BRD","JPN") = 1e-05;
F.l("LAB","BRD","USA") = 1e-05;
F.l("LAB","MLK","JPN") = 1e-05;
F.l("LAB","MLK","USA") = 1e-05;
X.l("BRD","BRD","JPN") = 1e-05;
X.l("BRD","BRD","USA") = 1e-05;
X.l("BRD","MLK","JPN") = 1e-05;
X.l("BRD","MLK","USA") = 1e-05;
X.l("MLK","BRD","JPN") = 1e-05;
X.l("MLK","BRD","USA") = 1e-05;
X.l("MLK","MLK","JPN") = 1e-05;
X.l("MLK","MLK","USA") = 1e-05;
Z.l("BRD","JPN") = 1e-05;
Z.l("BRD","USA") = 1e-05;
Z.l("MLK","JPN") = 1e-05;
Z.l("MLK","USA") = 1e-05;
Xp.l("BRD","JPN") = 1e-05;
Xp.l("BRD","USA") = 1e-05;
Xp.l("MLK","JPN") = 1e-05;
Xp.l("MLK","USA") = 1e-05;
Xg.l("BRD","JPN") = 1e-05;
Xg.l("BRD","USA") = 1e-05;
Xg.l("MLK","JPN") = 1e-05;
Xg.l("MLK","USA") = 1e-05;
Xv.l("BRD","JPN") = 1e-05;
Xv.l("BRD","USA") = 1e-05;
Xv.l("MLK","JPN") = 1e-05;
Xv.l("MLK","USA") = 1e-05;
E.l("BRD","JPN") = 1e-05;
E.l("BRD","USA") = 1e-05;
E.l("MLK","JPN") = 1e-05;
E.l("MLK","USA") = 1e-05;
M.l("BRD","JPN") = 1e-05;
M.l("BRD","USA") = 1e-05;
M.l("MLK","JPN") = 1e-05;
M.l("MLK","USA") = 1e-05;
Q.l("BRD","JPN") = 1e-05;
Q.l("BRD","USA") = 1e-05;
Q.l("MLK","JPN") = 1e-05;
Q.l("MLK","USA") = 1e-05;
D.l("BRD","JPN") = 1e-05;
D.l("BRD","USA") = 1e-05;
D.l("MLK","JPN") = 1e-05;
D.l("MLK","USA") = 1e-05;
pf.l("CAP","JPN") = 1.0;
pf.l("CAP","USA") = 1.0;
pf.l("LAB","JPN") = 1.0;
pf.l("LAB","USA") = 1.0;
py.l("BRD","JPN") = 1.0;
py.l("BRD","USA") = 1.0;
py.l("MLK","JPN") = 1.0;
py.l("MLK","USA") = 1.0;
pz.l("BRD","JPN") = 1.0;
pz.l("BRD","USA") = 1.0;
pz.l("MLK","JPN") = 1.0;
pz.l("MLK","USA") = 1.0;
pq.l("BRD","JPN") = 1.0;
pq.l("BRD","USA") = 1.0;
pq.l("MLK","JPN") = 1.0;
pq.l("MLK","USA") = 1.0;
pe.l("BRD","JPN") = 1.0;
pe.l("BRD","USA") = 1.0;
pe.l("MLK","JPN") = 1.0;
pe.l("MLK","USA") = 1.0;
pm.l("BRD","JPN") = 1.0;
pm.l("BRD","USA") = 1.0;
pm.l("MLK","JPN") = 1.0;
pm.l("MLK","USA") = 1.0;
pd.l("BRD","JPN") = 1.0;
pd.l("BRD","USA") = 1.0;
pd.l("MLK","JPN") = 1.0;
pd.l("MLK","USA") = 1.0;
epsilon.l("JPN") = 1.0;
epsilon.l("USA") = 1.0;
pWe.l("BRD","JPN") = 1.0;
pWe.l("BRD","USA") = 1.0;
pWe.l("MLK","JPN") = 1.0;
pWe.l("MLK","USA") = 1.0;
pWm.l("BRD","JPN") = 1.0;
pWm.l("BRD","USA") = 1.0;
pWm.l("MLK","JPN") = 1.0;
pWm.l("MLK","USA") = 1.0;
Sp.l("JPN") = 1e-05;
Sp.l("USA") = 1e-05;
Sg.l("JPN") = 1e-05;
Sg.l("USA") = 1e-05;
Td.l("JPN") = 1e-05;
Td.l("USA") = 1e-05;

* ============================================
* Post-solve Calibration (variable .l references)
* ============================================

$onImplicitAssign
dY(j,r) = (y.l(j,r) / Y0(j,r) - 1) * 100;
dF(h,j,r) = (f.l(h,j,r) / F0(h,j,r) - 1) * 100;
dX(i,j,r) = (x.l(i,j,r) / X0(i,j,r) - 1) * 100;
dZ(j,r) = (z.l(j,r) / Z0(j,r) - 1) * 100;
dXp(i,r) = (xp.l(i,r) / Xp0(i,r) - 1) * 100;
dXg(i,r) = (xg.l(i,r) / Xg0(i,r) - 1) * 100;
dXv(i,r) = (xv.l(i,r) / Xv0(i,r) - 1) * 100;
dQ(i,r) = (q.l(i,r) / Q0(i,r) - 1) * 100;
dE(i,r) = (e.l(i,r) / E0(i,r) - 1) * 100;
dM(i,r) = (m.l(i,r) / M0(i,r) - 1) * 100;
dD(i,r) = (d.l(i,r) / D0(i,r) - 1) * 100;
dpf(h,r) = (pf.l(h,r) / 1 - 1) * 100;
dpy(j,r) = (py.l(j,r) / 1 - 1) * 100;
dpz(i,r) = (pz.l(i,r) / 1 - 1) * 100;
dpq(i,r) = (pq.l(i,r) / 1 - 1) * 100;
dpe(i,r) = (pe.l(i,r) / 1 - 1) * 100;
dpm(i,r) = (pm.l(i,r) / 1 - 1) * 100;
dpd(i,r) = (pd.l(i,r) / 1 - 1) * 100;
depsilon(r) = (epsilon.l(r) / 1 - 1) * 100;
dpWe(i,r) = (pwe.l(i,r) / 1 - 1) * 100;
dpWm(i,r) = (pwm.l(i,r) / 1 - 1) * 100;
dSp(r) = (sp.l(r) / Sp0(r) - 1) * 100;
dSg(r) = (sg.l(r) / Sg0(r) - 1) * 100;
dTd(r) = (td.l(r) / Td0(r) - 1) * 100;
dTz(i,r) = (tz.l(i,r) / Tz0(i,r) - 1) * 100;
dTm(i,r) = (tm.l(i,r) / Tm0(i,r) - 1) * 100;
$offImplicitAssign

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_d(i,r)
    stat_e(i,r)
    stat_epsilon(r)
    stat_f(h,j,r)
    stat_m(i,r)
    stat_pd(i,r)
    stat_pe(i,r)
    stat_pf(h,r)
    stat_pm(i,r)
    stat_pq(i,r)
    stat_pwe(i,r)
    stat_pwm(i,r)
    stat_py(j,r)
    stat_pz(i,r)
    stat_q(i,r)
    stat_sg(r)
    stat_sp(r)
    stat_sw
    stat_td(r)
    stat_tm(i,r)
    stat_tz(j,r)
    stat_uu(r)
    stat_x(i,j,r)
    stat_xg(i,r)
    stat_xp(i,r)
    stat_xv(i,r)
    stat_y(j,r)
    stat_z(j,r)
    comp_lo_d(i,r)
    comp_lo_e(i,r)
    comp_lo_epsilon(r)
    comp_lo_f(h,j,r)
    comp_lo_m(i,r)
    comp_lo_pd(i,r)
    comp_lo_pe(i,r)
    comp_lo_pf(h,r)
    comp_lo_pm(i,r)
    comp_lo_pq(i,r)
    comp_lo_pwe(i,r)
    comp_lo_pwm(i,r)
    comp_lo_py(j,r)
    comp_lo_pz(i,r)
    comp_lo_q(i,r)
    comp_lo_sg(r)
    comp_lo_sp(r)
    comp_lo_td(r)
    comp_lo_tm(i,r)
    comp_lo_tz(j,r)
    comp_lo_x(i,j,r)
    comp_lo_xg(i,r)
    comp_lo_xp(i,r)
    comp_lo_xv(i,r)
    comp_lo_y(j,r)
    comp_lo_z(j,r)
    epsilon_fx_USA
    eqD(i,r)
    eqDs(i,r)
    eqE(i,r)
    eqF(h,j,r)
    eqM(i,r)
    eqSg(r)
    eqSp(r)
    eqTd(r)
    eqTm(i,r)
    eqTz(i,r)
    eqUU(r)
    eqX(i,j,r)
    eqXg(i,r)
    eqXp(i,r)
    eqXv(i,r)
    eqY(j,r)
    eqepsilon(r)
    eqpe(i,r)
    eqpf(h,r)
    eqpm(i,r)
    eqpqd(i,r)
    eqpqs(i,r)
    eqpy(j,r)
    eqpzd(i,r)
    eqpzs(j,r)
    obj
    pf_fx_LAB_JPN
    pf_fx_LAB_USA
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(h, h__);
Alias(i, i__);

* Stationarity equations
stat_d(i,r).. ((-1) * (gamma(i, r) * (deltam(i,r) * m(i,r) ** eta(i) + deltad(i,r) * d(i,r) ** eta(i)) ** (1 / eta(i)) * 1 / eta(i) / (deltam(i,r) * m(i,r) ** eta(i) + deltad(i,r) * d(i,r) ** eta(i)) * deltad(i,r) * d(i,r) ** eta(i) * eta(i) / d(i,r))) * nu_eqpqs(i,r) + nu_eqD(i,r) + ((-1) * (theta(i,r) * (xie(i,r) * e(i,r) ** phi(i) + xid(i,r) * d(i,r) ** phi(i)) ** (1 / phi(i)) * 1 / phi(i) / (xie(i,r) * e(i,r) ** phi(i) + xid(i,r) * d(i,r) ** phi(i)) * xid(i,r) * d(i,r) ** phi(i) * phi(i) / d(i,r))) * nu_eqpzd(i,r) + nu_eqDs(i,r) - piL_d(i,r) =E= 0;
stat_e(i,r).. pwe(i,r) * nu_eqepsilon(r) + ((-1) * (theta(i,r) * (xie(i,r) * e(i,r) ** phi(i) + xid(i,r) * d(i,r) ** phi(i)) ** (1 / phi(i)) * 1 / phi(i) / (xie(i,r) * e(i,r) ** phi(i) + xid(i,r) * d(i,r) ** phi(i)) * xie(i,r) * e(i,r) ** phi(i) * phi(i) / e(i,r))) * nu_eqpzd(i,r) + nu_eqE(i,r) - piL_e(i,r) =E= 0;
stat_epsilon(r).. sum(i, ((-1) * (pq(i,r) * lambda(i,r) * Sf(r) / pq(i,r) ** 2)) * nu_eqXv(i,r)) + sum(i, ((-1) * pwe(i,r)) * nu_eqpe(i,r)) + sum(i, ((-1) * pwm(i,r)) * nu_eqpm(i,r)) + nu_epsilon_fx_USA$sameas(r, 'USA') - piL_epsilon(r) =E= 0;
stat_f(h,j,r).. ((-1) * (b(j,r) * prod(h__, f(h__,j,r) ** beta(h__,j,r)) * sum(h__, f(h__,j,r) ** beta(h__,j,r) * beta(h__,j,r) / f(h__,j,r) / f(h__,j,r) ** beta(h__,j,r)))) * nu_eqpy(j,r) + nu_eqF(h,j,r) - nu_eqpf(h,r) - piL_f(h,j,r) =E= 0;
stat_m(i,r).. ((-1) * (taum(i,r) * pm(i,r))) * nu_eqTm(i,r) + ((-1) * pwm(i,r)) * nu_eqepsilon(r) + ((-1) * (gamma(i, r) * (deltam(i,r) * m(i,r) ** eta(i) + deltad(i,r) * d(i,r) ** eta(i)) ** (1 / eta(i)) * 1 / eta(i) / (deltam(i,r) * m(i,r) ** eta(i) + deltad(i,r) * d(i,r) ** eta(i)) * deltam(i,r) * m(i,r) ** eta(i) * eta(i) / m(i,r))) * nu_eqpqs(i,r) + nu_eqM(i,r) - piL_m(i,r) =E= 0;
stat_pd(i,r).. ((-1) * (q(i,r) * (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) * ((-1) * (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r))) / pd(i,r) ** 2)) * nu_eqD(i,r) + ((-1) * (z(i,r) * (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) * ((-1) * (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r))) / pd(i,r) ** 2)) * nu_eqDs(i,r) - piL_pd(i,r) =E= 0;
stat_pe(i,r).. nu_eqpe(i,r) + ((-1) * (z(i,r) * (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) * ((-1) * (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r))) / pe(i,r) ** 2)) * nu_eqE(i,r) - piL_pe(i,r) =E= 0;
stat_pf(h,r).. sum(j, ((-1) * (((-1) * (beta(h,j,r) * py(j,r) * y(j,r))) / pf(h,r) ** 2)) * nu_eqF(h,j,r)) + ((-1) * (taud(r) * FF(h,r))) * nu_eqTd(r) + ((-1) * (ssp(r) * FF(h,r))) * nu_eqSp(r) + sum(i, ((-1) * (pq(i,r) * alpha(i,r) * FF(h,r) / pq(i,r) ** 2)) * nu_eqXp(i,r)) + nu_pf_fx_LAB_JPN$(sameas(h, 'LAB') and sameas(r, 'JPN')) + nu_pf_fx_LAB_USA$(sameas(h, 'LAB') and sameas(r, 'USA')) - piL_pf(h,r) =E= 0;
stat_pm(i,r).. ((-1) * (m(i,r) * taum(i,r))) * nu_eqTm(i,r) + nu_eqpm(i,r) + ((-1) * (q(i,r) * (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) * ((-1) * (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) * (1 + taum(i,r)))) / ((1 + taum(i,r)) * pm(i,r)) ** 2)) * nu_eqM(i,r) - piL_pm(i,r) =E= 0;
stat_pq(i,r).. sum(j, ((-1) * ax(i,j,r)) * nu_eqpzs(j,r)) + ((-1) * (((-1) * (mu(i,r) * (td(r) + sum(j, tz(j,r)) + sum(j, tm(j,r)) - sg(r)))) / pq(i,r) ** 2)) * nu_eqXg(i,r) + ((-1) * (((-1) * (lambda(i,r) * (sp(r) + sg(r) + epsilon(r) * Sf(r)))) / pq(i,r) ** 2)) * nu_eqXv(i,r) + ((-1) * (((-1) * (alpha(i,r) * (sum(h, pf(h,r) * FF(h,r)) - sp(r) - td(r)))) / pq(i,r) ** 2)) * nu_eqXp(i,r) + ((-1) * (q(i,r) * (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) * (1 + taum(i,r)) * pm(i,r) * gamma(i, r) ** eta(i) * deltam(i,r) / ((1 + taum(i,r)) * pm(i,r)) ** 2)) * nu_eqM(i,r) + ((-1) * (q(i,r) * (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) * pd(i,r) * gamma(i, r) ** eta(i) * deltad(i,r) / pd(i,r) ** 2)) * nu_eqD(i,r) - piL_pq(i,r) =E= 0;
stat_pwe(i,r).. ((-1) * epsilon(r)) * nu_eqpe(i,r) + e(i,r) * nu_eqepsilon(r) - piL_pwe(i,r) =E= 0;
stat_pwm(i,r).. ((-1) * epsilon(r)) * nu_eqpm(i,r) + ((-1) * m(i,r)) * nu_eqepsilon(r) - piL_pwm(i,r) =E= 0;
stat_py(j,r).. sum(h, ((-1) * (pf(h,r) * y(j,r) * beta(h,j,r) / pf(h,r) ** 2)) * nu_eqF(h,j,r)) + ((-1) * ay(j,r)) * nu_eqpzs(j,r) - piL_py(j,r) =E= 0;
stat_pz(i,r).. sum(j, nu_eqpzs(j,r)) + ((-1) * (z(i,r) * tauz(i,r))) * nu_eqTz(i,r) + ((-1) * (z(i,r) * (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) * pe(i,r) * theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) / pe(i,r) ** 2)) * nu_eqE(i,r) + ((-1) * (z(i,r) * (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) * pd(i,r) * theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) / pd(i,r) ** 2)) * nu_eqDs(i,r) - piL_pz(i,r) =E= 0;
stat_q(i,r).. nu_eqpqs(i,r) + ((-1) * ((gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) ** (1 / (1 - eta(i))))) * nu_eqM(i,r) + ((-1) * ((gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) ** (1 / (1 - eta(i))))) * nu_eqD(i,r) + nu_eqpqd(i,r) - piL_q(i,r) =E= 0;
stat_sg(r).. sum(i, ((-1) * (pq(i,r) * mu(i,r) * (-1) / pq(i,r) ** 2)) * nu_eqXg(i,r)) + sum(i, ((-1) * (pq(i,r) * lambda(i,r) / pq(i,r) ** 2)) * nu_eqXv(i,r)) + nu_eqSg(r) - piL_sg(r) =E= 0;
stat_sp(r).. sum(i, ((-1) * (pq(i,r) * lambda(i,r) / pq(i,r) ** 2)) * nu_eqXv(i,r)) + nu_eqSp(r) + sum(i, ((-1) * (pq(i,r) * alpha(i,r) * (-1) / pq(i,r) ** 2)) * nu_eqXp(i,r)) - piL_sp(r) =E= 0;
stat_sw.. 0 =E= 0;
stat_td(r).. nu_eqTd(r) + sum(i, ((-1) * (pq(i,r) * mu(i,r) / pq(i,r) ** 2)) * nu_eqXg(i,r)) + ((-1) * ssg(r)) * nu_eqSg(r) + sum(i, ((-1) * (pq(i,r) * alpha(i,r) * (-1) / pq(i,r) ** 2)) * nu_eqXp(i,r)) - piL_td(r) =E= 0;
stat_tm(i,r).. nu_eqTm(i,r) + ((-1) * (pq(i,r) * mu(i,r) / pq(i,r) ** 2)) * nu_eqXg(i,r) + ((-1) * ssg(r)) * nu_eqSg(r) - piL_tm(i,r) =E= 0;
stat_tz(j,r).. sum(i, nu_eqTz(i,r)) + sum(i, ((-1) * (pq(i,r) * mu(i,r) / pq(i,r) ** 2)) * nu_eqXg(i,r)) + ((-1) * ssg(r)) * nu_eqSg(r) - piL_tz(j,r) =E= 0;
stat_uu(r).. -1 + nu_eqUU(r) =E= 0;
stat_x(i,j,r).. nu_eqX(i,j,r) - piL_x(i,j,r) =E= 0;
stat_xg(i,r).. nu_eqXg(i,r) - nu_eqpqd(i,r) - piL_xg(i,r) =E= 0;
stat_xp(i,r).. nu_eqXp(i,r) - nu_eqpqd(i,r) + ((-1) * (prod(i__, xp(i__,r) ** alpha(i__,r)) * sum(i__, xp(i__,r) ** alpha(i__,r) * alpha(i__,r) / xp(i__,r) / xp(i__,r) ** alpha(i__,r)))) * nu_eqUU(r) - piL_xp(i,r) =E= 0;
stat_xv(i,r).. nu_eqXv(i,r) - nu_eqpqd(i,r) - piL_xv(i,r) =E= 0;
stat_y(j,r).. nu_eqpy(j,r) + nu_eqY(j,r) + sum(h, ((-1) * (pf(h,r) * beta(h,j,r) * py(j,r) / pf(h,r) ** 2)) * nu_eqF(h,j,r)) - piL_y(j,r) =E= 0;
stat_z(j,r).. sum(i, ((-1) * ax(j,j,r)) * nu_eqX(i,j,r)) + ((-1) * ay(j,r)) * nu_eqY(j,r) + sum(i, ((-1) * (tauz(i,r) * pz(i,r))) * nu_eqTz(i,r)) + sum(i, nu_eqpzd(i,r)) + sum(i, ((-1) * ((theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) ** (1 / (1 - phi(i))))) * nu_eqE(i,r)) + sum(i, ((-1) * ((theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) ** (1 / (1 - phi(i))))) * nu_eqDs(i,r)) - piL_z(j,r) =E= 0;

* Lower bound complementarity equations
comp_lo_d(i,r).. d(i,r) - 1e-05 =G= 0;
comp_lo_e(i,r).. e(i,r) - 1e-05 =G= 0;
comp_lo_epsilon(r).. epsilon(r) - 1e-05 =G= 0;
comp_lo_f(h,j,r).. f(h,j,r) - 1e-05 =G= 0;
comp_lo_m(i,r).. m(i,r) - 1e-05 =G= 0;
comp_lo_pd(i,r).. pd(i,r) - 1e-05 =G= 0;
comp_lo_pe(i,r).. pe(i,r) - 1e-05 =G= 0;
comp_lo_pf(h,r).. pf(h,r) - 1e-05 =G= 0;
comp_lo_pm(i,r).. pm(i,r) - 1e-05 =G= 0;
comp_lo_pq(i,r).. pq(i,r) - 1e-05 =G= 0;
comp_lo_pwe(i,r).. pwe(i,r) - 1e-05 =G= 0;
comp_lo_pwm(i,r).. pwm(i,r) - 1e-05 =G= 0;
comp_lo_py(j,r).. py(j,r) - 1e-05 =G= 0;
comp_lo_pz(i,r).. pz(i,r) - 1e-05 =G= 0;
comp_lo_q(i,r).. q(i,r) - 1e-05 =G= 0;
comp_lo_sg(r).. sg(r) - 1e-05 =G= 0;
comp_lo_sp(r).. sp(r) - 1e-05 =G= 0;
comp_lo_td(r).. td(r) - 1e-05 =G= 0;
comp_lo_tm(i,r).. tm(i,r) - 0 =G= 0;
comp_lo_tz(j,r).. tz(j,r) - 0 =G= 0;
comp_lo_x(i,j,r).. x(i,j,r) - 1e-05 =G= 0;
comp_lo_xg(i,r).. xg(i,r) - 1e-05 =G= 0;
comp_lo_xp(i,r).. xp(i,r) - 1e-05 =G= 0;
comp_lo_xv(i,r).. xv(i,r) - 1e-05 =G= 0;
comp_lo_y(j,r).. y(j,r) - 1e-05 =G= 0;
comp_lo_z(j,r).. z(j,r) - 1e-05 =G= 0;

* Original equality equations
eqpy(j,r).. y(j,r) =E= b(j,r) * prod(h, f(h,j,r) ** beta(h,j,r));
eqX(i,j,r).. x(i,j,r) =E= ax(i,j,r) * z(j,r);
eqY(j,r).. y(j,r) =E= ay(j,r) * z(j,r);
eqF(h,j,r).. f(h,j,r) =E= beta(h,j,r) * py(j,r) * y(j,r) / pf(h,r);
eqpzs(j,r).. pz(j,r) =E= ay(j,r) * py(j,r) + sum(i, ax(i,j,r) * pq(i,r));
eqTd(r).. td(r) =E= taud(r) * sum(h, pf(h,r) * FF(h,r));
eqTz(i,r).. tz(i,r) =E= tauz(i,r) * pz(i,r) * z(i,r);
eqTm(i,r).. tm(i,r) =E= taum(i,r) * pm(i,r) * m(i,r);
eqXg(i,r).. xg(i,r) =E= mu(i,r) * (td(r) + sum(j, tz(j,r)) + sum(j, tm(j,r)) - sg(r)) / pq(i,r);
eqXv(i,r).. xv(i,r) =E= lambda(i,r) * (sp(r) + sg(r) + epsilon(r) * Sf(r)) / pq(i,r);
eqSp(r).. sp(r) =E= ssp(r) * sum(h, pf(h,r) * FF(h,r));
eqSg(r).. sg(r) =E= ssg(r) * (td(r) + sum(j, tz(j,r)) + sum(j, tm(j,r)));
eqXp(i,r).. xp(i,r) =E= alpha(i,r) * (sum(h, pf(h,r) * FF(h,r)) - sp(r) - td(r)) / pq(i,r);
eqpe(i,r).. pe(i,r) =E= epsilon(r) * pwe(i,r);
eqpm(i,r).. pm(i,r) =E= epsilon(r) * pwm(i,r);
eqepsilon(r).. sum(i, pwe(i,r) * e(i,r)) + Sf(r) =E= sum(i, pwm(i,r) * m(i,r));
eqpqs(i,r).. q(i,r) =E= gamma(i, r) * (deltam(i,r) * m(i,r) ** eta(i) + deltad(i,r) * d(i,r) ** eta(i)) ** (1 / eta(i));
eqM(i,r).. m(i,r) =E= (gamma(i, r) ** eta(i) * deltam(i,r) * pq(i,r) / ((1 + taum(i,r)) * pm(i,r))) ** (1 / (1 - eta(i))) * q(i,r);
eqD(i,r).. d(i,r) =E= (gamma(i, r) ** eta(i) * deltad(i,r) * pq(i,r) / pd(i,r)) ** (1 / (1 - eta(i))) * q(i,r);
eqpzd(i,r).. z(i,r) =E= theta(i,r) * (xie(i,r) * e(i,r) ** phi(i) + xid(i,r) * d(i,r) ** phi(i)) ** (1 / phi(i));
eqE(i,r).. e(i,r) =E= (theta(i,r) ** phi(i) * xie(i,r) * (1 + tauz(i,r)) * pz(i,r) / pe(i,r)) ** (1 / (1 - phi(i))) * z(i,r);
eqDs(i,r).. d(i,r) =E= (theta(i,r) ** phi(i) * xid(i,r) * (1 + tauz(i,r)) * pz(i,r) / pd(i,r)) ** (1 / (1 - phi(i))) * z(i,r);
eqpqd(i,r).. q(i,r) =E= xp(i,r) + xg(i,r) + xv(i,r) + sum(j, x(i,j,r));
eqpf(h,r).. FF(h,r) =E= sum(j, f(h,j,r));
eqUU(r).. uu(r) =E= prod(i, xp(i,r) ** alpha(i,r));
obj.. sw =E= sum(r, uu(r));
pf_fx_LAB_JPN.. pf("LAB","JPN") - 1 =E= 0;
pf_fx_LAB_USA.. pf("LAB","USA") - 1 =E= 0;
epsilon_fx_USA.. epsilon("USA") - 1 =E= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_d.d,
    stat_e.e,
    stat_epsilon.epsilon,
    stat_f.f,
    stat_m.m,
    stat_pd.pd,
    stat_pe.pe,
    stat_pf.pf,
    stat_pm.pm,
    stat_pq.pq,
    stat_pwe.pwe,
    stat_pwm.pwm,
    stat_py.py,
    stat_pz.pz,
    stat_q.q,
    stat_sg.sg,
    stat_sp.sp,
    stat_sw.sw,
    stat_td.td,
    stat_tm.tm,
    stat_tz.tz,
    stat_uu.uu,
    stat_x.x,
    stat_xg.xg,
    stat_xp.xp,
    stat_xv.xv,
    stat_y.y,
    stat_z.z,
    epsilon_fx_USA.nu_epsilon_fx_USA,
    eqD.nu_eqD,
    eqDs.nu_eqDs,
    eqE.nu_eqE,
    eqF.nu_eqF,
    eqM.nu_eqM,
    eqSg.nu_eqSg,
    eqSp.nu_eqSp,
    eqTd.nu_eqTd,
    eqTm.nu_eqTm,
    eqTz.nu_eqTz,
    eqUU.nu_eqUU,
    eqX.nu_eqX,
    eqXg.nu_eqXg,
    eqXp.nu_eqXp,
    eqXv.nu_eqXv,
    eqY.nu_eqY,
    eqepsilon.nu_eqepsilon,
    eqpe.nu_eqpe,
    eqpf.nu_eqpf,
    eqpm.nu_eqpm,
    eqpqd.nu_eqpqd,
    eqpqs.nu_eqpqs,
    eqpy.nu_eqpy,
    eqpzd.nu_eqpzd,
    eqpzs.nu_eqpzs,
    obj.SW,
    pf_fx_LAB_JPN.nu_pf_fx_LAB_JPN,
    pf_fx_LAB_USA.nu_pf_fx_LAB_USA,
    comp_lo_d.piL_d,
    comp_lo_e.piL_e,
    comp_lo_epsilon.piL_epsilon,
    comp_lo_f.piL_f,
    comp_lo_m.piL_m,
    comp_lo_pd.piL_pd,
    comp_lo_pe.piL_pe,
    comp_lo_pf.piL_pf,
    comp_lo_pm.piL_pm,
    comp_lo_pq.piL_pq,
    comp_lo_pwe.piL_pwe,
    comp_lo_pwm.piL_pwm,
    comp_lo_py.piL_py,
    comp_lo_pz.piL_pz,
    comp_lo_q.piL_q,
    comp_lo_sg.piL_sg,
    comp_lo_sp.piL_sp,
    comp_lo_td.piL_td,
    comp_lo_tm.piL_tm,
    comp_lo_tz.piL_tz,
    comp_lo_x.piL_x,
    comp_lo_xg.piL_xg,
    comp_lo_xp.piL_xp,
    comp_lo_xv.piL_xv,
    comp_lo_y.piL_y,
    comp_lo_z.piL_z
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = SW.l;
Display nlp2mcp_obj_val;