$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    tl /'0', '1', '2', '3'/
    t(tl) /'1', '2', '3'/
    tt(t) /'3'/
;

Parameters
    ufact(t)
;

Scalars
    p /1.0/
    r /0.07/
    tr /0.0/
    th /1004.72366/
    w /1.0/
    d /0.2/
    a1 /0.5/
    a2 /-0.5/
    am /1100.0/
    lambda /0.944/
    lstar /400.0/
    gamma1 /0.255905/
    gamma2 /1.0/
;

ufact(t) = lambda ** (ord(t) - 1);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    a(tl)
    c(t)
    l(t)
    m(tl)
    n(t)
    obj
    s(tl)
    tax(t)
    u(t)
    y(t)
    nu_utility(t)
    nu_income(t)
    nu_taxes(t)
    nu_savings(t)
    nu_budget(tl)
    nu_timemoney(t)
    nu_terminal(tt)
    nu_a_fx_0
    nu_m_fx_0
;

Positive Variables
    lam_dom1(t)
    lam_dom2(t)
    piL_c(t)
    piL_l(t)
    piL_u(t)
    piU_l(t)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

a.l("0") = 1000.0;
a.l("1") = 1000.0;
a.l("2") = 1000.0;
a.l("3") = 1000.0;
c.l("1") = 100.0;
c.l("2") = 100.0;
c.l("3") = 100.0;
l.l("1") = 400.0;
l.l("2") = 400.0;
l.l("3") = 400.0;
m.l("0") = 100.0;
m.l("1") = 100.0;
m.l("2") = 100.0;
m.l("3") = 100.0;
u.l("1") = 1.0;
u.l("2") = 1.0;
u.l("3") = 1.0;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_a(tl)
    stat_c(t)
    stat_l(t)
    stat_m(tl)
    stat_n(t)
    stat_s(tl)
    stat_tax(t)
    stat_u(t)
    stat_y(t)
    comp_dom1(t)
    comp_dom2(t)
    comp_lo_c(t)
    comp_lo_l(t)
    comp_lo_u(t)
    comp_up_l(t)
    a_fx_0
    budget(tl)
    income(t)
    m_fx_0
    objective
    savings(t)
    taxes(t)
    terminal(tt)
    timemoney(t)
    utility(t)
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(t, t__);

* Stationarity equations
stat_a(tl)$(t(tl)).. ((-1) * nu_budget(tl)) + nu_a_fx_0$sameas(tl, '0') + sum(t, ((-1) * r) * nu_income(t)) + sum(tt, nu_terminal(tt)) =E= 0;
stat_c(t).. ((-1) * (100 * (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) ** ((-1) / a2) * (-1) / a2 / (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) * a1 * c(t) ** ((-1) * a2) * ((-1) * a2) / c(t) / 10000)) * nu_utility(t) + p * nu_savings(t) + n(t) * ((-1) * (gamma1 * p)) * nu_timemoney(t) + 1.01 * gamma1 * p * lam_dom1(t) - piL_c(t) =E= 0;
stat_l(t).. ((-1) * (100 * (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) ** ((-1) / a2) * (-1) / a2 / (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) * (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2) * ((-1) * a2) / (th - l(t) - n(t)) * (-1) / 10000)) * nu_utility(t) + ((-1) * w) * nu_income(t) + lam_dom2(t) - piL_l(t) + piU_l(t) =E= 0;
stat_m(tl)$(t(tl)).. ((-1) * nu_budget(tl)) + nu_m_fx_0$sameas(tl, '0') + sum(t, n(t) * nu_timemoney(t)) + sum(tt, nu_terminal(tt)) + sum(t, (-1) * lam_dom1(t)) =E= 0;
stat_n(t).. ((-1) * (100 * (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) ** ((-1) / a2) * (-1) / a2 / (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) * (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2) * ((-1) * a2) / (th - l(t) - n(t)) * (-1) / 10000)) * nu_utility(t) + (m(t) - gamma1 * p * c(t)) * nu_timemoney(t) + lam_dom2(t) =E= 0;
stat_s(tl)$(t(tl)).. nu_budget(tl) + sum(t, nu_savings(t)) =E= 0;
stat_tax(t).. nu_taxes(t) + nu_savings(t) =E= 0;
stat_u(t).. ((-1) * (prod(t__, u(t__) ** ufact(t__)) * sum(t__, u(t__) ** ufact(t__) * ufact(t__) / u(t__) / u(t__) ** ufact(t__)))) + nu_utility(t) - piL_u(t) =E= 0;
stat_y(t).. nu_income(t) + ((-1) * d) * nu_taxes(t) - nu_savings(t) =E= 0;

* Inequality complementarity equations
comp_dom1(t).. m(t) - 1.01 * gamma1 * p * c(t) =G= 0;
comp_dom2(t).. ((-1) * (l(t) + n(t) - 0.9 * th)) =G= 0;

* Lower bound complementarity equations
comp_lo_c(t).. c(t) - 100 =G= 0;
comp_lo_l(t).. l(t) - 100 =G= 0;
comp_lo_u(t).. u(t) - 0.01 =G= 0;

* Upper bound complementarity equations
comp_up_l(t).. 400 - l(t) =G= 0;

* Original equality equations
objective.. obj =E= prod(t, u(t) ** ufact(t));
utility(t).. u(t) =E= (a1 * c(t) ** ((-1) * a2) + (1 - a1) * (th - l(t) - n(t)) ** ((-1) * a2)) ** ((-1) / a2) / 100;
income(t).. y(t) =E= w * l(t) + r * a(t);
taxes(t).. tax(t) =E= d * y(t) - tr;
savings(t).. s(t) =E= y(t) - tax(t) - p * c(t);
budget(tl)$(ord(tl) > 1).. s(tl) =E= a(tl) - a(tl-1) + m(tl) - m(tl-1);
timemoney(t).. n(t) * (m(t) - gamma1 * p * c(t)) =E= gamma2;
terminal(tt).. a(tt) + m(tt) =E= am;
a_fx_0.. a("0") - 1000 =E= 0;
m_fx_0.. m("0") - 100 =E= 0;


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

a.fx(tl)$(not (t(tl))) = 0;
m.fx(tl)$(not (t(tl))) = 0;
s.fx(tl)$(not (t(tl))) = 0;
nu_budget.fx(tl)$(not (ord(tl) > 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_a.a,
    stat_c.c,
    stat_l.l,
    stat_m.m,
    stat_n.n,
    stat_s.s,
    stat_tax.tax,
    stat_u.u,
    stat_y.y,
    comp_dom1.lam_dom1,
    comp_dom2.lam_dom2,
    a_fx_0.nu_a_fx_0,
    budget.nu_budget,
    income.nu_income,
    m_fx_0.nu_m_fx_0,
    objective.obj,
    savings.nu_savings,
    taxes.nu_taxes,
    terminal.nu_terminal,
    timemoney.nu_timemoney,
    utility.nu_utility,
    comp_lo_c.piL_c,
    comp_lo_l.piL_l,
    comp_lo_u.piL_u,
    comp_up_l.piU_l
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = obj.l;
Display nlp2mcp_obj_val;