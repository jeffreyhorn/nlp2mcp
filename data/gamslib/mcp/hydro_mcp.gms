$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    tt /'0', '1', '2', '3', '4', '5', '6'/
    t(tt) /'1', '2', '3', '4', '5', '6'/
;

Scalars
    load /1300.0/
    losscof /8e-05/
    n /12.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    cost
    nu_losseq(t)
    nu_flow(tt)
    nu_dischar(t)
    nu_v_fx_0
    nu_v_fx_1
    nu_v_fx_2
    nu_v_fx_3
    nu_v_fx_4
    nu_v_fx_5
    nu_v_fx_6
;

Positive Variables
    thermal(t)
    hydro(t)
    loss(t)
    q(tt)
    v(tt)
    lam_demcons(t)
    piL_thermal(t)
    piL_v(tt)
    piU_thermal(t)
    piU_hydro(t)
    piU_v(tt)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1.

thermal.l("1") = 150.0;
thermal.l("2") = 150.0;
thermal.l("3") = 150.0;
thermal.l("4") = 150.0;
thermal.l("5") = 150.0;
thermal.l("6") = 150.0;
thermal.l(t) = min(max(thermal.l(t), 1e-6), thermal.up(t));
hydro.l(t) = 1;
loss.l(t) = 1;
q.l(tt) = 1;
v.l("0") = 60000.0;
v.l("1") = 60000.0;
v.l("2") = 60000.0;
v.l("3") = 60000.0;
v.l("4") = 60000.0;
v.l("5") = 60000.0;
v.l("6") = 60000.0;
v.l(tt) = min(max(v.l(tt), 1e-6), v.up(tt));

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_hydro(t)
    stat_loss(t)
    stat_q(tt)
    stat_thermal(t)
    stat_v(tt)
    comp_demcons(t)
    comp_lo_thermal(t)
    comp_lo_v(tt)
    comp_up_hydro(t)
    comp_up_thermal(t)
    comp_up_v(tt)
    costfn
    dischar(t)
    flow(tt)
    losseq(t)
    v_fx_0
    v_fx_1
    v_fx_2
    v_fx_3
    v_fx_4
    v_fx_5
    v_fx_6
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_hydro(t).. ((-1) * (losscof * 2 * power(hydro(t), 1))) * nu_losseq(t) + (-4.97) * nu_dischar(t) - lam_demcons(t) + piU_hydro(t) =E= 0;
stat_loss(t).. nu_losseq(t) + lam_demcons(t) =E= 0;
stat_q(tt)$(t(tt)).. ((-1) * (n * (-1))) * nu_flow(tt) + sum(t, nu_dischar(t)) =E= 0;
stat_thermal(t).. 1.15 * n * card(t) * (8 + 0.0032 * thermal(t)) - lam_demcons(t) - piL_thermal(t) + piU_thermal(t) =E= 0;
stat_v(tt).. nu_flow(tt) + nu_v_fx_0$sameas(tt, '0') + nu_v_fx_1$sameas(tt, '1') + nu_v_fx_2$sameas(tt, '2') + nu_v_fx_3$sameas(tt, '3') + nu_v_fx_4$sameas(tt, '4') + nu_v_fx_5$sameas(tt, '5') + nu_v_fx_6$sameas(tt, '6') - piL_v(tt) + piU_v(tt) =E= 0;

* Inequality complementarity equations
comp_demcons(t).. thermal(t) + hydro(t) - (load(t) + loss(t)) =G= 0;

* Lower bound complementarity equations
comp_lo_thermal(t).. thermal(t) - 150 =G= 0;
comp_lo_v(tt).. v(tt) - 60000 =G= 0;

* Upper bound complementarity equations
comp_up_hydro(t).. 1000 - hydro(t) =G= 0;
comp_up_thermal(t).. 1500 - thermal(t) =G= 0;
comp_up_v(tt).. 120000 - v(tt) =G= 0;

* Original equality equations
costfn.. cost =E= 1.15 * n * card(t) * sum(t, 500 + 8 * thermal(t) + 0.0016 * sqr(thermal(t)));
losseq(t).. loss(t) =E= losscof * power(hydro(t), 2);
flow(tt)$(ord(tt) > 1).. v(tt) =E= v(tt-1) + (2000 - q(tt)) * n;
dischar(t).. q(t) =E= 330 + 4.97 * hydro(t);
v_fx_0.. v("0") - 100000 =E= 0;
v_fx_1.. v("1") - 100000 =E= 0;
v_fx_2.. v("2") - 100000 =E= 0;
v_fx_3.. v("3") - 100000 =E= 0;
v_fx_4.. v("4") - 100000 =E= 0;
v_fx_5.. v("5") - 100000 =E= 0;
v_fx_6.. v("6") - 100000 =E= 0;


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

q.fx(tt)$(not (t(tt))) = 0;
nu_flow.fx(tt)$(not (ord(tt) > 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_hydro.hydro,
    stat_loss.loss,
    stat_q.q,
    stat_thermal.thermal,
    stat_v.v,
    comp_demcons.lam_demcons,
    costfn.cost,
    dischar.nu_dischar,
    flow.nu_flow,
    losseq.nu_losseq,
    v_fx_0.nu_v_fx_0,
    v_fx_1.nu_v_fx_1,
    v_fx_2.nu_v_fx_2,
    v_fx_3.nu_v_fx_3,
    v_fx_4.nu_v_fx_4,
    v_fx_5.nu_v_fx_5,
    v_fx_6.nu_v_fx_6,
    comp_lo_thermal.piL_thermal,
    comp_lo_v.piL_v,
    comp_up_hydro.piU_hydro,
    comp_up_thermal.piU_thermal,
    comp_up_v.piU_v
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = cost.l;
Display nlp2mcp_obj_val;