$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    w /ICBM, 'MRBM-1', 'LR-Bomber', 'F-Bomber', 'MRBM-2'/
    t /'1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'/
;

Parameters
    td(*,*) /'1'.'target data' 2.0, icbm.'target data' 0.05, 'mrbm-1'.'target data' 0.16, 'lr-bomber'.'target data' 0.04, 'f-bomber'.'target data' 0.04, 'mrbm-2'.'target data' 0.08, damage.'target data' 60.0, target.'target data' 30.0/
    wa(w)
    tm(t)
    mv(t)
;

Scalars
    report /0.0/
;

wa(w) = td(w,"avail");
tm(t) = td("target",t);
mv(t) = td("damage",t);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    prob(t)
    tetd
    nu_probe(t)
    nu_etd
;

Positive Variables
    x(w,t)
    lam_maxw(w)
    lam_minw(t)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables are set to 1.

x.l(w,t) = 1;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_prob(t)
    stat_x(w,t)
    comp_maxw(w)
    comp_minw(t)
    etd
    etdp
    probe(t)
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(w, w__);

* Stationarity equations
stat_prob(t).. ((-1) * mv(t)) + (1 - ((-1) * (prod(w$td(w,t), (1 - td(w,t)) ** x(w,t)) * sum(w$td(w,t), 0)))) * nu_probe(t) + ((-1) * (mv(t) * ((-1) * (prod(w$td(w,"1"), (1 - td(w,"1")) ** x(w,"1")) * sum(w$td(w,t), 0))))) * nu_etd + sum(w, 0 * lam_maxw(w)) =E= 0;
stat_x(w,t).. 0 + prod(w__$td(w__,t), (1 - td(w__,t)) ** x(w__,t)) * sum(w__$td(w__,t), 0) * nu_probe(t) + ((-1) * (mv(t) * ((-1) * (prod(w__$td(w__,"1"), (1 - td(w__,"1")) ** x(w__,"1")) * sum(w__$td(w__,t), 0))))) * nu_etd + 1 * lam_maxw(w) =E= 0;

* Inequality complementarity equations
comp_maxw(w).. ((-1) * (sum(t$td(w,t), x(w,t)) - wa(w))) =G= 0;
comp_minw(t)$(tm(t)).. sum(w$td(w,t), x(w,t)) - tm(t) =G= 0;

* Original equality equations
probe(t).. prob(t) =E= 1 - prod(w$td(w,t), (1 - td(w,t)) ** x(w,t));
etdp.. tetd =E= sum(t, mv(t) * prob(t));
etd.. tetd =E= sum(t, mv(t) * (1 - prod(w$td(w,t), (1 - td(w,t)) ** x(w,t))));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_prob.prob,
    stat_x.x,
    comp_maxw.lam_maxw,
    comp_minw.lam_minw,
    etd.nu_etd,
    etdp.tetd,
    probe.nu_probe
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;