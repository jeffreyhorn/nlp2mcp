$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    c /pulplogs, sawlogs, residuals, pulp, sawnwood/
    cf(c) /pulp, sawnwood/
    cl(c) /pulplogs, sawlogs/
    s /nigra, brutia/
    k /good, medium, poor/
    at /'a-10', 'a-20', 'a-30', 'a-40', 'a-50', 'a-60', 'a-70', 'a-80'/
    p /'pulp-pl', 'pulp-sl', 'pulp-rs', sawing/
    m /'pulp-mill', 'saw-mill'/
    rhoset /'rho-03', 'rho-05', 'rho-07', 'rho-10'/
;

Parameters
    scd(k) /good 0.25, medium 0.5, poor 0.25/
    land(s) /nigra 143.679, brutia 227.58/
    ymf(at,k,s,cl)
    a(c,p) /pulplogs.'pulp-pl' -1.0, sawlogs.'pulp-pl' -1.0, sawlogs.'pulp-rs' -1.0, residuals.'pulp-sl' -1.0, residuals.'pulp-rs' 0.4, pulp.'pulp-pl' 0.207, pulp.'pulp-sl' 0.207, pulp.'pulp-rs' 0.207, sawnwood.'pulp-rs' 0.6, sawlogs.'pulp-sl' 0.0, sawlogs.sawing 0.0, pulplogs.'pulp-sl' 0.0, pulplogs.'pulp-rs' 0.0, pulplogs.sawing 0.0, residuals.'pulp-pl' 0.0, residuals.sawing 0.0, sawnwood.'pulp-pl' 0.0, sawnwood.'pulp-sl' 0.0, sawnwood.sawing 0.0, pulp.sawing 0.0/
    b(m,p) /'pulp-mill'.'pulp-pl' 1.0, 'pulp-mill'.'pulp-sl' 1.0, 'pulp-mill'.'pulp-rs' 1.0, 'saw-mill'.sawing 1.0, 'saw-mill'.'pulp-pl' 0.0, 'saw-mill'.'pulp-sl' 0.0, 'saw-mill'.'pulp-rs' 0.0, 'pulp-mill'.sawing 0.0/
    pc(p) /'pulp-pl' 5.96, 'pulp-sl' 5.96, 'pulp-rs' 5.96, sawing 6.0/
    pd(cf) /pulp 147.0, sawnwood 70.0/
    nu(m) /'pulp-mill' 37.8, 'saw-mill' 61.5/
    age(at)
    landcl(s,k)
    repr(cl,rhoset)
    reprp(s,k,rhoset)
    repsp(s,k,rhoset)
    rhoval(rhoset) /'rho-03' 0.03, 'rho-05' 0.05, 'rho-07' 0.07, 'rho-10' 0.1/
;

Scalars
    mup /150.0/
    muc /7.0/
    life /30.0/
    rho /nan/
;

age(at) = 10 * ord(at);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    r(c)
    h(m)
    phik
    phir
    phix
    phil
    phip
    phi
    nu_lbal(cl)
    nu_cap(m)
    nu_ainvc
    nu_aproc
    nu_asales
    nu_acutc
    nu_aplnt
;

Positive Variables
    v(s,k,at)
    z(p)
    x(c)
    lam_bal(c)
    lam_landc(s,k)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables are set to 1.

v.l(s,k,at) = 1;
z.l(p) = 1;
x.l(c) = 1;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_h(m)
    stat_phik
    stat_phil
    stat_phip
    stat_phir
    stat_phix
    stat_r(c)
    stat_v(s,k,at)
    stat_x(c)
    stat_z(p)
    comp_bal(c)
    comp_landc(s,k)
    acutc
    ainvc
    aplnt
    aproc
    asales
    benefit
    cap(m)
    lbal(cl)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_h(m).. ((-1) * nu_cap(m)) + ((-1) * (rho / (1 - (1 + rho) ** ((-1) * life)) * nu(m))) * nu_ainvc =E= 0;
stat_phik.. 1 + nu_ainvc =E= 0;
stat_phil.. 1 + nu_acutc =E= 0;
stat_phip.. 1 + nu_aplnt =E= 0;
stat_phir.. 1 + nu_aproc =E= 0;
stat_phix.. -1 + nu_asales =E= 0;
stat_r(c).. sum(cl, nu_lbal(cl)) + (((-1) * muc) * nu_acutc)$sameas(c, 'pulplogs') =E= 0;
stat_v(s,k,at).. sum(cl, ((-1) * ymf(at,k,s,cl)) * nu_lbal(cl)) + ((-1) * (mup * (1 + rho) ** age(at))) * nu_aplnt + age(at) * lam_landc(s,k) =E= 0;
stat_x(c).. sum(cf, ((-1) * pd(cf)) * nu_asales)$sameas(c, 'pulp') =E= 0;
stat_z(p).. sum(m, b(m,p) * nu_cap(m)) + ((-1) * pc(p)) * nu_aproc + sum(c, ((-1) * a(c,p)) * lam_bal(c)) =E= 0;

* Inequality complementarity equations
comp_bal(c).. sum(p, a(c,p) * z(p)) + r(c)$cl(c) - x(c)$cf(c) =G= 0;
comp_landc(s,k).. ((-1) * (sum(at, v(s,k,at) * age(at)) - land(s) * scd(k))) =G= 0;

* Original equality equations
lbal(cl).. r(cl) =E= sum((s,k,at), ymf(at,k,s,cl) * v(s,k,at));
cap(m).. sum(p, b(m,p) * z(p)) =E= h(m);
ainvc.. phik =E= rho / (1 - (1 + rho) ** ((-1) * life)) * sum(m, nu(m) * h(m));
aproc.. phir =E= sum(p, pc(p) * z(p));
asales.. phix =E= sum(cf, pd(cf) * x(cf));
acutc.. phil =E= muc * sum(cl, r(cl));
aplnt.. phip =E= mup * sum((s,k,at), v(s,k,at) * (1 + rho) ** age(at));
benefit.. phi =E= phix - phik - phir - phil - phip;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_h.h,
    stat_phik.phik,
    stat_phil.phil,
    stat_phip.phip,
    stat_phir.phir,
    stat_phix.phix,
    stat_r.r,
    stat_v.v,
    stat_x.x,
    stat_z.z,
    comp_bal.lam_bal,
    comp_landc.lam_landc,
    acutc.nu_acutc,
    ainvc.nu_ainvc,
    aplnt.nu_aplnt,
    aproc.nu_aproc,
    asales.nu_asales,
    benefit.phi,
    cap.nu_cap,
    lbal.nu_lbal
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = phi.l;
Display nlp2mcp_obj_val;