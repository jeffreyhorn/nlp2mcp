$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    t /y01, y02, y03, y04, y05, y06, y07, y08, y09, y10, y11, y12, y13, y14, y15, y16, y17, y18, y19, y20, y21, y22, y23, y24, y25, y26, y27, y28, y29, y30/
    a /a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24/
    m /jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec/
    mc(m) /jul, aug, sep, oct/
    i /'1', '2', '3', '4', '5', '6', '7', '8', '9'/
    c /maize, tobacco/
;

Parameters
    ld(*,m) /tobacco.jan 44.7, tobacco.feb 84.2, tobacco.mar 87.3, tobacco.apr 90.7, tobacco.may 20.5, tobacco.aug 37.3, tobacco.sep 44.7, tobacco.oct 19.7, tobacco.nov 46.4, maize.jan 46.7, maize.feb 10.0, maize.mar 13.0, maize.apr 16.7, maize.may 18.3, maize.oct 13.3, maize.nov 33.3, 'timber-1'.jan 10.0, 'timber-1'.mar 3.0, 'timber-1'.may 10.0, 'timber-1'.aug 1.0, 'timber-1'.sep 7.0, 'timber-1'.oct 8.0, 'timber-1'.nov 9.0, 'timber-2'.jan 7.0, 'timber-2'.may 10.0, 'timber-2'.aug 1.0, other.jan 10.0, other.feb 8.0, other.mar 12.0, other.apr 10.0, other.may 4.0, other.jun 2.0, other.sep 10.0, other.oct 28.0, other.nov 24.0, 'timber-1'.feb 0.0, 'timber-1'.apr 0.0, 'timber-1'.jun 0.0, 'timber-1'.jul 0.0, 'timber-1'.dec 0.0, 'timber-2'.feb 0.0, 'timber-2'.mar 0.0, 'timber-2'.apr 0.0, 'timber-2'.jun 0.0, 'timber-2'.jul 0.0, 'timber-2'.sep 0.0, 'timber-2'.oct 0.0, 'timber-2'.nov 0.0, 'timber-2'.dec 0.0, other.jul 0.0, other.aug 0.0, other.dec 0.0, tobacco.jun 0.0, tobacco.jul 0.0, tobacco.dec 0.0, maize.jun 0.0, maize.jul 0.0, maize.aug 0.0, maize.sep 0.0, maize.dec 0.0/
    tmd(*,c) /'input-cost'.tobacco 2000.0, 'input-cost'.maize 20.0, yield.tobacco 675.0, yield.maize 750.0, price.tobacco 8.4, price.maize 0.8/
    yv(a) /a08 120.0, a16 120.0, a24 120.0/
    vr(t)
    labor(m)
    fa(i)
    dist(i)
    labw(i)
    cc(c)
    yc(c)
    pc(c)
    cr(c)
    delt(t)
    delta(a)
;

Scalars
    nfam /400.0/
    sfam /3.0/
    resw /0.5/
    fdmaize /650.0/
    tob /234.0/
    sr /5.0/
    width /1.0/
    ws /5.0/
    whd /10.0/
    wdm /25.0/
    tr /1.31/
    tc /349.0/
    wrc /46.75/
    dwr /10.0/
    labwc /1.0/
    labvc /0.5/
    yw /40.0/
    rho /0.1/
    matr /0.25/
    dmaize /0.0/
    wr /0.0/
;

dmaize = fdmaize * nfam;
wr = tob * wrc + dwr * nfam;
vr(t) = tr * sr * sum(a$(ord(t) + ord(a) > card(t)), yv(a) * delta(a));
labor(m) = nfam * (sfam * wdm - ld("other",m));
fa(i) = 100 * 3.1416 * dist(i) * width;
dist(i) = sr - width / 2 + width * ord(i);
labw(i) = yw * labwc * whd / (whd - 2 * dist(i) / ws);
cc(c) = tmd("input-cost",c);
yc(c) = tmd("yield",c);
pc(c) = tmd("price",c);
cr(c) = yc(c) * pc(c);
delt(t) = (1 + rho) ** ((-1) * (ord(t)));
delta(a) = (1 + rho) ** ((-1) * (ord(a)));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    rev(t)
    cost(t)
    income
    nu_lw(t)
    nu_rd(t)
    nu_cd(t)
;

Positive Variables
    w(t,i)
    v(t)
    x(t,c)
    mat(t)
    lc(t,m)
    lam_wb(t)
    lam_wa(i)
    lam_lb(t,m)
    lam_mm(t)
    lam_matd1(t)
    lam_matd2(t)
    piU_mat_y01
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables are set to 1.

w.l(t,i) = 1;
v.l(t) = 1;
x.l(t,c) = 1;
mat.l(t) = 1;
lc.l(t,m) = 1;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_cost(t)
    stat_lc(t,m)
    stat_mat_y01
    stat_mat_y02
    stat_mat_y03
    stat_mat_y04
    stat_mat_y05
    stat_mat_y06
    stat_mat_y07
    stat_mat_y08
    stat_mat_y09
    stat_mat_y10
    stat_mat_y11
    stat_mat_y12
    stat_mat_y13
    stat_mat_y14
    stat_mat_y15
    stat_mat_y16
    stat_mat_y17
    stat_mat_y18
    stat_mat_y19
    stat_mat_y20
    stat_mat_y21
    stat_mat_y22
    stat_mat_y23
    stat_mat_y24
    stat_mat_y25
    stat_mat_y26
    stat_mat_y27
    stat_mat_y28
    stat_mat_y29
    stat_mat_y30
    stat_rev(t)
    stat_v(t)
    stat_w(t,i)
    stat_x(t,c)
    comp_lb(t,m)
    comp_matd1(t)
    comp_matd2(t)
    comp_mm(t)
    comp_wa(i)
    comp_wb(t)
    comp_up_mat_y01
    cd(t)
    lw(t)
    od
    rd(t)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_cost(t).. ((-1) * (delt(t) * (-1))) + nu_cd(t) =E= 0;
stat_lc(t,m).. nu_lw(t) + ((-1) * (1000 * resw * whd / 1000000)) * nu_cd(t) =E= 0;
stat_mat_y01.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) + piU_mat_y01 =E= 0;
stat_mat_y02.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y03.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y04.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y05.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y06.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y07.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y08.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y09.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y10.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y11.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y12.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y13.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y14.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y15.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y16.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y17.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y18.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y19.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y20.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y21.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y22.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y23.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y24.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y25.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y26.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y27.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y28.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y29.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_mat_y30.. sum(t, ((-1) * (1000 * matr * cr(c) / 1000000)) * nu_rd(t)) + sum(t, ((-1) * (yc(c) * matr)) * lam_mm(t)) + sum(t, lam_matd1(t)) + sum(t, lam_matd2(t)) =E= 0;
stat_rev(t).. ((-1) * delt(t)) + nu_rd(t) =E= 0;
stat_v(t).. ((-1) * (delt(t) * 1000 * vr(t) / 1000000)) + ((-1) * (1000 * tc / 1000000)) * nu_cd(t) + sum(m, ld("timber-1",m) * lam_lb(t,m)) =E= 0;
stat_w(t,i).. ((-1) * labw(i)) * nu_lw(t) + ((-1) * (1000 * tr * yw * dist(i) / 1000000)) * nu_cd(t) + ((-1) * yw) * lam_wb(t) + lam_wa(i) =E= 0;
stat_x(t,c).. ((-1) * (1000 * cr(c) / 1000000)) * nu_rd(t) + ((-1) * (1000 * cc(c) / 1000000)) * nu_cd(t) + sum(m, ld(c,m) * lam_lb(t,m)) =E= 0;

* Inequality complementarity equations
comp_lb(t,m)$(ord(t) > 1).. ((-1) * (ld("timber-1",m) * v(t) + ld("timber-2",m) * v(t-1) + sum(c, ld(c,m) * x(t,c)) + lc(t,m)$mc(m) - labor(m))) =G= 0;
comp_matd1(t)$(ord(t) > 1).. ((-1) * (mat(t) - x(t-1,"tobacco"))) =G= 0;
comp_matd2(t).. ((-1) * (mat(t) - x(t,"maize"))) =G= 0;
comp_mm(t).. yc("maize") * (x(t,"maize") + matr * mat(t)) - dmaize =G= 0;
comp_wa(i).. ((-1) * (sum(t, w(t,i)) - fa(i))) =G= 0;
comp_wb(t).. yw * sum(i, w(t,i)) + sum(a, yv(a) * v(t-ord(a))) - (wrc * x(t,"tobacco") + dwr * nfam) =G= 0;

* Upper bound complementarity equations
comp_up_mat_y01.. 234 - mat("y01") =G= 0;

* Original equality equations
lw(t).. sum(mc, lc(t,mc)) =E= sum(i, labw(i) * w(t,i)) + sum(a, labvc * yv(a) * v(t-ord(a)));
rd(t).. rev(t) =E= (sum(c, cr(c) * x(t,c)) + matr * cr("maize") * mat(t)) / 1000;
cd(t).. cost(t) =E= (sum(c, cc(c) * x(t,c)) + tc * v(t) + resw * whd * sum(mc, lc(t,mc)) + sum(i, tr * yw * dist(i) * w(t,i))) / 1000;
od.. income =E= sum(t, delt(t) * (rev(t) - cost(t) + vr(t) * v(t) / 1000));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_cost.cost,
    stat_lc.lc,
    stat_mat_y01.mat,
    stat_mat_y02.mat,
    stat_mat_y03.mat,
    stat_mat_y04.mat,
    stat_mat_y05.mat,
    stat_mat_y06.mat,
    stat_mat_y07.mat,
    stat_mat_y08.mat,
    stat_mat_y09.mat,
    stat_mat_y10.mat,
    stat_mat_y11.mat,
    stat_mat_y12.mat,
    stat_mat_y13.mat,
    stat_mat_y14.mat,
    stat_mat_y15.mat,
    stat_mat_y16.mat,
    stat_mat_y17.mat,
    stat_mat_y18.mat,
    stat_mat_y19.mat,
    stat_mat_y20.mat,
    stat_mat_y21.mat,
    stat_mat_y22.mat,
    stat_mat_y23.mat,
    stat_mat_y24.mat,
    stat_mat_y25.mat,
    stat_mat_y26.mat,
    stat_mat_y27.mat,
    stat_mat_y28.mat,
    stat_mat_y29.mat,
    stat_mat_y30.mat,
    stat_rev.rev,
    stat_v.v,
    stat_w.w,
    stat_x.x,
    comp_lb.lam_lb,
    comp_matd1.lam_matd1,
    comp_matd2.lam_matd2,
    comp_mm.lam_mm,
    comp_wa.lam_wa,
    comp_wb.lam_wb,
    cd.nu_cd,
    lw.nu_lw,
    od.income,
    rd.nu_rd,
    comp_up_mat_y01.piU_mat_y01
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = income.l;
Display nlp2mcp_obj_val;