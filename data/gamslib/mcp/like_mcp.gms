$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /'1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31'/
    g /one, two, three/
;

Parameters
    data(*,i) /pressure.'1' 95.0, pressure.'2' 105.0, pressure.'3' 110.0, pressure.'4' 115.0, pressure.'5' 120.0, pressure.'6' 125.0, pressure.'7' 130.0, pressure.'8' 135.0, pressure.'9' 140.0, pressure.'10' 145.0, pressure.'11' 150.0, pressure.'12' 155.0, pressure.'13' 160.0, pressure.'14' 165.0, pressure.'15' 170.0, frequency.'1' 1.0, frequency.'2' 1.0, frequency.'3' 4.0, frequency.'4' 4.0, frequency.'5' 15.0, frequency.'6' 15.0, frequency.'7' 15.0, frequency.'8' 13.0, frequency.'9' 21.0, frequency.'10' 12.0, frequency.'11' 17.0, frequency.'12' 4.0, frequency.'13' 20.0, frequency.'14' 8.0, frequency.'15' 17.0, pressure.'16' 175.0, pressure.'17' 180.0, pressure.'18' 185.0, pressure.'19' 190.0, pressure.'20' 195.0, pressure.'21' 200.0, pressure.'22' 205.0, pressure.'23' 210.0, pressure.'24' 215.0, pressure.'25' 220.0, pressure.'26' 225.0, pressure.'27' 230.0, pressure.'28' 235.0, pressure.'29' 240.0, pressure.'30' 245.0, pressure.'31' 260.0, frequency.'16' 8.0, frequency.'17' 6.0, frequency.'18' 6.0, frequency.'19' 7.0, frequency.'20' 4.0, frequency.'21' 3.0, frequency.'22' 3.0, frequency.'23' 8.0, frequency.'24' 1.0, frequency.'25' 6.0, frequency.'26' 0.0, frequency.'27' 5.0, frequency.'28' 1.0, frequency.'29' 7.0, frequency.'30' 1.0, frequency.'31' 2.0/
    y(i)
    w(i)
;

Scalars
    c /0.0/
;

y(i) = data("pressure",i);
w(i) = data("frequency",i);
c = 1 / sqrt(2 * 3.14159);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    mlf
    nu_pdef
;

Positive Variables
    p(g)
    m(g)
    s(g)
    lam_rank(g)
    piL_p(g)
    piL_s(g)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1.

p.l("one") = 0.1;
p.l("two") = 0.1;
p.l("three") = 0.1;
p.l(g) = min(max(p.l(g), 1e-6), p.up(g));
m.l(g) = 1;
s.l("one") = 15.0;
s.l("two") = 15.0;
s.l("three") = 15.0;
s.l(g) = min(max(s.l(g), 1e-6), s.up(g));

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_m(g)
    stat_p(g)
    stat_s(g)
    comp_rank(g)
    comp_lo_p(g)
    comp_lo_s(g)
    like
    pdef
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(g, g__);

* Stationarity equations
stat_m(g).. ((-1) * sum(i, w(i) * 1 / (c * sum(g__, p(g__) / s(g__) * exp((-0.5) * sqr((y(i) - m(g__)) / s(g__))))) * c * p(g) / s(g) * exp((-0.5) * sqr((y(i) - m(g)) / s(g))) * (-0.5) * 2 * (y(i) - m(g)) / s(g) * s(g) * (-1) / s(g) ** 2)) + lam_rank(g) =E= 0;
stat_p(g).. ((-1) * sum(i, w(i) * 1 / (c * sum(g__, p(g__) / s(g__) * exp((-0.5) * sqr((y(i) - m(g__)) / s(g__))))) * c * exp((-0.5) * sqr((y(i) - m(g)) / s(g))) * 1 / s(g) ** 1)) + nu_pdef - piL_p(g) =E= 0;
stat_s(g).. ((-1) * sum(i, w(i) * 1 / (c * sum(g__, p(g__) / s(g__) * exp((-0.5) * sqr((y(i) - m(g__)) / s(g__))))) * c * (exp((-0.5) * sqr((y(i) - m(g)) / s(g))) * ((-1) * p(g)) / s(g) ** 2 - p(g) / s(g) * exp((-0.5) * sqr((y(i) - m(g)) / s(g))) * (y(i) - m(g)) / s(g) * ((-1) * (y(i) - m(g))) / s(g) ** 2))) - piL_s(g) =E= 0;

* Inequality complementarity equations
comp_rank(g)$(ord(g) <= card(g) - 1).. m(g+1) - m(g) =G= 0;

* Lower bound complementarity equations
comp_lo_p(g).. p(g) - 0.1 =G= 0;
comp_lo_s(g).. s(g) - 0.1 =G= 0;

* Original equality equations
like.. mlf =E= sum(i, w(i) * log(c * sum(g, p(g) / s(g) * exp((-0.5) * sqr((y(i) - m(g)) / s(g))))));
pdef.. sum(g, p(g)) =E= 1;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_m.m,
    stat_p.p,
    stat_s.s,
    comp_rank.lam_rank,
    like.mlf,
    pdef.nu_pdef,
    comp_lo_p.piL_p,
    comp_lo_s.piL_s
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = mlf.l;
Display nlp2mcp_obj_val;