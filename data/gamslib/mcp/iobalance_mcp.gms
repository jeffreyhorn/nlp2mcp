$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /'1', '2', '3'/
;

Alias(i, j);

Parameters
    a0(i,j)
    z1(i,j)
    x(j) /'1' 421.0, '2' 284.0, '3' 283.0/
    u(i)
    v(j)
    a1(i,j)
    r(i) /'1' 1.0, '2' 1.0, '3' 1.0/
    s(j) /'1' 1.0, '2' 1.0, '3' 1.0/
    report(*,i,j)
    zbar(i,j)
;

Scalars
    oldr /0.0/
    olds /0.0/
    maxdelta /1.0/
;

u(i) = sum(j, z1(i,j));
v(j) = sum(i, z1(i,j));
a1(i,j) = z1(i,j) / x(j);
zbar(i,j) = a0(i,j) * x(j);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    obj
    zv(i,j)
    nu_colbal(j)
    nu_colbalz(j)
    nu_defobjentz
    nu_defabs(i,j)
    nu_defmad
    nu_defmade
    nu_defLinf
    nu_defsd
    nu_defrsd
;

Positive Variables
    a(i,j)
    ap(i,j)
    an(i,j)
    amax
    lam_defmaxp(i,j)
    lam_defmaxn(i,j)
    piL_a(i,j)
    piL_zv(i,j)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound). Others are set to 1.

a.l("1","1") = 1e-05;
a.l("1","2") = 1e-05;
a.l("1","3") = 1e-05;
a.l("2","1") = 1e-05;
a.l("2","2") = 1e-05;
a.l("2","3") = 1e-05;
a.l("3","1") = 1e-05;
a.l("3","2") = 1e-05;
a.l("3","3") = 1e-05;
a.l(i,j) = min(max(a.l(i,j), 1e-6), a.up(i,j));
zv.l("1","1") = 1.0;
zv.l("1","2") = 1.0;
zv.l("1","3") = 1.0;
zv.l("2","1") = 1.0;
zv.l("2","2") = 1.0;
zv.l("2","3") = 1.0;
zv.l("3","1") = 1.0;
zv.l("3","2") = 1.0;
zv.l("3","3") = 1.0;
ap.l(i,j) = 1;
an.l(i,j) = 1;
amax.l = 1;

* ============================================
* Post-solve Calibration (variable .l references)
* ============================================

$onImplicitAssign
report("A0",i,j) = a0(i,j);
report("A1",i,j) = a1(i,j);
report("RAS",i,j) = r(i) * a0(i,j) * s(j);
report("Entropy",i,j) = a.l(i,j);
report("EntropyZ",i,j) = zv.l(i,j) / x(j);
report("MAD",i,j) = a.l(i,j);
report("MADE",i,j) = a.l(i,j);
report("Linf",i,j) = a.l(i,j);
report("SD",i,j) = a.l(i,j);
report("RSD",i,j) = a.l(i,j);
$offImplicitAssign

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_a(i,j)
    stat_amax
    stat_an(i,j)
    stat_ap(i,j)
    stat_zv(i,j)
    comp_defmaxn(i,j)
    comp_defmaxp(i,j)
    comp_lo_a(i,j)
    comp_lo_zv(i,j)
    colbal(j)
    colbalz(j)
    defLinf
    defabs(i,j)
    defmad
    defmade
    defobjent
    defobjentz
    defrsd
    defsd
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_a(i,j).. log(a(i,i) / a0(i,j)) * x(j) + x(j) * a(i,i) * 1 / (a(i,i) / a0(i,j)) * 1 / a0(i,j) ** 1 + x(j) * nu_colbal(j) + nu_defabs(i,j) + ((-1) * (2 * (a(i,i) + a0(i,j)))) * nu_defsd + ((-1) * (a0(i,j) * 2 * (a(i,i) + a0(i,j)) / a0(i,j) ** 2)) * nu_defrsd + lam_defmaxp(i,j) - lam_defmaxn(i,j) - piL_a(i,j) =E= 0;
stat_amax.. ((-1) * nu_defLinf) + sum((i,j), (-1) * lam_defmaxp(i,j)) + sum((i,j), (-1) * lam_defmaxn(i,j)) =E= 0;
stat_an(i,j).. nu_defabs(i,j) + ((-1) * (1 / sqr(card(i)))) * nu_defmad + ((-1) * (100 / sqr(card(i)) * 1 / a0(i,j) ** 1)) * nu_defmade =E= 0;
stat_ap(i,j).. ((-1) * nu_defabs(i,j)) + ((-1) * (1 / sqr(card(i)))) * nu_defmad + ((-1) * (100 / sqr(card(i)) * 1 / a0(i,j) ** 1)) * nu_defmade =E= 0;
stat_zv(i,j).. nu_colbalz(j) + ((-1) * (log(zv(i,i) / zbar(i,j)) + zv(i,i) * 1 / (zv(i,i) / zbar(i,j)) * 1 / zbar(i,j) ** 1)) * nu_defobjentz - piL_zv(i,j) =E= 0;

* Inequality complementarity equations
comp_defmaxn(i,j).. a(i,j) - a0(i,j) - ((-1) * amax) =G= 0;
comp_defmaxp(i,j).. ((-1) * (a(i,j) - a0(i,j) - amax)) =G= 0;

* Lower bound complementarity equations
comp_lo_a(i,j).. a(i,j) - 1e-05 =G= 0;
comp_lo_zv(i,j).. zv(i,j) - 1 =G= 0;

* Original equality equations
colbal(j).. sum(i, a(i,j) * x(j)) =E= v(j);
defobjent.. obj =E= sum((i,j), x(j) * a(i,j) * log(a(i,j) / a0(i,j)));
colbalz(j).. sum(i, zv(i,j)) =E= v(j);
defobjentz.. obj =E= sum((i,j), zv(i,j) * log(zv(i,j) / zbar(i,j)));
defabs(i,j).. a(i,j) - a0(i,j) =E= ap(i,j) - an(i,j);
defmad.. obj =E= 1 / sqr(card(i)) * sum((i,j), ap(i,j) + an(i,j));
defmade.. obj =E= 100 / sqr(card(i)) * sum((i,j), (ap(i,j) + an(i,j)) / a0(i,j));
defLinf.. obj =E= amax;
defsd.. obj =E= sum((i,j), sqr(a(i,j) + a0(i,j)));
defrsd.. obj =E= sum((i,j), sqr(a(i,j) + a0(i,j)) / a0(i,j));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_a.a,
    stat_amax.amax,
    stat_an.an,
    stat_ap.ap,
    stat_zv.zv,
    comp_defmaxn.lam_defmaxn,
    comp_defmaxp.lam_defmaxp,
    colbal.nu_colbal,
    colbalz.nu_colbalz,
    defLinf.nu_defLinf,
    defabs.nu_defabs,
    defmad.nu_defmad,
    defmade.nu_defmade,
    defobjent.obj,
    defobjentz.nu_defobjentz,
    defrsd.nu_defrsd,
    defsd.nu_defsd,
    comp_lo_a.piL_a,
    comp_lo_zv.piL_zv
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = obj.l;
Display nlp2mcp_obj_val;