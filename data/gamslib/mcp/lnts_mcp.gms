$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    h /h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23, h24, h25, h26, h27, h28, h29, h30, h31, h32, h33, h34, h35, h36, h37, h38, h39, h40, h41, h42, h43, h44, h45, h46, h47, h48, h49, h50/
    c /y1, y2, y3, y4/
;

Scalars
    nh /50.0/
    a /100.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    u(h)
    y(c,h)
    tf
    nu_pos_eqn(c,h)
    nu_velo1_eqn(h)
    nu_velo2_eqn(h)
    nu_y_fx_y1_h0
    nu_y_fx_y2_h0
    nu_y_fx_y3_h0
    nu_y_fx_y4_h0
    nu_y_fx_y2_h50
    nu_y_fx_y3_h50
    nu_y_fx_y4_h50
;

Positive Variables
    step
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables with explicit .l values are
* clamped to min(max(value, 1e-6), upper_bound).

y.l("y2",h) = 5 * (ord(h) - 1) / nh;
y.l("y3",h) = 45 * (ord(h) - 1) / nh;
step.l = 1 / nh;
step.l = min(max(step.l, 1e-6), step.up);

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_step
    stat_u(h)
    stat_y(c,h)
    pos_eqn(c,h)
    tf_eqn
    velo1_eqn(h)
    velo2_eqn(h)
    y_fx_y1_h0
    y_fx_y2_h0
    y_fx_y2_h50
    y_fx_y3_h0
    y_fx_y3_h50
    y_fx_y4_h0
    y_fx_y4_h50
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_step.. nh + sum((c,h), ((-1) * (2 * y(c,h) * 0.5)) * nu_pos_eqn(c,h)) + sum(h, ((-1) * (2 * a * cos(u(h)) * 0.5)) * nu_velo1_eqn(h)) + sum(h, ((-1) * (2 * a * sin(u(h)) * 0.5)) * nu_velo2_eqn(h)) =E= 0;
stat_u(h).. ((-1) * (0.5 * step * a * ((-1) * (sin(u(h)))))) * nu_velo1_eqn(h) + ((-1) * (0.5 * step * a * cos(u(h)))) * nu_velo2_eqn(h) =E= 0;
stat_y(c,h).. ((-1) * nu_pos_eqn(c,h)) + nu_y_fx_y1_h0$(sameas(c, 'y1') and sameas(h, 'h0')) + nu_y_fx_y2_h0$(sameas(c, 'y2') and sameas(h, 'h0')) + nu_y_fx_y2_h50$(sameas(c, 'y2') and sameas(h, 'h50')) + nu_y_fx_y3_h0$(sameas(c, 'y3') and sameas(h, 'h0')) + nu_y_fx_y3_h50$(sameas(c, 'y3') and sameas(h, 'h50')) + nu_y_fx_y4_h0$(sameas(c, 'y4') and sameas(h, 'h0')) + nu_y_fx_y4_h50$(sameas(c, 'y4') and sameas(h, 'h50')) =E= 0;

* Original equality equations
tf_eqn.. tf =E= step * nh;
pos_eqn(c,h)$((ord(c) <= card(c) - 2) and (ord(h) <= card(h) - 1)).. y(c,h+1) =E= y(c,h) + 0.5 * step * (y(c+2,h) + y(c+2,h+1));
velo1_eqn(h)$(ord(h) <= card(h) - 1).. y("y3",h+1) =E= y("y3",h) + 0.5 * step * (a * cos(u(h)) + a * cos(u(h+1)));
velo2_eqn(h)$(ord(h) <= card(h) - 1).. y("y4",h+1) =E= y("y4",h) + 0.5 * step * (a * sin(u(h)) + a * sin(u(h+1)));
y_fx_y1_h0.. y("y1","h0") - 0 =E= 0;
y_fx_y2_h0.. y("y2","h0") - 0 =E= 0;
y_fx_y3_h0.. y("y3","h0") - 0 =E= 0;
y_fx_y4_h0.. y("y4","h0") - 0 =E= 0;
y_fx_y2_h50.. y("y2","h50") - 5 =E= 0;
y_fx_y3_h50.. y("y3","h50") - 45 =E= 0;
y_fx_y4_h50.. y("y4","h50") - 0 =E= 0;


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

nu_pos_eqn.fx(c,h)$(not ((ord(c) <= card(c) - 2) and (ord(h) <= card(h) - 1))) = 0;
nu_velo1_eqn.fx(h)$(not (ord(h) <= card(h) - 1)) = 0;
nu_velo2_eqn.fx(h)$(not (ord(h) <= card(h) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_step.step,
    stat_u.u,
    stat_y.y,
    pos_eqn.nu_pos_eqn,
    tf_eqn.tf,
    velo1_eqn.nu_velo1_eqn,
    velo2_eqn.nu_velo2_eqn,
    y_fx_y1_h0.nu_y_fx_y1_h0,
    y_fx_y2_h0.nu_y_fx_y2_h0,
    y_fx_y2_h50.nu_y_fx_y2_h50,
    y_fx_y3_h0.nu_y_fx_y3_h0,
    y_fx_y3_h50.nu_y_fx_y3_h50,
    y_fx_y4_h0.nu_y_fx_y4_h0,
    y_fx_y4_h50.nu_y_fx_y4_h50
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = tf.l;
Display nlp2mcp_obj_val;