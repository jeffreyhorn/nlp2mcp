$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    u /BRD, MLK, CAP, LAB, IDT, TRF, HOH, GOV, INV, EXT/
    i(u) /BRD, MLK/
    h(u) /CAP, LAB/
;

Alias(u, v);
Alias(i, j);
Alias(h, k);

Parameters
    SAM(u,v) /BRD.BRD 21.0, BRD.MLK 8.0, BRD.HOH 20.0, BRD.GOV 19.0, BRD.INV 16.0, BRD.EXT 8.0, MLK.BRD 17.0, MLK.MLK 9.0, MLK.HOH 30.0, MLK.GOV 14.0, MLK.INV 15.0, MLK.EXT 4.0, CAP.BRD 20.0, CAP.MLK 30.0, LAB.BRD 15.0, LAB.MLK 25.0, IDT.BRD 5.0, IDT.MLK 4.0, TRF.BRD 1.0, TRF.MLK 2.0, HOH.CAP 50.0, HOH.LAB 40.0, GOV.IDT 9.0, GOV.TRF 3.0, GOV.HOH 23.0, INV.HOH 17.0, INV.GOV 2.0, INV.EXT 12.0, EXT.BRD 13.0, EXT.MLK 11.0, IDT.CAP 0.0, IDT.LAB 0.0, IDT.IDT 0.0, IDT.TRF 0.0, IDT.HOH 0.0, IDT.GOV 0.0, IDT.INV 0.0, IDT.EXT 0.0, GOV.BRD 0.0, GOV.MLK 0.0, GOV.CAP 0.0, GOV.LAB 0.0, GOV.GOV 0.0, GOV.INV 0.0, GOV.EXT 0.0, HOH.BRD 0.0, HOH.MLK 0.0, HOH.IDT 0.0, HOH.TRF 0.0, HOH.HOH 0.0, HOH.GOV 0.0, HOH.INV 0.0, HOH.EXT 0.0, INV.BRD 0.0, INV.MLK 0.0, INV.CAP 0.0, INV.LAB 0.0, INV.IDT 0.0, INV.TRF 0.0, INV.INV 0.0, LAB.CAP 0.0, LAB.LAB 0.0, LAB.IDT 0.0, LAB.TRF 0.0, LAB.HOH 0.0, LAB.GOV 0.0, LAB.INV 0.0, LAB.EXT 0.0, EXT.CAP 0.0, EXT.LAB 0.0, EXT.IDT 0.0, EXT.TRF 0.0, EXT.HOH 0.0, EXT.GOV 0.0, EXT.INV 0.0, EXT.EXT 0.0, CAP.CAP 0.0, CAP.LAB 0.0, CAP.IDT 0.0, CAP.TRF 0.0, CAP.HOH 0.0, CAP.GOV 0.0, CAP.INV 0.0, CAP.EXT 0.0, MLK.CAP 0.0, MLK.LAB 0.0, MLK.IDT 0.0, MLK.TRF 0.0, BRD.CAP 0.0, BRD.LAB 0.0, BRD.IDT 0.0, BRD.TRF 0.0, TRF.CAP 0.0, TRF.LAB 0.0, TRF.IDT 0.0, TRF.TRF 0.0, TRF.HOH 0.0, TRF.GOV 0.0, TRF.INV 0.0, TRF.EXT 0.0/
    nu(i) /BRD 0.1, MLK 0.1/
    Y0(j)
    F0(h,j)
    FC(j)
    X0(i,j)
    Z0(j)
    Xp0(i)
    Xg0(i)
    Xv0(i)
    E0(i)
    M0(i)
    Q0(i)
    D0(i)
    Tz0(j)
    Tm0(j)
    FF(h)
    pWe(i) /BRD 1.0, MLK 1.0/
    pWm(i) /BRD 1.0, MLK 1.0/
    tauz(i)
    taum(i) /BRD 0.0, MLK 0.0/
    sigma(i) /BRD 2.0, MLK 2.0/
    psi(i) /BRD 2.0, MLK 2.0/
    eta(i)
    phi(i)
    alpha(i)
    beta(h,j)
    b(j)
    ax(i,j)
    ay(j)
    mu(i)
    lambda(i)
    deltam(i)
    deltad(i)
    gamma(i)
    xid(i)
    xie(i)
    theta(i)
    dY(j)
    dF(h,j)
    dX(i,j)
    dZ(j)
    dXp(i)
    dXg(i)
    dXv(i)
    dE(i)
    dM(i)
    dQ(i)
    dD(i)
    dpf(h)
    dpy(j)
    dpz(i)
    dpq(i)
    dpe(i)
    dpm(i)
    dpd(i)
    dTz(i)
    dTm(i)
;

Scalars
    Sp0 /0.0/
    Sg0 /0.0/
    Td0 /0.0/
    Sf /0.0/
    ssp /0.0/
    ssg /0.0/
    taud /0.0/
    depsilon /0.0/
    dTd /0.0/
    dSp /0.0/
    dSg /0.0/
    UU0 /0.0/
    ep0 /0.0/
    ep1 /0.0/
    EV /0.0/
;

Y0(j) = sum(h, F0(h,j));
F0(h,j) = ((1 - nu(j)) * SAM(h,j))$(ord(h) = 1) + SAM(h,j)$(ord(h) <> 1);
FC(j) = nu(j) * SAM("CAP",j);
X0(i,j) = SAM(i,j);
Z0(j) = Y0(j) + sum(i, X0(i,j)) + FC(j);
Xp0(i) = SAM(i,"HOH");
Xg0(i) = SAM(i,"GOV");
Xv0(i) = SAM(i,"INV");
E0(i) = SAM(i,"EXT");
M0(i) = SAM("EXT",i);
Q0(i) = Xp0(i) + Xg0(i) + Xv0(i) + sum(j, X0(i,j));
D0(i) = (1 + tauz(i)) * Z0(i) - E0(i);
Sp0 = SAM("INV","HOH");
Sg0 = SAM("INV","GOV");
Td0 = SAM("GOV","HOH");
Tz0(j) = SAM("IDT",j);
Tm0(j) = SAM("TRF","J");
FF(h) = sum(j, F0(h,j));
Sf = SAM("INV","EXT");
tauz(j) = Tz0(j) / Z0(j);
taum(j) = Tm0(j) / M0(j);
eta(i) = (sigma(i) - 1) / sigma(i);
phi(i) = (psi(i) + 1) / psi(i);
alpha(i) = Xp0(i) / sum(j, Xp0(j));
beta(h,j) = F0(h,j) / sum(k, F0(k,j));
b(j) = Y0(j) / prod(h, F0(h,j) ** beta(h,j));
ax(i,j) = X0(i,j) / Z0(j);
ay(j) = Y0(j) / Z0(j);
mu(i) = Xg0(i) / sum(j, Xg0(j));
lambda(i) = Xv0(i) / (Sp0 + Sg0 + Sf);
deltam(i) = (1 + taum(i)) * M0(i) ** (1 - eta(i)) / ((1 + taum(i)) * M0(i) ** (1 - eta(i)) + D0(i) ** (1 - eta(i)));
deltad(i) = D0(i) ** (1 - eta(i)) / ((1 + taum(i)) * M0(i) ** (1 - eta(i)) + D0(i) ** (1 - eta(i)));
gamma(i) = Q0(i) / (deltam(i) * M0(i) ** eta(i) + deltad(i) * D0(i) ** eta(i)) ** (1 / eta(i));
xid(i) = D0(i) ** (1 - phi(i)) / (E0(i) ** (1 - phi(i)) + D0(i) ** (1 - phi(i)));
xie(i) = E0(i) ** (1 - phi(i)) / (E0(i) ** (1 - phi(i)) + D0(i) ** (1 - phi(i)));
theta(i) = Z0(i) / (xie(i) * E0(i) ** phi(i) + xid(i) * D0(i) ** phi(i)) ** (1 / phi(i));
ssp = Sp0 / (sum(h, FF(h)) + sum(j, FC(j)));
ssg = Sg0 / (Td0 + sum(j, Tz0(j)) + sum(j, Tm0(j)));
taud = Td0 / (sum(h, FF(h)) + sum(j, FC(j)));
UU0 = prod(i, Xp0(i) ** alpha(i));
ep0 = UU0 / prod(i, (alpha(i) / 1) ** alpha(i));
EV = ep1 - ep0;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    Y(j)
    F(h,j)
    X(i,j)
    Z(j)
    Xp(i)
    Xg(i)
    Xv(i)
    E(i)
    M(i)
    Q(i)
    D(i)
    pf(h)
    py(j)
    pz(j)
    pq(i)
    pe(i)
    pm(i)
    pd(i)
    epsilon
    Sp
    Sg
    Td
    Tz(j)
    Tm(i)
    UU
    nu_eqpy(j)
    nu_eqX(i,j)
    nu_eqY(j)
    nu_eqF(h,j)
    nu_eqpzs(j)
    nu_eqTd
    nu_eqTz(j)
    nu_eqTm(i)
    nu_eqXg(i)
    nu_eqXv(i)
    nu_eqSp
    nu_eqSg
    nu_eqXp(i)
    nu_eqpe(i)
    nu_eqpm(i)
    nu_eqepsilon
    nu_eqpqs(i)
    nu_eqM(i)
    nu_eqD(i)
    nu_eqpzd(i)
    nu_eqE(i)
    nu_eqDs(i)
    nu_eqpqd(i)
    nu_eqpf(h)
    nu_pf_fx_LAB
;

Positive Variables
    piL_y(j)
    piL_f(h,j)
    piL_x(i,j)
    piL_z(j)
    piL_xp(i)
    piL_xg(i)
    piL_xv(i)
    piL_e(i)
    piL_m(i)
    piL_q(i)
    piL_d(i)
    piL_pf(h)
    piL_py(j)
    piL_pz(j)
    piL_pq(i)
    piL_pe(i)
    piL_pm(i)
    piL_pd(i)
    piL_epsilon
    piL_sp
    piL_sg
    piL_td
    piL_tz(j)
    piL_tm(i)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

Y.l("BRD") = 1e-05;
Y.l("MLK") = 1e-05;
X.l("BRD","BRD") = 1e-05;
X.l("BRD","MLK") = 1e-05;
X.l("MLK","BRD") = 1e-05;
X.l("MLK","MLK") = 1e-05;
Z.l("BRD") = 1e-05;
Z.l("MLK") = 1e-05;
Xp.l("BRD") = 1e-05;
Xp.l("MLK") = 1e-05;
Xg.l("BRD") = 1e-05;
Xg.l("MLK") = 1e-05;
Xv.l("BRD") = 1e-05;
Xv.l("MLK") = 1e-05;
E.l("BRD") = 1e-05;
E.l("MLK") = 1e-05;
M.l("BRD") = 1e-05;
M.l("MLK") = 1e-05;
Q.l("BRD") = 1e-05;
Q.l("MLK") = 1e-05;
D.l("BRD") = 1e-05;
D.l("MLK") = 1e-05;
pf.l("CAP") = 1.0;
pf.l("LAB") = 1.0;
py.l("BRD") = 1.0;
py.l("MLK") = 1.0;
pz.l("BRD") = 1.0;
pz.l("MLK") = 1.0;
pq.l("BRD") = 1.0;
pq.l("MLK") = 1.0;
pe.l("BRD") = 1.0;
pe.l("MLK") = 1.0;
pm.l("BRD") = 1.0;
pm.l("MLK") = 1.0;
pd.l("BRD") = 1.0;
pd.l("MLK") = 1.0;
epsilon.l = 1.0;
Sp.l = 1e-05;
Sg.l = 1e-05;
Td.l = 1e-05;

* ============================================
* Post-solve Calibration (variable .l references)
* ============================================

$onImplicitAssign
dY(j) = (y.l(j) / Y0(j) - 1) * 100;
dF(h,j) = (f.l(h,j) / F0(h,j) - 1) * 100;
dX(i,j) = (x.l(i,j) / X0(i,j) - 1) * 100;
dZ(j) = (z.l(j) / Z0(j) - 1) * 100;
dXp(i) = (xp.l(i) / Xp0(i) - 1) * 100;
dXg(i) = (xg.l(i) / Xg0(i) - 1) * 100;
dXv(i) = (xv.l(i) / Xv0(i) - 1) * 100;
dE(i) = (e.l(i) / E0(i) - 1) * 100;
dM(i) = (m.l(i) / M0(i) - 1) * 100;
dQ(i) = (q.l(i) / Q0(i) - 1) * 100;
dD(i) = (d.l(i) / D0(i) - 1) * 100;
dpf(h) = (pf.l(h) / 1 - 1) * 100;
dpy(j) = (py.l(j) / 1 - 1) * 100;
dpz(j) = (pz.l(j) / 1 - 1) * 100;
dpq(i) = (pq.l(i) / 1 - 1) * 100;
dpe(i) = (pe.l(i) / 1 - 1) * 100;
dpm(i) = (pm.l(i) / 1 - 1) * 100;
dpd(i) = (pd.l(i) / 1 - 1) * 100;
depsilon = (epsilon.l / 1 - 1) * 100;
dTd = (td.l / Td0 - 1) * 100;
dTz(j) = (tz.l(j) / Tz0(j) - 1) * 100;
dTm(i) = (tm.l(i) / Tm0(i) - 1) * 100;
dSp = (sp.l / Sp0 - 1) * 100;
dSg = (sg.l / Sg0 - 1) * 100;
ep1 = uu.l / prod(i, (alpha(i) / 1) ** alpha(i));
$offImplicitAssign

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_d(i)
    stat_e(i)
    stat_epsilon
    stat_f(h,j)
    stat_m(i)
    stat_pd(i)
    stat_pe(i)
    stat_pf(h)
    stat_pm(i)
    stat_pq(i)
    stat_py(j)
    stat_pz(j)
    stat_q(i)
    stat_sg
    stat_sp
    stat_td
    stat_tm(i)
    stat_tz(j)
    stat_uu
    stat_x(i,j)
    stat_xg(i)
    stat_xp(i)
    stat_xv(i)
    stat_y(j)
    stat_z(j)
    comp_lo_d(i)
    comp_lo_e(i)
    comp_lo_epsilon
    comp_lo_f(h,j)
    comp_lo_m(i)
    comp_lo_pd(i)
    comp_lo_pe(i)
    comp_lo_pf(h)
    comp_lo_pm(i)
    comp_lo_pq(i)
    comp_lo_py(j)
    comp_lo_pz(j)
    comp_lo_q(i)
    comp_lo_sg
    comp_lo_sp
    comp_lo_td
    comp_lo_tm(i)
    comp_lo_tz(j)
    comp_lo_x(i,j)
    comp_lo_xg(i)
    comp_lo_xp(i)
    comp_lo_xv(i)
    comp_lo_y(j)
    comp_lo_z(j)
    eqD(i)
    eqDs(i)
    eqE(i)
    eqF(h,j)
    eqM(i)
    eqSg
    eqSp
    eqTd
    eqTm(i)
    eqTz(j)
    eqX(i,j)
    eqXg(i)
    eqXp(i)
    eqXv(i)
    eqY(j)
    eqepsilon
    eqpe(i)
    eqpf(h)
    eqpm(i)
    eqpqd(i)
    eqpqs(i)
    eqpy(j)
    eqpzd(i)
    eqpzs(j)
    obj
    pf_fx_LAB
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(h, h__);
Alias(i, i__);

* Stationarity equations
stat_d(i).. ((-1) * (gamma(i) * (deltam(i) * m(i) ** eta(i) + deltad(i) * d(i) ** eta(i)) ** (1 / eta(i)) * 1 / eta(i) / (deltam(i) * m(i) ** eta(i) + deltad(i) * d(i) ** eta(i)) * deltad(i) * d(i) ** eta(i) * eta(i) / d(i))) * nu_eqpqs(i) + nu_eqD(i) + ((-1) * (theta(i) * (xie(i) * e(i) ** phi(i) + xid(i) * d(i) ** phi(i)) ** (1 / phi(i)) * 1 / phi(i) / (xie(i) * e(i) ** phi(i) + xid(i) * d(i) ** phi(i)) * xid(i) * d(i) ** phi(i) * phi(i) / d(i))) * nu_eqpzd(i) + nu_eqDs(i) - piL_d(i) =E= 0;
stat_e(i).. pWe(i) * nu_eqepsilon + ((-1) * (theta(i) * (xie(i) * e(i) ** phi(i) + xid(i) * d(i) ** phi(i)) ** (1 / phi(i)) * 1 / phi(i) / (xie(i) * e(i) ** phi(i) + xid(i) * d(i) ** phi(i)) * xie(i) * e(i) ** phi(i) * phi(i) / e(i))) * nu_eqpzd(i) + nu_eqE(i) - piL_e(i) =E= 0;
stat_epsilon.. sum(i, ((-1) * (pq(i) * lambda(i) * Sf / pq(i) ** 2)) * nu_eqXv(i)) + sum(i, ((-1) * pWe(i)) * nu_eqpe(i)) + sum(i, ((-1) * pWm(i)) * nu_eqpm(i)) - piL_epsilon =E= 0;
stat_f(h,j).. ((-1) * (b(j) * prod(h__, f(h__,j) ** beta(h__,j)) * sum(h__, f(h__,j) ** beta(h__,j) * beta(h__,j) / f(h__,j) / f(h__,j) ** beta(h__,j)))) * nu_eqpy(j) + nu_eqF(h,j) - nu_eqpf(h) - piL_f(h,j) =E= 0;
stat_m(i).. ((-1) * (taum(i) * pm(i))) * nu_eqTm(i) + ((-1) * pWm(i)) * nu_eqepsilon + ((-1) * (gamma(i) * (deltam(i) * m(i) ** eta(i) + deltad(i) * d(i) ** eta(i)) ** (1 / eta(i)) * 1 / eta(i) / (deltam(i) * m(i) ** eta(i) + deltad(i) * d(i) ** eta(i)) * deltam(i) * m(i) ** eta(i) * eta(i) / m(i))) * nu_eqpqs(i) + nu_eqM(i) - piL_m(i) =E= 0;
stat_pd(i).. ((-1) * (q(i) * (gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) * ((-1) * (gamma(i) ** eta(i) * deltad(i) * pq(i))) / pd(i) ** 2)) * nu_eqD(i) + ((-1) * (z(i) * (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) * ((-1) * (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i))) / pd(i) ** 2)) * nu_eqDs(i) - piL_pd(i) =E= 0;
stat_pe(i).. nu_eqpe(i) + ((-1) * (z(i) * (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) * ((-1) * (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i))) / pe(i) ** 2)) * nu_eqE(i) - piL_pe(i) =E= 0;
stat_pf(h).. sum(j, ((-1) * (((-1) * (beta(h,j) * py(j) * y(j))) / pf(h) ** 2)) * nu_eqF(h,j)) + ((-1) * (taud * FF(h))) * nu_eqTd + ((-1) * (ssp * FF(h))) * nu_eqSp + sum(i, ((-1) * (pq(i) * alpha(i) * FF(h) / pq(i) ** 2)) * nu_eqXp(i)) + nu_pf_fx_LAB$sameas(h, 'LAB') - piL_pf(h) =E= 0;
stat_pm(i).. ((-1) * (m(i) * taum(i))) * nu_eqTm(i) + nu_eqpm(i) + ((-1) * (q(i) * (gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) * ((-1) * (gamma(i) ** eta(i) * deltam(i) * pq(i) * (1 + taum(i)))) / ((1 + taum(i)) * pm(i)) ** 2)) * nu_eqM(i) - piL_pm(i) =E= 0;
stat_pq(i).. sum(j, ((-1) * ax(i,j)) * nu_eqpzs(j)) + ((-1) * (((-1) * (mu(i) * (td + sum(j, tz(j)) + sum(j, tm(j)) - sg))) / pq(i) ** 2)) * nu_eqXg(i) + ((-1) * (((-1) * (lambda(i) * (sp + sg + epsilon * Sf))) / pq(i) ** 2)) * nu_eqXv(i) + ((-1) * (((-1) * (alpha(i) * (sum(h, pf(h) * FF(h)) + sum(j, FC(j)) - sp - td))) / pq(i) ** 2)) * nu_eqXp(i) + ((-1) * (q(i) * (gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) * (1 + taum(i)) * pm(i) * gamma(i) ** eta(i) * deltam(i) / ((1 + taum(i)) * pm(i)) ** 2)) * nu_eqM(i) + ((-1) * (q(i) * (gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) ** (1 / (1 - eta(i))) * 1 / (1 - eta(i)) / (gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) * pd(i) * gamma(i) ** eta(i) * deltad(i) / pd(i) ** 2)) * nu_eqD(i) - piL_pq(i) =E= 0;
stat_py(j).. sum(h, ((-1) * (pf(h) * y(j) * beta(h,j) / pf(h) ** 2)) * nu_eqF(h,j)) + ((-1) * ay(j)) * nu_eqpzs(j) - piL_py(j) =E= 0;
stat_pz(j).. nu_eqpzs(j) + ((-1) * (z(j) * tauz(j))) * nu_eqTz(j) + sum(i, ((-1) * (z(i) * (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) * pe(i) * theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) / pe(i) ** 2)) * nu_eqE(i)) + sum(i, ((-1) * (z(i) * (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) ** (1 / (1 - phi(i))) * 1 / (1 - phi(i)) / (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) * pd(i) * theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) / pd(i) ** 2)) * nu_eqDs(i)) - piL_pz(j) =E= 0;
stat_q(i).. nu_eqpqs(i) + ((-1) * ((gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) ** (1 / (1 - eta(i))))) * nu_eqM(i) + ((-1) * ((gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) ** (1 / (1 - eta(i))))) * nu_eqD(i) + nu_eqpqd(i) - piL_q(i) =E= 0;
stat_sg.. sum(i, ((-1) * (pq(i) * mu(i) * (-1) / pq(i) ** 2)) * nu_eqXg(i)) + sum(i, ((-1) * (pq(i) * lambda(i) / pq(i) ** 2)) * nu_eqXv(i)) + nu_eqSg - piL_sg =E= 0;
stat_sp.. sum(i, ((-1) * (pq(i) * lambda(i) / pq(i) ** 2)) * nu_eqXv(i)) + nu_eqSp + sum(i, ((-1) * (pq(i) * alpha(i) * (-1) / pq(i) ** 2)) * nu_eqXp(i)) - piL_sp =E= 0;
stat_td.. nu_eqTd + sum(i, ((-1) * (pq(i) * mu(i) / pq(i) ** 2)) * nu_eqXg(i)) + ((-1) * ssg) * nu_eqSg + sum(i, ((-1) * (pq(i) * alpha(i) * (-1) / pq(i) ** 2)) * nu_eqXp(i)) - piL_td =E= 0;
stat_tm(i).. nu_eqTm(i) + ((-1) * (pq(i) * mu(i) / pq(i) ** 2)) * nu_eqXg(i) + ((-1) * ssg) * nu_eqSg - piL_tm(i) =E= 0;
stat_tz(j).. nu_eqTz(j) + sum(i, ((-1) * (pq(i) * mu(i) / pq(i) ** 2)) * nu_eqXg(i)) + ((-1) * ssg) * nu_eqSg - piL_tz(j) =E= 0;
stat_uu.. 0 =E= 0;
stat_x(i,j).. nu_eqX(i,j) - piL_x(i,j) =E= 0;
stat_xg(i).. nu_eqXg(i) - nu_eqpqd(i) - piL_xg(i) =E= 0;
stat_xp(i).. ((-1) * (prod(i__, xp(i__) ** alpha(i__)) * sum(i__, xp(i__) ** alpha(i__) * alpha(i__) / xp(i__) / xp(i__) ** alpha(i__)))) + nu_eqXp(i) - nu_eqpqd(i) - piL_xp(i) =E= 0;
stat_xv(i).. nu_eqXv(i) - nu_eqpqd(i) - piL_xv(i) =E= 0;
stat_y(j).. nu_eqpy(j) + nu_eqY(j) + sum(h, ((-1) * (pf(h) * beta(h,j) * py(j) / pf(h) ** 2)) * nu_eqF(h,j)) - piL_y(j) =E= 0;
stat_z(j).. sum(i, ((-1) * ax(j,j)) * nu_eqX(i,j)) + ((-1) * ay(j)) * nu_eqY(j) + ((-1) * (((-1) * FC(j)) / z(j) ** 2)) * nu_eqpzs(j) + ((-1) * (tauz(j) * pz(j))) * nu_eqTz(j) + sum(i, nu_eqpzd(i)) + sum(i, ((-1) * ((theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) ** (1 / (1 - phi(i))))) * nu_eqE(i)) + sum(i, ((-1) * ((theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) ** (1 / (1 - phi(i))))) * nu_eqDs(i)) - piL_z(j) =E= 0;

* Lower bound complementarity equations
comp_lo_d(i).. d(i) - 1e-05 =G= 0;
comp_lo_e(i).. e(i) - 1e-05 =G= 0;
comp_lo_epsilon.. epsilon - 1e-05 =G= 0;
comp_lo_f(h,j).. f(h,j) - 0 =G= 0;
comp_lo_m(i).. m(i) - 1e-05 =G= 0;
comp_lo_pd(i).. pd(i) - 1e-05 =G= 0;
comp_lo_pe(i).. pe(i) - 1e-05 =G= 0;
comp_lo_pf(h).. pf(h) - 1e-05 =G= 0;
comp_lo_pm(i).. pm(i) - 1e-05 =G= 0;
comp_lo_pq(i).. pq(i) - 1e-05 =G= 0;
comp_lo_py(j).. py(j) - 1e-05 =G= 0;
comp_lo_pz(j).. pz(j) - 1e-05 =G= 0;
comp_lo_q(i).. q(i) - 1e-05 =G= 0;
comp_lo_sg.. sg - 1e-05 =G= 0;
comp_lo_sp.. sp - 1e-05 =G= 0;
comp_lo_td.. td - 1e-05 =G= 0;
comp_lo_tm(i).. tm(i) - 0 =G= 0;
comp_lo_tz(j).. tz(j) - 0 =G= 0;
comp_lo_x(i,j).. x(i,j) - 1e-05 =G= 0;
comp_lo_xg(i).. xg(i) - 1e-05 =G= 0;
comp_lo_xp(i).. xp(i) - 1e-05 =G= 0;
comp_lo_xv(i).. xv(i) - 1e-05 =G= 0;
comp_lo_y(j).. y(j) - 1e-05 =G= 0;
comp_lo_z(j).. z(j) - 1e-05 =G= 0;

* Original equality equations
eqpy(j).. y(j) =E= b(j) * prod(h, f(h,j) ** beta(h,j));
eqX(i,j).. x(i,j) =E= ax(i,j) * z(j);
eqY(j).. y(j) =E= ay(j) * z(j);
eqF(h,j).. f(h,j) =E= beta(h,j) * py(j) * y(j) / pf(h);
eqpzs(j).. pz(j) =E= ay(j) * py(j) + sum(i, ax(i,j) * pq(i)) + FC(j) / z(j);
eqTd.. td =E= taud * (sum(h, pf(h) * FF(h)) + sum(j, FC(j)));
eqTz(j).. tz(j) =E= tauz(j) * pz(j) * z(j);
eqTm(i).. tm(i) =E= taum(i) * pm(i) * m(i);
eqXg(i).. xg(i) =E= mu(i) * (td + sum(j, tz(j)) + sum(j, tm(j)) - sg) / pq(i);
eqXv(i).. xv(i) =E= lambda(i) * (sp + sg + epsilon * Sf) / pq(i);
eqSp.. sp =E= ssp * (sum(h, pf(h) * FF(h)) + sum(j, FC(j)));
eqSg.. sg =E= ssg * (td + sum(j, tz(j)) + sum(j, tm(j)));
eqXp(i).. xp(i) =E= alpha(i) * (sum(h, pf(h) * FF(h)) + sum(j, FC(j)) - sp - td) / pq(i);
eqpe(i).. pe(i) =E= epsilon * pWe(i);
eqpm(i).. pm(i) =E= epsilon * pWm(i);
eqepsilon.. sum(i, pWe(i) * e(i)) + Sf =E= sum(i, pWm(i) * m(i));
eqpqs(i).. q(i) =E= gamma(i) * (deltam(i) * m(i) ** eta(i) + deltad(i) * d(i) ** eta(i)) ** (1 / eta(i));
eqM(i).. m(i) =E= (gamma(i) ** eta(i) * deltam(i) * pq(i) / ((1 + taum(i)) * pm(i))) ** (1 / (1 - eta(i))) * q(i);
eqD(i).. d(i) =E= (gamma(i) ** eta(i) * deltad(i) * pq(i) / pd(i)) ** (1 / (1 - eta(i))) * q(i);
eqpzd(i).. z(i) =E= theta(i) * (xie(i) * e(i) ** phi(i) + xid(i) * d(i) ** phi(i)) ** (1 / phi(i));
eqE(i).. e(i) =E= (theta(i) ** phi(i) * xie(i) * (1 + tauz(i)) * pz(i) / pe(i)) ** (1 / (1 - phi(i))) * z(i);
eqDs(i).. d(i) =E= (theta(i) ** phi(i) * xid(i) * (1 + tauz(i)) * pz(i) / pd(i)) ** (1 / (1 - phi(i))) * z(i);
eqpqd(i).. q(i) =E= xp(i) + xg(i) + xv(i) + sum(j, x(i,j));
eqpf(h).. FF(h) =E= sum(j, f(h,j));
obj.. uu =E= prod(i, xp(i) ** alpha(i));
pf_fx_LAB.. pf("LAB") - 1 =E= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_d.d,
    stat_e.e,
    stat_epsilon.epsilon,
    stat_f.f,
    stat_m.m,
    stat_pd.pd,
    stat_pe.pe,
    stat_pf.pf,
    stat_pm.pm,
    stat_pq.pq,
    stat_py.py,
    stat_pz.pz,
    stat_q.q,
    stat_sg.sg,
    stat_sp.sp,
    stat_td.td,
    stat_tm.tm,
    stat_tz.tz,
    stat_uu.uu,
    stat_x.x,
    stat_xg.xg,
    stat_xp.xp,
    stat_xv.xv,
    stat_y.y,
    stat_z.z,
    eqD.nu_eqD,
    eqDs.nu_eqDs,
    eqE.nu_eqE,
    eqF.nu_eqF,
    eqM.nu_eqM,
    eqSg.nu_eqSg,
    eqSp.nu_eqSp,
    eqTd.nu_eqTd,
    eqTm.nu_eqTm,
    eqTz.nu_eqTz,
    eqX.nu_eqX,
    eqXg.nu_eqXg,
    eqXp.nu_eqXp,
    eqXv.nu_eqXv,
    eqY.nu_eqY,
    eqepsilon.nu_eqepsilon,
    eqpe.nu_eqpe,
    eqpf.nu_eqpf,
    eqpm.nu_eqpm,
    eqpqd.nu_eqpqd,
    eqpqs.nu_eqpqs,
    eqpy.nu_eqpy,
    eqpzd.nu_eqpzd,
    eqpzs.nu_eqpzs,
    obj.UU,
    pf_fx_LAB.nu_pf_fx_LAB,
    comp_lo_d.piL_d,
    comp_lo_e.piL_e,
    comp_lo_epsilon.piL_epsilon,
    comp_lo_f.piL_f,
    comp_lo_m.piL_m,
    comp_lo_pd.piL_pd,
    comp_lo_pe.piL_pe,
    comp_lo_pf.piL_pf,
    comp_lo_pm.piL_pm,
    comp_lo_pq.piL_pq,
    comp_lo_py.piL_py,
    comp_lo_pz.piL_pz,
    comp_lo_q.piL_q,
    comp_lo_sg.piL_sg,
    comp_lo_sp.piL_sp,
    comp_lo_td.piL_td,
    comp_lo_tm.piL_tm,
    comp_lo_tz.piL_tz,
    comp_lo_x.piL_x,
    comp_lo_xg.piL_xg,
    comp_lo_xp.piL_xp,
    comp_lo_xv.piL_xv,
    comp_lo_y.piL_y,
    comp_lo_z.piL_z
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = UU.l;
Display nlp2mcp_obj_val;