$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    inityrs /'1985', '1986', '1987', '1988', '1989'/
    bsyr
    t /'1990', '1995', '2000', '2005', '2010', '2015', '2020', '2025', '2030'/
    tfirst(t)
    tlast(t)
    nypset /'1', '2', '3', '4', '5'/
;

Parameters
    dfactcurr(t) /'1990' 0.96, '1995' 0.96, '2000' 0.96, '2005' 0.96, '2010' 0.96, '2015' 0.96, '2020' 0.96, '2025' 0.96, '2030' 0.96/
    dfact(t)
    grow(t) /'1990' 0.03, '1995' 0.03, '2000' 0.03, '2005' 0.03, '2010' 0.03, '2015' 0.03, '2020' 0.03, '2025' 0.03, '2030' 0.03/
    pegrow(t) /'1990' 0.01, '1995' 0.01, '2000' 0.01, '2005' 0.01, '2010' 0.01, '2015' 0.01, '2020' 0.01, '2025' 0.01, '2030' 0.01/
    pelec(t)
    pngrow(t) /'1990' 0.02, '1995' 0.02, '2000' 0.02, '2005' 0.02, '2010' 0.02, '2015' 0.02, '2020' 0.02, '2025' 0.02, '2030' 0.02/
    pnelec(t)
    l(t)
    ln(t)
    ipm(t)
    htrt(t) /'1990' 10.809, '1995' 10.809, '2000' 10.809, '2005' 10.809, '2010' 10.809, '2015' 10.809, '2020' 10.809, '2025' 10.809, '2030' 10.809/
    knew(t)
;

Scalars
    nyper /5.0/
    spda /0.96/
    kpvs /0.28/
    elvs /0.35/
    esub /0.45/
    k0 /10.9/
    e0 /2.5/
    n0 /50.0/
    i0 /0.7/
    c0 /3.2/
    pe0 /50.0/
    pn0 /4.5/
    pnref /3.0/
    y0 /0.0/
    htrt0 /10.809/
    thsnd /1000.0/
    rho /0.0/
    aconst /0.0/
    bconst /0.0/
    ninit /0.0/
    tol /0.3/
;

bsyr(inityrs) = 1$(ord(inityrs) = 1);
tfirst(t) = 1$(ord(t) = 1);
tlast(t) = 1$(ord(t) = card(t));

y0 = i0 + c0 + (e0 * pe0 + n0 * pn0) / thsnd;
rho = (esub - 1) / esub;
aconst = (y0 ** rho - bconst * e0 ** (rho * elvs) * n0 ** (rho * (1 - elvs))) / k0 ** (rho * kpvs);
bconst = pnref / thsnd * y0 ** (rho - 1) / ((1 - elvs) * e0 ** (rho * elvs) * n0 ** (rho * (1 - elvs) - 1));
ninit = card(inityrs);
dfact(tfirst) = dfactcurr(tfirst) ** ninit;
dfact(tlast) = dfact(tlast) / (1 - dfactcurr(tlast));
pelec(tfirst) = pe0 * (1 + pegrow(tfirst)) ** ninit;
pnelec(tfirst) = pn0 * (1 + pngrow(tfirst)) ** ninit;
l(tfirst) = (1 + grow(tfirst)) ** ninit;
ln(tfirst) = l(tfirst) - spda ** ninit;
ipm(t) = sum(nypset, spda ** (ord(nypset) - 1) * (1 + grow(t)) ** (nyper - ord(nypset)));
knew(tfirst) = i0 * sum(inityrs, spda ** (ord(inityrs) - 1) * (1 + grow(tfirst)) ** (ninit - ord(inityrs)));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    k(t)
    kn(t)
    y(t)
    yn(t)
    e(t)
    en(t)
    n(t)
    nn(t)
    c(t)
    i(t)
    ec(t)
    utility
    nu_newcap(t)
    nu_fnewelec(t)
    nu_newelec(t)
    nu_fnewnon(t)
    nu_newnon(t)
    nu_totalcap(t)
    nu_ftotalprod(t)
    nu_totalprod(t)
    nu_costnrg(t)
    nu_cc(t)
;

Positive Variables
    lam_tc(t)
    piL_k(t)
    piL_e(t)
    piL_n(t)
    piL_c(t)
    piL_i(t)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

k.l("1990") = 10.9;
k.l("1995") = 10.9;
k.l("2000") = 10.9;
k.l("2005") = 10.9;
k.l("2010") = 10.9;
k.l("2015") = 10.9;
k.l("2020") = 10.9;
k.l("2025") = 10.9;
k.l("2030") = 10.9;
e.l("1990") = 2.5;
e.l("1995") = 2.5;
e.l("2000") = 2.5;
e.l("2005") = 2.5;
e.l("2010") = 2.5;
e.l("2015") = 2.5;
e.l("2020") = 2.5;
e.l("2025") = 2.5;
e.l("2030") = 2.5;
n.l("1990") = 50.0;
n.l("1995") = 50.0;
n.l("2000") = 50.0;
n.l("2005") = 50.0;
n.l("2010") = 50.0;
n.l("2015") = 50.0;
n.l("2020") = 50.0;
n.l("2025") = 50.0;
n.l("2030") = 50.0;
c.l("1990") = 3.2;
c.l("1995") = 3.2;
c.l("2000") = 3.2;
c.l("2005") = 3.2;
c.l("2010") = 3.2;
c.l("2015") = 3.2;
c.l("2020") = 3.2;
c.l("2025") = 3.2;
c.l("2030") = 3.2;
i.l("1990") = 0.7;
i.l("1995") = 0.7;
i.l("2000") = 0.7;
i.l("2005") = 0.7;
i.l("2010") = 0.7;
i.l("2015") = 0.7;
i.l("2020") = 0.7;
i.l("2025") = 0.7;
i.l("2030") = 0.7;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_c(t)
    stat_e(t)
    stat_ec(t)
    stat_en(t)
    stat_i(t)
    stat_k(t)
    stat_kn(t)
    stat_n(t)
    stat_nn(t)
    stat_y(t)
    stat_yn(t)
    comp_tc(t)
    comp_lo_c(t)
    comp_lo_e(t)
    comp_lo_i(t)
    comp_lo_k(t)
    comp_lo_n(t)
    cc(t)
    costnrg(t)
    fnewelec(t)
    fnewnon(t)
    ftotalprod(t)
    newcap(t)
    newelec(t)
    newnon(t)
    totalcap(t)
    totalprod(t)
    util
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_c(t).. ((-1) * (dfact(t) * 1 / c(t))) - nu_cc(t) - piL_c(t) =E= 0;
stat_e(t).. sum(tfirst, (-1) * nu_fnewelec(tfirst)) + spda ** nyper * nu_newelec(t) + ((-1) * pelec(t)) * nu_costnrg(t) - piL_e(t) =E= 0;
stat_ec(t).. thsnd * nu_costnrg(t) - nu_cc(t) =E= 0;
stat_en(t)$(tfirst(t)).. sum(tfirst, nu_fnewelec(tfirst)) + sum(tfirst, ((-1) * ((aconst * knew(t) ** (rho * kpvs) * ln(t) ** (rho * (1 - kpvs)) + bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs))) ** (1 / rho) * 1 / rho / (aconst * knew(t) ** (rho * kpvs) * ln(t) ** (rho * (1 - kpvs)) + bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs))) * nn(tfirst) ** (rho * (1 - elvs)) * bconst * en(tfirst) ** (rho * elvs) * rho * elvs / en(tfirst))) * nu_ftotalprod(tfirst)) =E= 0;
stat_i(t).. ((-1) * ipm(t)) * nu_newcap(t) - nu_cc(t) + sum(tlast, (-1) * lam_tc(tlast)) - piL_i(t) =E= 0;
stat_k(t)$(tlast(t)).. ((-1) * (spda ** nyper)) * nu_totalcap(t) + sum(tlast, (grow(t) + 1 - spda) * lam_tc(tlast)) - piL_k(t) =E= 0;
stat_kn(t).. 0 =E= 0;
stat_n(t).. sum(tfirst, (-1) * nu_fnewnon(tfirst)) + spda ** nyper * nu_newnon(t) + ((-1) * pnelec(t)) * nu_costnrg(t) - piL_n(t) =E= 0;
stat_nn(t)$(tfirst(t)).. sum(tfirst, nu_fnewnon(tfirst)) + sum(tfirst, ((-1) * ((aconst * knew(t) ** (rho * kpvs) * ln(t) ** (rho * (1 - kpvs)) + bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs))) ** (1 / rho) * 1 / rho / (aconst * knew(t) ** (rho * kpvs) * ln(t) ** (rho * (1 - kpvs)) + bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs))) * bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs)) * rho * (1 - elvs) / nn(tfirst))) * nu_ftotalprod(tfirst)) =E= 0;
stat_y(t).. sum(tfirst, nu_ftotalprod(tfirst)) + ((-1) * (spda ** nyper)) * nu_totalprod(t) + nu_cc(t) =E= 0;
stat_yn(t).. 0 =E= 0;

* Inequality complementarity equations
comp_tc(tlast).. ((-1) * (k(tlast) * (grow(tlast) + 1 - spda) - i(tlast))) =G= 0;

* Lower bound complementarity equations
comp_lo_c(t).. c(t) - 3.2 =G= 0;
comp_lo_e(t).. e(t) - 2.5 =G= 0;
comp_lo_i(t).. i(t) - 0.7 =G= 0;
comp_lo_k(t).. k(t) - 10.9 =G= 0;
comp_lo_n(t).. n(t) - 50 =G= 0;

* Original equality equations
newcap(t)$(ord(t) <= card(t) - 1).. kn(t+1) =E= i(t) * ipm(t);
fnewelec(tfirst).. en(tfirst) =E= e(tfirst) - e0 * spda ** nyper;
newelec(t)$(ord(t) <= card(t) - 1).. en(t+1) =E= e(t+1) - e(t) * spda ** nyper;
fnewnon(tfirst).. nn(tfirst) =E= n(tfirst) - n0 * spda ** nyper;
newnon(t)$(ord(t) <= card(t) - 1).. nn(t+1) =E= n(t+1) - n(t) * spda ** nyper;
totalcap(t)$(ord(t) <= card(t) - 1).. k(t+1) =E= k(t) * spda ** nyper + kn(t+1);
ftotalprod(tfirst).. y(tfirst) =E= y0 * spda ** ninit + (aconst * knew(tfirst) ** (rho * kpvs) * ln(tfirst) ** (rho * (1 - kpvs)) + bconst * en(tfirst) ** (rho * elvs) * nn(tfirst) ** (rho * (1 - elvs))) ** (1 / rho);
totalprod(t)$(ord(t) <= card(t) - 1).. y(t+1) =E= y(t) * spda ** nyper + yn(t+1);
costnrg(t).. thsnd * ec(t) =E= pelec(t) * e(t) + pnelec(t) * n(t);
cc(t).. y(t) =E= c(t) + i(t) + ec(t);
util.. utility =E= sum(t, dfact(t) * log(c(t)));


* ============================================
* Fix inactive variable instances
* ============================================

* Variables whose paired MCP equation is conditioned must be
* fixed for excluded instances to satisfy MCP matching.

en.fx(t)$(not (tfirst(t))) = 0;
k.fx(t)$(not (tlast(t))) = 0;
nn.fx(t)$(not (tfirst(t))) = 0;
nu_newcap.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;
nu_newelec.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;
nu_newnon.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;
nu_totalcap.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;
nu_totalprod.fx(t)$(not (ord(t) <= card(t) - 1)) = 0;

* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_c.c,
    stat_e.e,
    stat_ec.ec,
    stat_en.en,
    stat_i.i,
    stat_k.k,
    stat_kn.kn,
    stat_n.n,
    stat_nn.nn,
    stat_y.y,
    stat_yn.yn,
    comp_tc.lam_tc,
    cc.nu_cc,
    costnrg.nu_costnrg,
    fnewelec.nu_fnewelec,
    fnewnon.nu_fnewnon,
    ftotalprod.nu_ftotalprod,
    newcap.nu_newcap,
    newelec.nu_newelec,
    newnon.nu_newnon,
    totalcap.nu_totalcap,
    totalprod.nu_totalprod,
    util.utility,
    comp_lo_c.piL_c,
    comp_lo_e.piL_e,
    comp_lo_i.piL_i,
    comp_lo_k.piL_k,
    comp_lo_n.piL_n
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = utility.l;
Display nlp2mcp_obj_val;