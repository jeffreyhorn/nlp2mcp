$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    i /i1, i2, i3, i4, i5/
    ij(i,j)
;

Alias(i, j);

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    r
    x(i)
    y(i)
;

Positive Variables
    lam_circumscribe(i)
    lam_nooverlap(i,j)
    piL_r
    piL_x(i)
    piL_y(i)
    piU_r
    piU_x(i)
    piU_y(i)
;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_r
    stat_x(i)
    stat_y(i)
    comp_circumscribe(i)
    comp_nooverlap(i,j)
    comp_lo_r
    comp_lo_x(i)
    comp_lo_y(i)
    comp_up_r
    comp_up_x(i)
    comp_up_y(i)
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_r.. -1 + ((-1) * (2 * (1 - r) * (-1))) * lam_circumscribe("i1") + ((-1) * (2 * (1 - r) * (-1))) * lam_circumscribe("i2") + ((-1) * (2 * (1 - r) * (-1))) * lam_circumscribe("i3") + ((-1) * (2 * (1 - r) * (-1))) * lam_circumscribe("i4") + ((-1) * (2 * (1 - r) * (-1))) * lam_circumscribe("i5") + 4 * 2 * r * lam_nooverlap("i1","i1") + 4 * 2 * r * lam_nooverlap("i1","i2") + 4 * 2 * r * lam_nooverlap("i1","i3") + 4 * 2 * r * lam_nooverlap("i1","i4") + 4 * 2 * r * lam_nooverlap("i1","i5") + 4 * 2 * r * lam_nooverlap("i2","i1") + 4 * 2 * r * lam_nooverlap("i2","i2") + 4 * 2 * r * lam_nooverlap("i2","i3") + 4 * 2 * r * lam_nooverlap("i2","i4") + 4 * 2 * r * lam_nooverlap("i2","i5") + 4 * 2 * r * lam_nooverlap("i3","i1") + 4 * 2 * r * lam_nooverlap("i3","i2") + 4 * 2 * r * lam_nooverlap("i3","i3") + 4 * 2 * r * lam_nooverlap("i3","i4") + 4 * 2 * r * lam_nooverlap("i3","i5") + 4 * 2 * r * lam_nooverlap("i4","i1") + 4 * 2 * r * lam_nooverlap("i4","i2") + 4 * 2 * r * lam_nooverlap("i4","i3") + 4 * 2 * r * lam_nooverlap("i4","i4") + 4 * 2 * r * lam_nooverlap("i4","i5") + 4 * 2 * r * lam_nooverlap("i5","i1") + 4 * 2 * r * lam_nooverlap("i5","i2") + 4 * 2 * r * lam_nooverlap("i5","i3") + 4 * 2 * r * lam_nooverlap("i5","i4") + 4 * 2 * r * lam_nooverlap("i5","i5") - piL_r + piU_r =E= 0;
stat_x(i).. 0 + 2 * x(i) * lam_circumscribe(i) + sum(j, 0 * lam_nooverlap(i,j)) - piL_x(i) + piU_x(i) =E= 0;
stat_y(i).. 0 + 2 * y(i) * lam_circumscribe(i) + sum(j, 0 * lam_nooverlap(i,j)) - piL_y(i) + piU_y(i) =E= 0;

* Inequality complementarity equations
comp_circumscribe(i).. sqr(1 - r) =G= 0;
comp_nooverlap(i,j).. sqr(x(i) - x(j)) + sqr(y(i) - y(j)) =G= 0;

* Lower bound complementarity equations
comp_lo_r.. r - 0.05 =G= 0;
comp_lo_x(i).. x(i) + 1 =G= 0;
comp_lo_y(i).. y(i) + 1 =G= 0;

* Upper bound complementarity equations
comp_up_r.. 0.4 - r =G= 0;
comp_up_x(i).. 1 - x(i) =G= 0;
comp_up_y(i).. 1 - y(i) =G= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_x.x,
    stat_y.y,
    comp_circumscribe.lam_circumscribe,
    comp_nooverlap.lam_nooverlap,
    comp_lo_r.piL_r,
    comp_lo_x.piL_x,
    comp_lo_y.piL_y,
    comp_up_r.piU_r,
    comp_up_x.piU_x,
    comp_up_y.piU_y
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;