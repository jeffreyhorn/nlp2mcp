$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    u /BRD, MLK, CAP, LAB, HOH/
    i(u) /BRD, MLK/
    h(u) /CAP, LAB/
;

Alias(u, v);
Alias(i, j);
Alias(h, k);

Parameters
    SAM(u,v) /BRD.HOH 15.0, MLK.HOH 35.0, CAP.BRD 5.0, CAP.MLK 20.0, LAB.BRD 10.0, LAB.MLK 15.0, HOH.CAP 25.0, HOH.LAB 25.0, MLK.BRD 0.0, MLK.MLK 0.0, MLK.CAP 0.0, MLK.LAB 0.0, HOH.BRD 0.0, HOH.MLK 0.0, HOH.HOH 0.0, BRD.BRD 0.0, BRD.MLK 0.0, BRD.CAP 0.0, BRD.LAB 0.0, CAP.CAP 0.0, CAP.LAB 0.0, CAP.HOH 0.0, LAB.CAP 0.0, LAB.LAB 0.0, LAB.HOH 0.0/
    X0(i)
    F0(h,j)
    Z0(j)
    FF(h)
    alpha(i)
    beta(h,j)
    b(j)
;

X0(i) = SAM(i,"HOH");
F0(h,j) = SAM(h,j);
Z0(j) = sum(h, F0(h,j));
FF(h) = SAM("HOH",h);
alpha(i) = X0(i) / sum(j, X0(j));
beta(h,j) = F0(h,j) / sum(k, F0(k,j));
b(j) = Z0(j) / prod(h, F0(h,j) ** beta(h,j));

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    X(i)
    F(h,j)
    Z(j)
    px(i)
    pz(j)
    pf(h)
    UU
    nu_eqX(i)
    nu_eqpz(j)
    nu_eqF(h,j)
    nu_eqpx(i)
    nu_eqpf(h)
    nu_eqZ(i)
    nu_pf_fx_LAB
;

Positive Variables
    piL_x(i)
    piL_f(h,j)
    piL_z(j)
    piL_px(i)
    piL_pz(j)
    piL_pf(h)
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.

X.l("BRD") = 0.001;
X.l("MLK") = 0.001;
F.l("CAP","BRD") = 0.001;
F.l("CAP","MLK") = 0.001;
F.l("LAB","BRD") = 0.001;
F.l("LAB","MLK") = 0.001;
Z.l("BRD") = 0.001;
Z.l("MLK") = 0.001;
px.l("BRD") = 1.0;
px.l("MLK") = 1.0;
pz.l("BRD") = 1.0;
pz.l("MLK") = 1.0;
pf.l("CAP") = 1.0;
pf.l("LAB") = 1.0;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_f(h,j)
    stat_pf(h)
    stat_px(i)
    stat_pz(j)
    stat_uu
    stat_x(i)
    stat_z(j)
    comp_lo_f(h,j)
    comp_lo_pf(h)
    comp_lo_px(i)
    comp_lo_pz(j)
    comp_lo_x(i)
    comp_lo_z(j)
    eqF(h,j)
    eqX(i)
    eqZ(i)
    eqpf(h)
    eqpx(i)
    eqpz(j)
    obj
    pf_fx_LAB
;

* ============================================
* Equation Definitions
* ============================================

* Index aliases to avoid 'Set is under control already' error
* (GAMS Error 125 when equation domain index is reused in sum)
Alias(h, h__);
Alias(i, i__);

* Stationarity equations
stat_f(h,j).. ((-1) * (b(j) * prod(h__, f(h__,j) ** beta(h__,j)) * sum(h__, f(h__,j) ** beta(h__,j) * beta(h__,j) / f(h__,j) / f(h__,j) ** beta(h__,j)))) * nu_eqpz(j) + nu_eqF(h,j) + nu_eqpf(h) - piL_f(h,j) =E= 0;
stat_pf(h).. sum(i, ((-1) * (px(i) * alpha(i) * FF(h) / px(i) ** 2)) * nu_eqX(i)) + sum(j, ((-1) * (((-1) * (beta(h,j) * pz(j) * z(j))) / pf(h) ** 2)) * nu_eqF(h,j)) + nu_pf_fx_LAB$sameas(h, 'LAB') - piL_pf(h) =E= 0;
stat_px(i).. ((-1) * (((-1) * (alpha(i) * sum(h, pf(h) * FF(h)))) / px(i) ** 2)) * nu_eqX(i) + nu_eqZ(i) - piL_px(i) =E= 0;
stat_pz(j).. sum(h, ((-1) * (pf(h) * z(j) * beta(h,j) / pf(h) ** 2)) * nu_eqF(h,j)) + sum(i, (-1) * nu_eqZ(i)) - piL_pz(j) =E= 0;
stat_uu.. 0 =E= 0;
stat_x(i).. ((-1) * (prod(i__, x(i__) ** alpha(i__)) * sum(i__, x(i__) ** alpha(i__) * alpha(i__) / x(i__) / x(i__) ** alpha(i__)))) + nu_eqX(i) + nu_eqpx(i) - piL_x(i) =E= 0;
stat_z(j).. nu_eqpz(j) + sum(h, ((-1) * (pf(h) * beta(h,j) * pz(j) / pf(h) ** 2)) * nu_eqF(h,j)) + sum(i, (-1) * nu_eqpx(i)) - piL_z(j) =E= 0;

* Lower bound complementarity equations
comp_lo_f(h,j).. f(h,j) - 0.001 =G= 0;
comp_lo_pf(h).. pf(h) - 0.001 =G= 0;
comp_lo_px(i).. px(i) - 0.001 =G= 0;
comp_lo_pz(j).. pz(j) - 0.001 =G= 0;
comp_lo_x(i).. x(i) - 0.001 =G= 0;
comp_lo_z(j).. z(j) - 0.001 =G= 0;

* Original equality equations
eqX(i).. x(i) =E= alpha(i) * sum(h, pf(h) * FF(h)) / px(i);
eqpz(j).. z(j) =E= b(j) * prod(h, f(h,j) ** beta(h,j));
eqF(h,j).. f(h,j) =E= beta(h,j) * pz(j) * z(j) / pf(h);
eqpx(i).. x(i) =E= z(i);
eqpf(h).. sum(j, f(h,j)) =E= FF(h);
eqZ(i).. px(i) =E= pz(i);
obj.. uu =E= prod(i, x(i) ** alpha(i));
pf_fx_LAB.. pf("LAB") - 1 =E= 0;


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_f.f,
    stat_pf.pf,
    stat_px.px,
    stat_pz.pz,
    stat_uu.uu,
    stat_x.x,
    stat_z.z,
    eqF.nu_eqF,
    eqX.nu_eqX,
    eqZ.nu_eqZ,
    eqpf.nu_eqpf,
    eqpx.nu_eqpx,
    eqpz.nu_eqpz,
    obj.UU,
    pf_fx_LAB.nu_pf_fx_LAB,
    comp_lo_f.piL_f,
    comp_lo_pf.piL_pf,
    comp_lo_px.piL_px,
    comp_lo_pz.piL_pz,
    comp_lo_x.piL_x,
    comp_lo_z.piL_z
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = UU.l;
Display nlp2mcp_obj_val;