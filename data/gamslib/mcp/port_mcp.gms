$onText
Generated by nlp2mcp

This file contains the KKT (Karush-Kuhn-Tucker) conditions
for the original NLP model, transformed into MCP format.

KKT System Components:
  - Stationarity: ∇f + J^T λ + J^T ν - π^L + π^U = 0
  - Complementarity: g(x) ⊥ λ, h(x) = 0, bounds ⊥ π
  - Dual feasibility: λ, π^L, π^U ≥ 0
  - Primal feasibility: g(x) ≤ 0, h(x) = 0, lo ≤ x ≤ up
$offText

* ============================================
* Original Model Declarations
* ============================================

Sets
    b /'municip-a', 'municip-b', corporate, 'us-ser-e', 'us-ser-f'/
    g(b) /corporate, 'us-ser-e', 'us-ser-f'/
;

Parameters
    ydat(b,*) /'municip-a'.rating 2.0, 'municip-a'.maturity 9.0, 'municip-a'.yield 4.3, 'municip-b'.rating 5.0, 'municip-b'.maturity 2.0, 'municip-b'.yield 4.5, corporate.rating 2.0, corporate.maturity 15.0, corporate.yield 5.4, corporate.'tax-rate' 0.5, 'us-ser-e'.rating 1.0, 'us-ser-e'.maturity 4.0, 'us-ser-e'.yield 5.0, 'us-ser-e'.'tax-rate' 0.5, 'us-ser-f'.rating 1.0, 'us-ser-f'.maturity 3.0, 'us-ser-f'.yield 4.4, 'us-ser-f'.'tax-rate' 0.5, 'municip-b'.'tax-rate' 0.0, 'municip-a'.'tax-rate' 0.0/
;

* ============================================
* Variables (Primal + Multipliers)
* ============================================

* Primal variables: Original decision variables from the NLP
* Multipliers:
*   ν (nu_*): Free multipliers for equality constraints
*   λ (lam_*): Positive multipliers for inequality constraints
*   π^L (piL_*): Positive multipliers for lower bounds
*   π^U (piU_*): Positive multipliers for upper bounds

Variables
    tinvest
    return
    nu_tdef
;

Positive Variables
    investment(b)
    lam_groupmin
    lam_rdef
    lam_mdef
    piU_tinvest
;

* ============================================
* Variable Initialization
* ============================================

* Initialize variables to avoid division by zero during model generation.
* Variables appearing in denominators (from log, 1/x derivatives) need
* non-zero initial values.
* POSITIVE variables are set to 1.

investment.l(b) = 1;

* ============================================
* Equations
* ============================================

* Stationarity: One equation per primal variable (except objvar)
* Complementarity: Equations for inequalities and bounds
* Equality constraints: Original equality constraints

Equations
    stat_investment(b)
    stat_tinvest
    comp_groupmin
    comp_mdef
    comp_rdef
    comp_up_tinvest
    idef
    tdef
;

* ============================================
* Equation Definitions
* ============================================

* Stationarity equations
stat_investment(b).. ((-1) * (ydat(b,"yield") / 100 * (1 - ydat(b,"tax-rate")))) - nu_tdef + ((-1) * lam_groupmin)$sameas(b, 'corporate') + ydat(b,"rating") * lam_rdef + ydat(b,"maturity") * lam_mdef =E= 0;
stat_tinvest.. nu_tdef - (-1.4) * lam_rdef - (-5) * lam_mdef + piU_tinvest =E= 0;

* Inequality complementarity equations
comp_groupmin.. sum(g, investment(g)) - 4 =G= 0;
comp_mdef.. ((-1) * (sum(b, ydat(b,"maturity") * investment(b)) - 5 * tinvest)) =G= 0;
comp_rdef.. ((-1) * (sum(b, ydat(b,"rating") * investment(b)) - 1.4 * tinvest)) =G= 0;

* Upper bound complementarity equations
comp_up_tinvest.. 10 - tinvest =G= 0;

* Original equality equations
tdef.. tinvest =E= sum(b, investment(b));
idef.. return =E= sum(b, ydat(b,"yield") / 100 * (1 - ydat(b,"tax-rate")) * investment(b));


* ============================================
* Model MCP Declaration
* ============================================

* Each line pairs an equation with a variable:
*   equation.variable
*
* This defines the complementarity problem:
*   equation ⊥ variable
*
* Meaning: equation = 0 if variable > 0
*          equation ≥ 0 if variable = 0

Model mcp_model /
    stat_investment.investment,
    stat_tinvest.tinvest,
    comp_groupmin.lam_groupmin,
    comp_mdef.lam_mdef,
    comp_rdef.lam_rdef,
    idef.return,
    tdef.nu_tdef,
    comp_up_tinvest.piU_tinvest
/;

* ============================================
* Solve Statement
* ============================================

Solve mcp_model using MCP;

Scalar nlp2mcp_obj_val;
nlp2mcp_obj_val = return.l;
Display nlp2mcp_obj_val;